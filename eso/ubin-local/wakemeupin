#!/usr/bin/perl
use warnings;
use strict;
use v5.19;
use constant true => 1, false => 0;
use Curses::UI;
use Term::ReadLine;


# --%version rules---------------------------------------------------------------------------------------------------
# add to minor +1 every time a complete run has been successful
# add to major +1 every time a full commit has been done on the repository
# increment the revision letter whenever more than 20% of code has been rewritten (ie, 'b' to 'c', or 'y' to 'z')
# letters are base-26 numbers: 'a,b,c..x,y,z,aa,ab,ac....ay,az,ba,bb...zx,zy,zz,aaa,aab' (are just as unlimited)
# reset revision to 'a' whenever the major (not minor) number is incremented
# change revision to 'final' when packaging for distribution, a fully tested and verified version release!
# change revision to 'alpha' for untested state releases
# change revision to 'beta' for user-tested state releases to be evaluated by volunteering users

my %version = ( major => 1,
				minor => 0,		revision => 'a' );
				
my $version = "v".$version{'major'}.".".$version{'minor'}." rev ".$version{'revision'};

my $cui = new Curses::UI( -color_support => 1 );
my @menu =( {-label=>'File',
							-submenu => [{
											-label => 'Exit		^Q',	-value => \&exit_dialog
										}]
			},
			{-label=>'Help',
							-submenu => [{
											-label => 'About	F1',	-value => \&about_dialog
										}]
			});

sub exit_dialog()
{
	my $ret = $cui->dialog	(	-message	=>	"Sure you want to exit now??",
								-title		=>	"Confirm Exit",
								-buttons	=>  ['Ok','Cancel'],
							);
	exit(0) if $ret;
}
sub about_dialog()
{
	my $author = "Gabriel Sharp";
	my $version = "1.0";
	my $copyright = "(C)2019";
	my $license = "GNU GPL v3";
	my $downloadurl = "http://github.io/mini.git/eso/ubin-local/wakemeupin";
	my $ret = $cui->dialog	(	-message	=>	"About $0",
								-title		=>	"$0 version $version, written by $author\n$copyright\n$license\n$downloadurl",
								-buttons	=>  ['Close'],
							);	
}
								


#exit(0);

no warnings "experimental";

use Getopt::Long::Descriptive;


my $quiet = 0;
my $myprogram = "wakemeupin";

my ($opt, $usage) = describe_options(

	'$myprogram %o | [[hours]h] | [[minutes]m] | [[seconds]s] | [[milliseconds]ms]',
	[ 
		'gui|g', "use graphical interface",
	],
	[	
		'at|a=s', "at (fixed destination/dynamic time) instead of in (fixed time/dynamic destination)", 
		{ default => 'no' },
	],
	[
		
		'time|t=s',	"the time to wake up in passing to sleep",
		{ default  => "5s" } 
	],
	[ 
		'delay|d=i',"time between notifications/beeps/audios/etc",
		{ default => 0.5 }
	],
	[
		'method|m=s',"method used to wake: beep(default) audio, command, or notify",
		{ default => "beep" }
	],		
[],
	[	'value|d=s',
		'data to pass to method:
			beep		- frequency/duration pair
			audio		- audio file to send to player (sox)
			command		- path of command to execute (or one in PATH)
			notify		- string to display with notify(1)
		',
		{ default => "5000 0.5" }
	],
	[ 
		'verbose|v',
		"print extra stuff"
	],
	[ 
		'help',
		"print usage message and exit"
	],
);
print($usage->text), exit if $opt->help;

my $time = $opt->time;
my $verbose = $opt->verbose;
my $method = $opt->method;
my %units = qw	( 	h 	hour 
					m 	minute 
					s 	second 
					ms 	millisecond 
					y 	year 
					w 	week 
					d 	day 
				);
my $value = $opt->value;				
my $debugmode = 1;	# disable this when not debugging (set to 0)
my $usegui = $opt->gui;
my @gui_elements = (	
	{ Class => "TitleBar",
	  Text => "Gui Interface",
	  Width => -1,
	  Height => 2,
	  Color => color(1,2), 
	},
	{ Class => "StatusBar",
		Items => [ "Status Item Left", "Center", "Right" ],
	  Width => -1,
	  Height => 2,
	  Refresh => 1000,
	} );
	#{ Class => "Menu",
	#	Items => { File => { menu(qq("Exit"
	 # Width => -1


					
sub color
{
	my @colors = (shift // 7, shift // 8);
	return \@colors;	
}
sub updategui()
{
	for my $elem (@gui_elements) 
	{
		say ${$elem}{"Class"};
	}
	return true;
}

# SUBROUTINES
sub gui
{
	my $px = 1;
	my $py = 1;
	my $x = $ENV{'COLUMNS'} // 40;
	my $y = $ENV{'ROWS'} // 24;
	my $run = 1;
	while ($run) 	
	{
		updategui() or die("error: updating gui failed: $!");		
		$run = gui_io();
	}		
}

sub gui_io
{
	my $kp = "";
	OUTER: 
	while(1) {
		read(STDIN,$kp,1,0);	
		given($kp)
		{											
			return 1 when /[qQ]/;
			default { return 0;	}					  
		}
	}
	return 0;
}

sub dmsg
{
	# level 3: unconditional debug messages
	CORE::say(@_) if $debugmode;
}
sub mesg 
{ 
	# level 2: extra info messages
	CORE::say(@_) if $verbose;
}
sub nmsg
{
	# level 1: user messages
	CORE::say(@_) unless ( $quiet && ! $verbose );
}
sub mmsg
{
	# level 0: unconditional messages
	CORE::say(@_);
}

sub killspk {
			mesg("killing pc speaker...");
			system( qw! sudo -H modprobe -r pcspkr ! );
			my $result = $?;
			mesg("pcspk disable result code: $result");
						
		
}
sub lifespk {
			mesg("resurrecting pc speaker...");
			system( qw( sudo -H modprobe pcspkr ) );
				mesg("warning: pcspk enable failed!!");

}



# CHECK POSITIONAL ARGUMENTS

mesg("command line was: @ARGV");

if ($usegui) {
	gui;
	gui_content( qw! Press Q To Exit !);
	exit(gui_io);
}	

while (@ARGV > 0) {

	$_ = shift(@ARGV);

	# must match:		but not:
	# 0.0s				..0s
	# .5ms              123.4.5.s
	# 1h				999..h
	# 10.22m            1...2m
	# .9h               333...ms
	if ( /(?<amt>^[-+]?([0-9]*\.[0-9]+|[0-9]+))(?<unit>[hmsdwy]|ms|)$/ )
	{
		my $amt = $+{amt};
		my $unit = $+{unit};
	
		print("amount=$amt  unit=$unit ");	
		print(" (unit type detected as \"" . $units{$unit} . "(s)\"\n");
		mesg("$_ is validated");
		mesg("resassigning from $time to $_");
		$time = $_;	
	}
	else { unshift @ARGV,$_; }	


# CHECK OPTIONS

die("method is not valid!!! ($!)") unless $opt->method =~ /(beep|audio|command|notify)/;
##die("too many bad arguments(" . scalar(@ARGV) . "), use --help for proper use information\n $? $!")	if (scalar(@ARGV) > 0);
if ( $opt->at ne "none" )
{
	# todo subtract
}


mesg("waiting for time to elapse:");
system( "sleep", $time );
mesg("waking, time reached!");
lifespk();
my $pid = $$;
my $forkid = fork();
my $delay = $opt->delay;
if ($forkid == 0) {
	
	while(1) {
		sleep($delay);
		given($method)
		{
			when(/beep/) { system("beep"); }
			when(/audio/) { system("play","-q",$opt->value); } 
			# die("audio play failed on client side"); }
			when(/command/) { system($opt->value); }
			when(/notify/) { system($opt->value); }
			default { die("unknown method passed: $method -- fatal!"); }
		}
			
		unless ( -d "/proc/$pid" ) {
			say("parent of $$ -> $pid exited and I am not dead, killing self..");
			say("");
			killspk();
			exit(127);
		} 
	}
	exit(0);
}
my $term = Term::ReadLine->new('waitingforbeeptostop');
$term->readline("press ENTER key to stop [CTRL+C will exit but not gracefully!]");
kill($forkid);
waitpid($forkid,2500);
killspk();

}


