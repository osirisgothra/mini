#!/usr/bin/perl
#
# FILE
#    perltemplate-file
#    the perltemplate-file perl script
#
# PROJECT
#    perltemplate-file-proj
#    project perltemplate-file-proj: container for perltemplate-file
#
# AUTHOR / COPYRIGHT
#
#    Copyright (C) 2020, Gabriel Thomas Sharp
#
#    Written by Gabriel Thomas Sharp, [osirisgothra@larnica.(none)]
#    Latest versions of this and all of Gabriel Thomas Sharp's projects can be
#    obtained from:
#
#    <https://github.com/osirisgothra>
#
#    Documentation Available At:
#
#    <https://osirisgothra.github.io/perltemplate-file-proj/http://www.github.com/osirisgothra/perltemplate-file-proj.git>
#
# LICENSE
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#  HISTORY
#
#	 Sun Jan 12 17:26:24 2020
#         osirisgothra\@larnica.(none) created this file using perltemplate
#         and named it perltemplate-file
#
#                    created with Text::Template::Alternative::Perl (or just 'perltemplate')
#
use warnings;
use v5.18;
use strict;
no warnings "experimental";			# 	disable warnings about using 'given-when-default' blocks, as well as subroutine signatures or prototypes (aka, mysub($@@) or mysub($sig)) -- also
									#   enables some of the advanced usage of '~~' smart matching.
no warnings "once";					# 	disable warning for once-used-declared variables in examples below (you probably want to remove this line after modifying the code)

## ANSI ##

use Term::ANSIColor  qw ( colorstrip color colored :constants );

# color

print color 'bold blue';
print "This text is bold blue.\n";
print color 'reset';
print "This text is normal.\n";
print colored("Yellow on magenta.", 'yellow on_magenta'), "\n";
print "This text is normal.\n";
print colored ['yellow on_magenta'], 'Yellow on magenta.', "\n";
print colored ['red on_bright_yellow'], 'Red on bright yellow.', "\n";
print colored ['bright_red on_black'], 'Bright red on black.', "\n";
print "\n";

# map escape sequences back to color names.	

my $names = uncolor('01;31');
print join(q{ }, @{$names}), "\n";

# Strip all color escape sequences.

print colorstrip '\e[1mThis is bold\e[0m', "\n";

# Determine whether a color is valid.

my $valid = colorvalid('blue bold', 'on_magenta');
print "Color string is ", $valid ? "valid\n" : "invalid\n";

# Create new aliases for colors.

coloralias('alert', 'red');
print "Alert is ", coloralias('alert'), "\n";
print colored("This is in red.", 'alert'), "\n";
print BOLD, BLUE, "This text is in bold blue.\n", RESET;


# localized
{
	local $Term::ANSIColor::AUTORESET = 1;
	print BOLD BLUE "This text is in bold blue.\n";
	print "This text is normal.\n";
}
print PUSHCOLOR RED ON_GREEN "This text is red on green.\n";
print PUSHCOLOR BRIGHT_BLUE "This text is bright blue on green.\n";
print RESET BRIGHT_BLUE "This text is just bright blue.\n";
print POPCOLOR "Back to red on green.\n";
print LOCALCOLOR GREEN ON_BLUE "This text is green on blue.\n";

# localized 
print "This text is red on green.\n";
{
	local $Term::ANSIColor::AUTOLOCAL = 1;
	print ON_BLUE "This text is red on blue.\n";
	print "This text is red on green.\n";
}
print POPCOLOR "Back to whatever we started as.\n";

## END ANSI ## 


## PATH ##

use Path::Tiny;

# creating Path::Tiny objects

my $dir = path("/tmp");
my $foo = path("foo.txt");
my $subdir = $dir->child("foo");
my $bar = $subdir->child("bar.txt");

# stringifies as cleaned up path

my $file = path("./foo.txt");
say $file; # "foo.txt"

# reading files

my $guts = $file->slurp;
$guts = $file->slurp_utf8;

my @lines = $file->lines;
@lines = $file->lines_utf8;

my ($head) = $file->lines( {count => 1} );
my ($tail) = $file->lines( {count => -1} );
say "head";
say $head;
say "tail";
say $tail;
say "write data...";

# writing files
my @data = qw ( sample data );

$bar->spew( @data );
$bar->spew_utf8( @data );

# reading directories

for ( $dir->children ) { say("children: $_"); }
my $iter = $dir->iterator;
while ( my $next = $iter->() ) { say("iterated: $next"); }

## PATH END ##


## OPEN3 ##

use IPC::Open3  qw( open3 );
my $pid = open3( \*CHLD_IN, 
              \*CHLD_OUT, 
              \*CHLD_ERR, 
              ## "some cmd and args", "arg", ..more..
               @ARGV
            );
my @handles = ( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR );	

my($wtr, $rdr, $err);

use Symbol "gensym"; $err = gensym;

$pid = open3($wtr, $rdr, $err, @ARGV ); ### "some cmd and args", "optarg", ...);
waitpid( $pid, 0 );
my $child_exit_status = $? >> 8;

## END OPEN3 ##



## GETOPT ##

use Getopt::Long::Descriptive; # opt|shortchar[kind] (kind is =s[tr],=i[nt], or none)
my ($opt, $usage) = describe_options(
        '$0 %o <some-arg> file',
        [ 'no-dialog', "dont use dialog to show log", { required => 1  } ],
        [ 'no-follow',   "do not follow the log, just show it",   { default  => 79 } ],

        [],
        [ 'verbose|v',  "print extra stuff"            ],
        [ 'help',       "print usage message and exit" ],
		
      );

say($usage->text), exit if $opt->help;

## GETOPT END ##

## CURSES ##
use Curses::UI;

my $debug = 1;  #1=yes 0=no
my $cui = Curses::UI->new( -clear_on_exit => 1, -debug => $debug, ); # this is where we gloss over setting up all the widgets and data structures + start the event loop
$cui->dialog("Hello, world!");
my $yes = $cui->dialog( 	-message => "Hello, world?", -buttons => ["yes","no"], -values  => [1,0], -title   => "Question", );
if ($yes) {	chomp(); } # whatever
$cui->error("It's the end of the\n"."world as we know it!");
$file = $cui->filebrowser(	-path => "/tmp", -show_hidden => 1, );

# Filebrowser will return undef if no file was selected.
if (defined $file) {    unless (open F, ">$file") {	print F "Hello, world!\n"; close F; } else { $cui->error(qq(Error on writing to "$file":\n$!)); }     }
$cui->status("Saying hello to the world..."); 		# code for saying "Hello, world!"
$cui->status("Saying goodbye to the world..."); 	# code for saying "Goodbye, world!"
$cui->nostatus;
$cui->progress( 	-max => 10, 	-message => "Counting 10 seconds...", );
for my $second (0..10) {	$cui->setprogress($second); sleep 1; }
$cui->noprogress;
$cui->mainloop;

## END CURSES ##

exit(1);

