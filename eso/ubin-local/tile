#!/bin/zsh
#
#    tile
#    tile some windows
#    mini
#    esoteric projects
#
#    Copyright (C) 1995-2021 Gabriel T. Sharp
#
#    Written by Gabriel T. Sharp <21shariria@gmail.com>
#    Latest versions of this and all projects can be
#    obtained by visiting the repository at:
#
#    <https://github.com/osirisgothra>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#    HISTORY
#
#	 Thu 07 Jan 2021 12:46:22 PM EST
#            osirisgothra@ initially created this file
#            with the original name, tile
#
#
#
#  This template and header was created using the template generator by Gabriel T. Sharp
#  You can download the latest version at: <https://www.github.com/osirisgothra/mini.git/eso/ubin-local/template>
#  (the url is subject to changes on github's behalf, please submit a pull request to fix or request a fix on any url changes)
#


# Get Options from Command Line for tile

declare -ga opts
declare -gi quiet_level=0
declare -g version_text="$(tput setaf 124)tile$(tput sgr0) Version 1.0 (C)2020 Gabriel T. Sharp, Licensed under GNU LGPL3 at https://gpl.gnu.org/gpl3.html"
declare -g help_text="tile
tile some windows

SYNTAX

	tile [OPTIONS] [window-class] [items-per-row]

DEFAULTS
    window-class    defaults to 'xterm'
    items-per-row   defaults to '2'

    Note: Windows could be set really small if you specify not enough rows!
          The defaults will be used if they are somehow invalid.

OPTIONS
--prepend  -p   put uneven windows on first row
 --verbose -V   show extra messages
	--help -h	show this help text
 --version -v   display version information and exit (also shows license info)
   --quiet -q   increase quiet level by one (quiet level is always zero if left alone)

TERMS

	FILENAME	A filename that must exist or be writable by the current user.
	PATHNAME	A relative or absolute path that must exist or be creatable.
	STRING		A readable string, it must not contain any unreprintable characters.
	NUMBER		An integer, usually between -32767 and 32767.
	BOOLEAN		A true/false value, represented as 0 for false, and any other value for true.
	FLOAT		A floating point single or double precision value, it is precise down to about 5 ot 6 decimal places.
	ENG			Scientific notation, expressed in powers (3x10^4 is written as 3.4)
	DEG			Like GRAD/RAD, but expressed in degrees (hours, minutes, seconds) so 3 5'5\" is written as \"3.5.5\"

INFO

    The -V and -q options are relative. That is, they affect each other
    in such a way that using '-V -V -V -q -q -V -q -q' is the same as
    using nothing. Also, '-V -V -q -q -q -q -V' is the same as '-q', etc.


    When --prepend is in use, the windows will be tiled per-row, except
    when there is an uneven number of windows to tile, the items
    remaining will be placed on the first line in this case, or the
    last line if --prepend is not specified at all.

LICENSE

	GNU LGPL3 is available in full at the GNU GPL website, or through the google voice command 'show me GNU LGPL VERSION 3'

"

lecho() { builtin echo "$@"; }

echo() {
	if [[ $quiet_level -gt 0 ]]; then
		return 127
	else
		builtin echo "$@"
	fi
}

is() {
    case $1 in
        quiet)  ((quiet_level > 0));;
      verbose)  ((quiet_level < 0));;
       normal)  ((quiet_level == 0));;
     notquiet)  ((quiet_level <= 0));;
            *)  ((quiet_level == 1));;
    esac
}

if opts=( `getopt -n $0 -o hvqVp -l prepend,verbose,help,version,quiet -- "$@"` ); then
	eval set -- "${opts[@]}"
	while [[ $# -ge 0 ]]; do
		curopt=$1
		nextopt=${2-none}
		shift
		# handle --options and -o ptions here
		case $curopt in
		  --prepend|-p) appendfirst=1;;
			--help|-h)	echo "$help_text"; exit 127;;
			--version|-v) echo "$version_text"; exit 127;;
            --verbose|-V) let quiet_level--;;
			--quiet|-q) let quiet_level++;;
			--) is verbose && echo "done with options";  break;;
			*)	is verbose && echo "handling option: $curopt (next:$nextopt)";;
		esac
	done
	# xdotool - ubuntu/mint/bsd/redhat/etc repos not usually core though
	# xdtt - found same place you found this program
	required=( xdotool )
	# use failed so we can tell user ALL missing items
	# instead of the back-and-forth crap most programs do
	failed=0
	for x in $required; do
	    if [[ ! -x ${x:c} ]]; then
	        lecho "error: $x is required, please install this program first"
	        failed=1
	    fi
	done
	[[ $failed == 1 ]] && exit 127
	for arg; do
		# verify/handle non-option arguments
		case $arg in
			*)	is verbose && echo "handling argument: $arg";;
		esac
	done

else
	is notquiet && echo "error, code is $?, exiting with fail"
fi

# class is xterm by default, or first arg
class=${1-xterm}
echo "class is $class"
declare -ga witems=( $(xdotool search --class "$class") )
items=$#witems
if [[ $items -lt 1 ]]; then
    echo "nothing found, aborting"
    exit 127
fi
# got number of items
# rows is 2 by default, or second arg
rows=${2-2}
if [[ $rows -gt $items ]]; then
    echo "warning: you entered a value greater than number of items, truncated to rows = 1"
    rows=1
fi
rowitems=$(( items / rows ))
sheight=1080
swidth=1920
echo "items: $items rows=$rows"
iheight=$(( sheight / rows ))
iwidth=$(( swidth / rowitems ))
remain=$(( items % rows ));
echo "rows=$2 class=$1"
echo "overhang=$remain"
echo "items per row: $rowitems  items: $items"
echo "screen: $swidth x $sheight"
echo "items: $iwidth x $iheight"
echo "upper left: 0 0"
echo "items: ${(j:,:)witems}."

# NOTE: incomplete cannot run yet
echo "------------------------------------- mock layout ---"
itemsleft=$items
declare -ga winrows=( )
for ((r=1;r<=rows;r++)); do
    thisrowwidth=0
    if ((remain && appendfirst && r==1)) ||
       ((remain && ! appendfirst && r==rows)); then
        thisrowwidth=$(( remain + rowitems ))
    else
        thisrowwidth=$(( rowitems ))
    fi
    winrows+=$thisrowwidth
done
# print remaining
idx=0
for ((r=1;r<=rows;r++))
{
    wcnt=${winrows[$r]}
    ww=$(( swidth / wcnt ))
    wh=$(( sheight / rows ))
    wx=$(( (r-1)*(wh) ))
    for ((x=1;x<=wcnt;x++)); do
        # running count for actual window ref:
        let idx++
        wy=$(( (x-1) * ww ))
        
        printf "[Win $witems[$idx] (size=$ww x $wh,pos=$wx,$wy)\t"
        # now drumroll, actually do it
        xdotool windowmove $witems[$idx] $wy $wx
        xdotool windowsize $witems[$idx] $ww $wh
        
    done
    printf "\n"
}

echo "------------------------------------- mock layout ---"

