#!/usr/bin/perl
#
# FILE
#    is
#    for question in all of our minds
#
# PROJECT
#    mini
#	 actually, not really
#
# AUTHOR / COPYRIGHT
#
#    Copyright (C) 2021, 
#
#    Written by  osirisgothra@larnica.(none)
#    Latest versions of this and all of 's projects can be
#    obtained from:
#
#     <<projbranch>>
#
#    Documentation Available At:
#
#     <http://www.github.com/osirisgothra/mini.git>
#
# LICENSE
#
#    mini/is  is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#  NOTES
#
#     * TODO: move 'use' statements to top if you want to keep them**
#    ** this feature will be added to the next version of perltemplate (hopefully)
#   *** warnings are disabled for experimental and once because they are pretty
#       annoying here, you might want to re-enable them for your own program
#       to do this during testing and development.
#
#  HISTORY
#
#	Sun Feb 21 14:47:11 2021
#         osirisgothra@larnica.(none) created this file using the template generator 'perltemplate'
#         and named it is for the project '<projname'.
#
#
# (created with perltemplate by Gabriel T. Sharp <osirisgothra@hotmail.com>)
#

use warnings;
use v5.18;
use strict;
no warnings "experimental";			# 	allow given/when/default and smartmatching without their warnings***
no warnings "once";					# 	allow variables to be used just once without warning***
use feature "signatures";
use Path::Tiny;

sub fail($msg,$code=127) {
    printf("A: $msg \n");
    #exit($code);
}

my $who = "";
my $a = "";
# first possessive will get the who, but who is nothing if it cant be found
for (reverse @ARGV)
{
    # a doesnt get set if there is no other possessive to clown it
    $a = "a " if /^a$/ && $who ne "";
    $a = "to " if /^to$/ && $who ne "";
    $who = "it's " if /^(it|its|it's)$/ && $who ne "";
    $who = "your " if /\A(m[ye]|I)\z/;
    $who = "their " if /^(his|her|their|them|everyone)$/;
    $who = "my " if /^(your|yer|yours|you)$/;
        
}
 
@ARGV = grep { ! /\A(it|in|out|beside|behind|below|above|beyond|before|after|during|now|later|its|it's|is|too?|[a-z]*ly|my|there a|your|his|of|her|everyone|their|these|those|them|thou|thine|dat|the|he|she|a)\z/ } @ARGV;   


while (@ARGV)
{
    my $topic = shift(@ARGV) // "nothing ";  # great thing is, nothing can be a verb, or a topic
    my $verb = shift(@ARGV) // "nothing ";
    my $fpass=0;
    my $file = path("/");
    given($topic)
    {        
        when (/no/)
        {
            if ($verb eq 'sound') {
                say("A: i'll fix that");
                system("sudo modprobe snd_emu10k1; sudo alsactl init");
                $fpass=1;
            }
            else
            {
                say("Q: I dont care if there is no $verb and i dont know how to fix that anyways!");
                
            }
            
        
        }
        # topic not understood, maybe verb will be    
        default {
            given ($verb)
            {
                when (/running|started|process/) {
                    say "i'll see if it is a running process or service...";
                    # topic is the process name or id
                    if ( -r "/proc/$topic" ) {
                        say("yes $topic is running");
                        $fpass=1;
                    }
                    else
                    {
                        for $file ( path("/proc")->children() )
                        {
                            if ( -r $file->child("comm")  )
                            {
                                #debug#say("$file has comm, checking comm");
                                if ( $file->child("comm")->slurp() eq "$topic\n" )
                                {
                                    say("yes $topic is running under $file");
                                    $fpass=1;
                                }
                            }                            
                            else
                            {
                                #debug#say("$file doesnt have a comm entry");
                            }
                        }
                    }                      
                    
                }
            
                default {
                    $a = "a " if $topic =~ /(this)/;  # todo add more placerizers                    
                    fail("I cannot tell if $who$topic is $a${verb}") unless $fpass;
                    $fpass=1;
                }
            }            
            my $ing = $verb =~ /(ing)$/ ? "" : "ing";
           
            fail("$topic is not $who${verb}$ing") unless $fpass;
        }
    }

}    



#
#
#
#
#
#use Getopt::Long::Descriptive; # opt|shortchar[kind] (kind is =s[tr],=i[nt], or none)
#
#my ($opt, $usage) = describe_options(
#    '$0 %o <some-arg> file',
#    [ 'no-dialog', "dont use dialog to show log",  ],
#    [ 'no-follow',   "do not follow the log, just show it",   { default  => 79 } ],
#    [],
#    [ 'verbose|v',  "print extra stuff"            ],
#    [ 'help',       "print usage message and exit" ],
#);
#
#
#
#
#
##
##say($usage->text), exit if $opt->help;
##say("getopt: arguments processed: $#ARGV");
##
##
#
#use Path::Tiny;
#
#sub path_demo()
#{
#    # creating Path::Tiny objects
#    print `tput clear`;
#    print("For this to work, must have /tmp/foo.txt and /tmp/foo/bar.txt first, attempt will be made to create them...");
#
#    sleep(0.5);
#    
#    my $data1 = `ls -l /`;
#    my $data2 = `ls /etc`;
#    
#    path('/tmp/foo/bar.txt')->spew($data1);
#    path('/tmp/foo.txt')->spew($data2);
#
#    my $dir = path("/tmp");
#    my $foo = path("foo.txt");
#    my $subdir = $dir->child("foo");
#    my $bar = $subdir->child("bar.txt");
#    
#    # stringifies as cleaned up path
#
#    my $file = path("./foo.txt");
#
#    say $file; # "foo.txt"
#
#    # reading files
#
#    my $guts = $file->slurp;
#    my @lines = $file->lines;
#    my ($head) = $file->lines( {count => 1} );
#    my ($tail) = $file->lines( {count => -1} );
#
#    $guts = $file->slurp_utf8;
#    @lines = $file->lines_utf8;
#
#    print `stty sane`;
#    say "head";
#    say $head;
#    say "tail";
#    say $tail;
#    say "write data...";
#    
#    # writing files
#    
#    my @data = qw ( sample data );
#
#    $bar->spew( @data );
#    $bar->spew_utf8( @data );
#
#    # reading directories
#
#    for ( $dir->children )
#    { 
#        say("children: $_"); 
#    }
#
#    my $iter = $dir->iterator;
#    
#    while ( my $next = $iter->() ) 
#    { 
#        say("iterated: $next"); 
#    }
#}
#
### CURSES ##
#use Curses::UI;
#
#my $cui;  # Main Program Object, it must be global so accessor/menu/etc subs can see it
#           # even though subs are defined inside of the same routine, subs wont be able to
#           # read any function-local data, this is a closure that keeps loops from compromise.
#           # an illustration of the closure:
#
##  GLOBAL STACK     FUNC STACK
##  +---------------+---------+ -> creates function B() but its access is still limited to global and above unless a ref was passed too
##  |     FUNC A    +    A    |
##  |     FUNC A    +    | var|
##  +---------------+---------+
##  +---------------+---------+
##  |     FUNC B    +    B    |-> tries to access cui, but if its in A how would it?
##  +---------------+---------+
##  GLOBAL STACK     FUNC STACK
##    +---------------+
## |->|     var       |
## |  +---------------+
## |    ^
## |    |
## |    | accessible!
## |    |
## | +---------------+---------+ -> creates function 'FUNC B'
## | |     FUNC A    +    A____|
## | |               +    |////| <- readable by A only
## | +---------------+---------+
## | +---------------+---------+
## -|     FUNC B    +    B     |-> tries to access var, and can because its global
##  +---------------+----------+
#
#my $file = undef;
#my $statusbar_showing = 0;
#my $statusbar_text = "I am some status text";
#sub exit_dialog()
#{
#    my $return = $cui->dialog	(	-message   => "Do you really want to quit?",
#	    							-title     => "Are you sure?",
#		    						-buttons   => ['yes', 'no'], );
#    exit(0) if $return;
#}
#
#sub curses_demo()
#{
#    say("curses: entering setting");
#
#    my $debug = 0;  #1=yes 0=no
#    $cui = Curses::UI->new( -color_support => 1, -clear_on_exit => 1, -debug => $debug, ); # this is where we gloss over setting up all the widgets and data structures + start the event loop
#
#    # menu subs
#
#    sub help_contents_act
#    {
#        $cui->dialog("Contents: Nothing!");
#    }
#    sub about_dialog
#    {
#        while(1) {
#        my $yes = $cui->dialog( 	-message => "Template Program v1.0", -buttons => [
#            {   -label    => '< About The Author >',
#                -value    => 191,
#                -onpress  => undef,
#                -shortcut => 'o', }
#        ,
#        "ok"], -values  => [1,0], -title   => "About", );
#        given($yes) {
#            when (191)
#            {
#                $cui->dialog( 	-message => "The Author of this program seems like a nice enough person!", -buttons => ["ok"], -values  => [1,0], -title   => "About Author", )
#            }
#            default
#            {
#                return;
#            }
#        }
#        }
#    }
#    sub open_dialog
#    {
#        $file = $cui->filebrowser(	-path => "/tmp", -show_hidden => 1, );
#
#        # Filebrowser will return undef if no file was selected.
#        
#        if (defined $file) 
#        {   
#            unless (open F, "<$file") 
#            {	
#                # do something with file
#                close F; 
#            } 
#            else 
#            { 
#                $cui->error(qq(Error opening "$file":\n$!)); 
#            }
#        }
#    }
#    sub undo_act
#    {
#        # todo: undo something
#    }
#    sub redo_act
#    {
#        # todo: redo something
#    }
#    sub next_act
#    {    
#        # todo: next something
#    }
#    sub prev_act
#    {    
#        # todo: previous something
#    }
#    sub statusbar_act
#    {
#        $statusbar_showing ^= 1;   # toggle it
#        $cui->status($statusbar_text) if $statusbar_showing;
#        $cui->nostatus unless $statusbar_showing;
#    }
#    sub toolbar_act
#    {
#        $cui->error("It's toolbar has yet to be completed!");
#
#    }
#    sub progress_act
#    {
#        $cui->progress( -max => 10, -message => "Counting 2 seconds...", );
#        for my $second (0..2) 
#        {	
#            $cui->setprogress($second); 
#            sleep 1; 
#        }
#        $cui->noprogress;
#    }
#
#    my @menu = (
#
#                { -label => 'File',
#                  -submenu => [{        -label => 'Open...'     ,     -value => \&open_dialog  },
#                               {        -label => 'Exit      ^Q',     -value => \&exit_dialog  }],
#                },
#                { -label => 'Edit',
#                  -submenu => [{        -label => 'Undo      ^U',     -value => \&undo_act  },
#                               {        -label => 'Redo'        ,     -value => \&redo_act  }],
#                },
#                { -label => 'Search',
#                  -submenu => [{        -label => 'Find      F3',     -value => \&find_dialog  },
#                               {        -label => 'Replace   F4',     -value => \&replace_dialog  }],
#                },
#                { -label => 'View',
#                  -submenu => [{        -label => 'Statusbar ^S',     -value => \&statusbar_act  },
#                               {        -label => 'Toolbar   ^T',     -value => \&toolbar_act }],
#                },
#                { -label => 'Document',
#                  -submenu => [{        -label => 'Previous   PGUP',     -value => \&prev_act  },
#                               {        -label => 'Next       PGDN',     -value => \&next_act  }],
#                },
#                { -label => 'Demos',
#                  -submenu => [{        -label => 'path',             -value => \&path_demo },
#                               {        -label => 'ansi',             -value => \&ansi_demo },
#                               {        -label => 'open3',             -value => \&open3_demo }],
#                },
#                { -label => 'Help',
#                  -submenu => [{        -label => 'Contents   F1',     -value => \&help_contents_act  },
#                               {        -label => 'About'        ,     -value => \&about_dialog  }],
#                },
#
#                );
#    $cui->add( 'menu','Menubar', -menu => \@menu, -fg => "blue",);
#    $cui->mainloop;
#}    
#curses_demo();
### END CURSES ##
#
#
#use IPC::Open3  qw( open3 );
#
#
## name: open3x
## desc: wrapper for open3
## retv: a hash with two members, stdout and stderr (the content of these should be obvious enough)
## args: $cmd    the command to run
##       @args   arguments to include, if any (remember that its slurpy and disolves hashes and lists)
## note: needs IPC::Open3 and imported open3
#sub open3x($cmd,@args)
#{
#    croak("open3x expects at least a command in \$cmd") unless $cmd;
#    croak("argument count exceeds hard limit of 255 - alter the program if you need more") if @args > 255;       
#	
#	my $pid = open3( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR, 'xcalc','-fg','red' );
#	my @handles = ( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR );	
#	my($wtr, $rdr, $err);
#	use Symbol "gensym"; $err = gensym;
#	$pid = open3($wtr, $rdr, $err, 'xcalc','-fg','red' ); 
#	waitpid( $pid, 0 );
#	my $child_exit_status = $? >> 8;
#    
#}
#
