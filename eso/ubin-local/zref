#!/bin/zsh
#
#    zref
#    zref reference cards WIP
#    mini
#    eso/ubin-local
#
#    Copyright (C) 1995-2021 Gabriel T. Sharp
#
#    Written by Gabriel T. Sharp <21shariria@gmail.com>
#    Latest versions of this and all projects can be
#    obtained by visiting the repository at:
#
#    <https://github.com/osirisgothra>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#    HISTORY
#
#	 Fri 09 Apr 2021 05:41:24 PM EDT
#            osirisgothra@ initially created this file
#            with the original name, zref
#
#
#
#  This template and header was created using the template generator by Gabriel T. Sharp
#  You can download the latest version at: <https://www.github.com/osirisgothra/mini.git/eso/ubin-local/template>
#  (the url is subject to changes on github's behalf, please submit a pull request to fix or request a fix on any url changes)
#


# Get Options from Command Line for zref

declare -ga opts
declare -gi quiet_level=0
declare -g version_text="$(tput setaf 124)zref$(tput sgr0) Version 1.0 (C)2020 Gabriel T. Sharp, Licensed under GNU LGPL3 at https://gpl.gnu.org/gpl3.html"
declare -g help_text="zref
zref reference cards 

** ZREF IS A WORK IN PROGRESS **

SYNTAX

    zref [OPTIONS] REFERENCE ...

OPTIONS
    --help -h   show this help text
 --version -v   display version information and exit (also shows license info)
   --quiet -q   increase quiet level by one (quiet level is always zero if left alone)

ARGUMENTS

    REFERENCE   The reference type to show, current types are listed below
    
REFERENCE TYPES

    Use the name for the reference type using a REFERENCE (ie 'zref prompt')
    given below:

    prompt      show % completion codes
    list        show a short list of reference type names  

LICENSE

    GNU LGPL3 is available in full at the GNU GPL website, or through the google voice command 'show me GNU LGPL VERSION 3'

"
showcard()
{
    declare -gi maxl=0
    for x in $list_items; do
        l=${#x}
        ((l>maxl)) && maxl=$l
    done
    
    declare -gi remain=$(( COLUMNS - ${#list_title} ))
    declare -g width=""
    declare -g lwidth=""
    for ((x=0;x<COLUMNS;x++)) { width+=" "; (( $x < $remain )) && lwidth+=" ";}
    print -P "\n%U%B$width%b%u"   
    print -P "%B%K{12} $list_title $lwidth%b%k"
    print -P "%U%B%K{12}$width%b%u%k"
    echo
    cpos=0
    declare -i pos=-1 bytes=0 count=${#list_items} cpos=-1 cmpos=1
    for r in $list_items; do
        r=${(r:maxl:)r}
        reallen=$(print -Pn "$r")
        
        
        
        
        let pos+=${#r}
        
        let bytes+=${#r}
        let cpos++
                
        ((cpos > cmpos )) && let cmpos=cpos        
        if (( pos >= COLUMNS )); then
            printf "\n"
            pos=${#r}
            let pos++
            cpos=0
        fi
        if (( cpos != 0 )); then
            spc=" "
            pos+=1
        else
            spc=""
        fi
        print -n "$spc"
        print -n "$r" | sed -r 's/^(\S+)/[31m\1/g;s/(\s.*)$/[33m\1/g;'
    done       
    print -P "\n%U%B$width[K%b%u\n"
    
    print -P "\nTotal: $bytes byte(s) in $count item(s)\nand $cmpos column(s).\n"
        
    

}

lecho() { builtin print -P "$@"; }

echo() {
    if [[ $quiet_level -gt 0 ]]; then
        return 127
    else
        builtin print -P "$@"
    fi
}

is() {
    case $1 in
        quiet)  ((quiet_level > 0));;
      verbose)  ((quiet_level < 0));;
       normal)  ((quiet_level == 0));;
     notquiet)  ((quiet_level <= 0));;
            *)  ((quiet_level == 1));;
    esac
}

if opts=( `getopt -n $0 -o hvqV -l verbose,help,version,quiet -- "$@"` ); then
    eval set -- "${opts[@]}"
    while [[ $# -ge 0 ]]; do
        curopt=$1
        nextopt=${2-none}
        shift
        # handle --options and -o ptions here
        case $curopt in
            --help|-h)    echo "$help_text"; exit 127;;
            --version|-v) echo "$version_text"; exit 127;;
            --verbose|-V) let quiet_level--;;
            --quiet|-q) let quiet_level++;;
            --) is verbose && echo "done with options";  break;;
            *)    is verbose && echo "handling option: $curopt (next:$nextopt)";;
        esac
    done
    case $# in
        0)  print -P "%F{1}fatal: no refcard name given, see --help for more details"
            exit 127
        ;;
        
        *)  for arg; do
                # verify/handle non-option arguments
                case $arg in
                    flags)  declare -g  list_title="Variable Param Flags (\${() \<\- they go in here)"
                            declare -ga list_items=( "0  -- split words on null bytes"
                                            "A  -- assign as an array parameter"
                                            "a  -- sort in array index order (with O to reverse)"
                                            "b  -- backslash quote pattern characters only"
                                            "B  -- include index of beginning of match in #, % expressions"
                                            "C  -- capitalize words"
                                            "c  -- count characters in an array (with \${(c)#...})"
                                            "D  -- perform directory name abbreviation"
                                            "E  -- include index of one past end of match in #, % expressions"
                                            "e  -- perform single-word shell expansions"
                                            "#  -- evaluate as numeric expression"
                                            "%  -- expand prompt sequences"
                                            "F  -- join arrays with newlines"
                                            "f  -- split the result on newlines"
                                            "g  -- process echo array sequences (needs options)"
                                            "I  -- search <argument>th match in #, %, / expressions"
                                            "i  -- sort case-insensitively"
                                            "j  -- join arrays with specified string"
                                            "k  -- substitute keys of associative arrays"
                                            "l  -- left-pad resulting words"
                                            "L  -- lower case all letters"
                                            "m  -- count multibyte width in padding calculation"
                                            "M  -- include matched portion in #, % expressions"
                                            "N  -- include length of match in #, % expressions"
                                            "n  -- sort decimal integers numerically"
                                            "o  -- sort in ascending order (lexically if no other sort option)"
                                            "O  -- sort in descending order (lexically if no other sort option)"
                                            "p  -- handle print escapes or variables in parameter flag arguments"
                                            "@  -- prevent double-quoted joining of arrays"
                                            "P  -- use parameter value as name of parameter for redirected lookup"
                                            "q  -- quote with backslashes"
                                            "Q  -- remove one level of quoting"
                                            "R  -- include rest (unmatched portion) in #, % expressions"
                                            "r  -- right-pad resulting words"
                                            "S  -- match non-greedy in /, // or search substrings in % and # expressions"
                                            "s  -- split words on specified string"
                                            "~  -- treat strings in parameter flag arguments as patterns"
                                            "t  -- substitute type of parameter"
                                            "u  -- substitute first occurrence of each unique word"
                                            "U  -- upper case all letters"
                                            "v  -- substitute values of associative arrays (with (k))"
                                            "V  -- visibility enhancements for special characters"
                                            "w  -- count words in array or string (with \${(w)#...})"
                                            "W  -- count words including empty words (with \${(W)#...})"
                                            "X  -- report parsing errors and eXit substitution"
                                            "z  -- split words as if zsh command line"
                                            "Z  -- split words as if zsh command line (with options)"
                                            )
                                    #echo "longest line: $maxl"
                            ;;

                    prompt) declare -g  list_title="Prompt Reference Card (Prompt Characters for ZSH Prompts, the % flag, and print -P)"
                            declare -ga list_items=(
                                            "%[!h] active history #       "
                                            "%[#a] # root, % not root     "
                                            "%%    literal %              "
                                            "%(    %(V.true.false)        "
                                            "%)    literal )              "
                                            "%*    24h time as hh:mm:ss   "
                                            "%[/d] get cwd                "
                                            "%<    strip rh %len<str<     "
                                            "%>    strip rh %len>str<     "
                                            "%?    last cmd's stat        "
                                            "%[@t] date, 12-hr am/pm      "
                                            "%[    strip to /dev/null     "
                                            "%^    reverse of %_          "
                                            "%_    parser status          "
                                            "%{    start ESC seq.         "
                                            "%}    end ESC seq            "
                                            "%[~.] pwd, home as ~         "
                                            "%b    stop bold              "
                                            "%B    start bold             "
                                            "%[Cc] as %1~,%1/ (C,c)       "
                                            "%D    date yy-mm-dd          "
                                            "%D{   fmt like strftime      "
                                            "%E    clear to EOL           "
                                            "%f    reset fg color         "
                                            "%F    start fg color         "
                                            "%G    count/chars %{...%}    "
                                            "%i    get line number        "
                                            "%I    get source line#       "
                                            "%j    number/jobs            "
                                            "%k    reset bg color         "
                                            "%K    start bg color         "
                                            "%l    get tty suffix         "
                                            "%L    \$SHLVL                 "
                                            "%m    hostname up to .       "
                                            "%M    full hostname          "
                                            "%n    username               "
                                            "%N    active executor*       "
                                            "%s    stop standout          "
                                            "%S    start standout         "
                                            "%T    get time 24hr fmt      "
                                            "%u    stop underline         "
                                            "%U    start underline        "
                                            "%Nv   get \$psvar[N]          "
                                            "%w    @ date@ day-dd fmt     "
                                            "%W    date as mm/dd/yy       "
                                            "%x    nameof srced script    "
                                            "%y    get line (tty)         "
                                    )
                                    
                            ;;
                            
                    list)   declare -g  list_title="valid refcards"
                            declare -ga list_items=(
                                            "prompt     reference for % codes in the prompt or print -P"
                                            "flags      for flags used in \${() codes"
                                            "list       the list you are reading right now"
                                    )
                            ;;
                    *)    print -P "%F{red}error: $arg not a valid ref card, use the 'list' refcard to see a list of valid cards%f"
                            exit;;
                esac
                showcard
                
            done
        ;;                        
    esac
else
    is notquiet && print -P "error, code is $?, exiting with fail"
fi
