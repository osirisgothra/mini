#!/usr/bin/perl
#
# FILE
#    perltemplate-file
#    the perltemplate-file perl script
#
# PROJECT
#    perltemplate-file-proj
#	 project perltemplate-file-proj: container for perltemplate-file
#
# AUTHOR / COPYRIGHT
#
#    Copyright (C) 2020, 
#
#    Written by  osirisgothra@larnica.(none)
#    Latest versions of this and all of 's projects can be
#    obtained from:
#
#     <<projbranch>>
#
#    Documentation Available At:
#
#     <http://www.github.com/osirisgothra/perltemplate-file-proj.git>
#
# LICENSE
#
#    perltemplate-file-proj/perltemplate-file  is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#  NOTES
#
#     * TODO: move 'use' statements to top if you want to keep them**
#    ** this feature will be added to the next version of perltemplate (hopefully)
#   *** warnings are disabled for experimental and once because they are pretty
#       annoying here, you might want to re-enable them for your own program
#       to do this during testing and development.
#
#  HISTORY
#
#	Sat Oct 24 14:40:36 2020
#         osirisgothra@larnica.(none) created this file using the template generator 'perltemplate'
#         and named it perltemplate-file for the project '<projname'.
#
#
# (created with perltemplate by Gabriel T. Sharp <osirisgothra@hotmail.com>)
#

use warnings;
use v5.18;
use strict;
no warnings "experimental";			# 	allow given/when/default and smartmatching without their warnings***
no warnings "once";					# 	allow variables to be used just once without warning***


## CURSES ##
use Curses::UI;

my $cui;  # Main Program Object, it must be global so accessor/menu/etc subs can see it
           # even though subs are defined inside of the same routine, subs wont be able to
           # read any function-local data, this is a closure that keeps loops from compromise.
           # an illustration of the closure:

#  GLOBAL STACK     FUNC STACK
#  +---------------+---------+ -> creates function B() but its access is still limited to global and above unless a ref was passed too
#  |     FUNC A    +    A    |
#  |     FUNC A    +    | var|
#  +---------------+---------+
#  +---------------+---------+
#  |     FUNC B    +    B    |-> tries to access cui, but if its in A how would it?
#  +---------------+---------+
#  GLOBAL STACK     FUNC STACK
#    +---------------+
# |->|     var       |
# |  +---------------+
# |    ^
# |    |
# |    | accessible!
# |    |
# | +---------------+---------+ -> creates function 'FUNC B'
# | |     FUNC A    +    A____|
# | |               +    |////| <- readable by A only
# | +---------------+---------+
# | +---------------+---------+
# -|     FUNC B    +    B     |-> tries to access var, and can because its global
#  +---------------+----------+

my $file;
my $debug;

sub curses_demo()
{
    say("curses: entering setting");

    my $debug = 1;  #1=yes 0=no
    say("creating curses");
    $cui = Curses::UI->new( 
            -color_support => 1, 
            -clear_on_exit => 1, 
            -debug => $debug, ); # this is where we gloss over setting up all the widgets and data structures + start the event loop

    # menu subs
    say("curses: entering subs");


    sub exit_dialog()
    {
	    my $return = $cui->dialog	(	-message   => "Do you really want to quit?",
		    							-title     => "Are you sure?",
			    						-buttons   => ['yes', 'no'], );
	    exit(0) if $return;
    }
    sub open_dialog()
    {
        my $file = $cui->filebrowser(	-path => "/tmp", -show_hidden => 1, );
        # Filebrowser will return undef if no file was selected.
        if (defined $file) 
        {    
            unless (open F, ">$file") 
            {	
                print F "Hello, world!\n"; 
                close F; 
            } 
            else 
            { 
                $cui->error(qq(Error on writing to "$file":\n$!)); 
            }
        }
    }
    sub about_dialog()
    {
        $cui->dialog("Hello, world!");
    }
    sub undo()
    {
        my $yes = $cui->dialog( 	-message => "Hello, world?", -buttons => ["yes","no"], -values  => [1,0], -title   => "Question", );        
        if ($yes) { chomp(); } # whatever
        $cui->error("It's the end of the\n"."world as we know it!");
    }    
    say("curses: subs half created");


    sub status1() 
    {
        $cui->status("Saying hello to the world..."); 		    # code for saying "Hello, world!"
    }
    sub status2() 
    {
        $cui->status("Saying goodbye to the world..."); 	        # code for saying "Goodbye, world!"
    }
    sub statusoff()
    {
        $cui->nostatus;
    }
    sub contents()
    {
    
        $cui->progress( -max => 10, -message => "Counting 2 seconds...", );
        for my $second (0..2) 
        {	
            $cui->setprogress($second); 
            sleep 1; 
        }
        $cui->noprogress;
    }
    say "subs created";
    my @menu = (

                 -label => 'File', -submenu => [
                        {        -label => 'Open...'     ,     -value => \&exit_dialog  }
                        ],
                 
                  

                );
                print("enter main loop here...");
    $cui->addmenu(\@menu);
    $cui->mainloop;
}   
curses_demo; 
## END CURSES ##


use Term::ANSIColor 4.0  qw ( colorstrip color colored uncolor coloralias :constants colorvalid :pushpop );

sub ansi_demo()
{

    print color 'bold blue';
    print "This text is bold blue.\n";
    print color 'reset';
    print "This text is normal.\n";
    print colored("Yellow on magenta.", 'yellow on_magenta'), "\n";
    print "This text is normal.\n";
    print colored ['yellow on_magenta'], 'Yellow on magenta.', "\n";
    print colored ['red on_bright_yellow'], 'Red on bright yellow.', "\n";
    print colored ['bright_red on_black'], 'Bright red on black.', "\n";
    print "\n";

    # Strip all color escape sequences.

    print colorstrip '\e[1mThis is bold\e[0m', "\n";

    # Determine whether a color is valid.

    my $valid = colorvalid('blue bold', 'on_magenta');

    print "Color string is ", $valid ? "valid\n" : "invalid\n";

    # Create new aliases for colors.

    coloralias('alert', 'red');

    print "Alert is ", coloralias('alert'), "\n";
    print colored("This is in red.", 'alert'), "\n";
    print BOLD, BLUE, "This text is in bold blue.\n", RESET;

    # localized

    {
    	local $Term::ANSIColor::AUTORESET = 1;
    	print BOLD BLUE "This text is in bold blue.\n";
    	print "This text is normal.\n";
    }

    print PUSHCOLOR RED ON_GREEN "This text is red on green.\n";
    print PUSHCOLOR BRIGHT_BLUE "This text is bright blue on green.\n";
    print RESET BRIGHT_BLUE "This text is just bright blue.\n";
    print POPCOLOR "Back to red on green.\n";
    print LOCALCOLOR GREEN ON_BLUE "This text is green on blue.\n";

    # localized 
    
    print "This text is red on green.\n";
    {
    	local $Term::ANSIColor::AUTOLOCAL = 1;
    	print ON_BLUE "This text is red on blue.\n";
    	print "This text is red on green.\n";
    }
    
    print POPCOLOR "Back to whatever we started as.\n";
}    


use IPC::Open3  qw( open3 );


sub open3_demo()
{
    print "do open3 example? [y/[n]]";
    
    $_ = readline();
    if (/y/) 
    {
    	
    	my $pid = open3( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR, 'xcalc','-fg','red' );
    	my @handles = ( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR );	
    	my($wtr, $rdr, $err);
    	use Symbol "gensym"; $err = gensym;
    	$pid = open3($wtr, $rdr, $err, 'xcalc','-fg','red' ); 
    	waitpid( $pid, 0 );
    	my $child_exit_status = $? >> 8;
    }
}


use Getopt::Long::Descriptive; # opt|shortchar[kind] (kind is =s[tr],=i[nt], or none)

my ($opt, $usage) = describe_options(
    '$0 %o <some-arg> file',
    [ 'no-dialog', "dont use dialog to show log",  ],
    [ 'no-follow',   "do not follow the log, just show it",   { default  => 79 } ],
    [],
    [ 'verbose|v',  "print extra stuff"            ],
    [ 'help',       "print usage message and exit" ],
);

say($usage->text), exit if $opt->help;
say("getopt: arguments processed: $#ARGV");



use Path::Tiny;

sub path_demo()
{
    # creating Path::Tiny objects
    
    print("for this to work, must have /tmp/foo.txt and /tmp/foo/bar.txt first, attempt will be made to create them...");

    sleep(0.5);
    
    my $data1 = `ls -l /`;
    my $data2 = `ls /etc`;
    
    path('/tmp/foo/bar.txt')->spew($data1);
    path('/tmp/foo.txt')->spew($data2);

    my $dir = path("/tmp");
    my $foo = path("foo.txt");
    my $subdir = $dir->child("foo");
    my $bar = $subdir->child("bar.txt");
    
    # stringifies as cleaned up path

    my $file = path("./foo.txt");

    say $file; # "foo.txt"

    # reading files

    my $guts = $file->slurp;
    my @lines = $file->lines;
    my ($head) = $file->lines( {count => 1} );
    my ($tail) = $file->lines( {count => -1} );

    $guts = $file->slurp_utf8;
    @lines = $file->lines_utf8;

    say "head";
    say $head;
    say "tail";
    say $tail;
    say "write data...";
    
    # writing files
    
    my @data = qw ( sample data );

    $bar->spew( @data );
    $bar->spew_utf8( @data );

    # reading directories

    for ( $dir->children )
    { 
        say("children: $_"); 
    }

    my $iter = $dir->iterator;
    
    while ( my $next = $iter->() ) 
    { 
        say("iterated: $next"); 
    }
}
