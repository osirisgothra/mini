#!/usr/bin/perl

use v5.20.2;
use warnings;
use strict;

use Cwd;
use File::Path;
use Path::Tiny;
use Getopt::Long::Descriptive;
use feature 'signatures';
no warnings 'experimental';
use constant { nil => undef, true => 1, false => 0 };
use constant { single =>1, double => 2, tripple => 3, quadruple => 4 };
# does not work properly:
# it seems the author did not use termcap but blindly uses ANSI
# standards from xterm/xterm-256color/linux which is most of the time
# compatible but not always (ie; like fbterm, vesaterm, stterm, Eterm, etc)
# no use Term::ANSIColor 4.00 qw( colorvalid :constants coloralias colorstrip :constants256 );
# doing it ourselves:
my $afstr = "";
my $abstr = "";
my $rst = "";
my $colorcount = 1;

sub setupansi()
{
    $colorcount = `tput colors`;
    $afstr = `tput setaf 9999`;    # looks sloppy but its guarentees compatibility with ALL terminals
    $abstr = `tput setab 9999`;
    $rst   = `tput sgr0`;
    chomp($colorcount);
    chomp($afstr);
    chomp($abstr);
    chomp($rst);

}

sub seta($val,$part) # name=seta, args=color(val) part=bg|rst|fg  exits=4
{
    # inf. wraparound to 1 (not 0) of values (-1(255),0(0),1(1),2(2)...255(255),256(1),257(2), etc)
    
    $val %= $colorcount; #( $val > 0 );    
    $val = 1 if $val == 0;
    
    my $sendstr = "<invalid val=$val part=$part to seta()>";
    given($part) {
        when (/fg/) {
            $sendstr = $afstr; # copy, dont clobber afstr!
            $sendstr =~ s/9999/$val/g;
            return $sendstr;
        }
        when (/bg/) {
            $sendstr = $abstr; # copy, dont clobber abstr!
            $sendstr =~ s/9999/$val/g;
            return $sendstr;
        }
        when (/rst/) {
            # val never used here
            return $rst;
        }
        default
        {
            warn("seta() called with invalid values");
            return $sendstr;
        }
    }
}
sub setfg($num) { return seta($num,"fg"); }
sub setbg($num) { return seta($num,"bg"); }
sub crst($num=0) { return seta($num,"rst"); }
sub colorize($str) {
    my @items = split(/~(\d+)/,$str);
    my $final = "";
    if (@items > 1) # has color data if split was not a no-go (single or no items)
    {
        for my $_item (@items) 
        {
            given($_item) 
            {
                when (/^\d+$/) 
                {
                    my %ranges = ( uninitialized => 1 );
                    my $num = $_item; # warning, do NOT convert to integer, this would destroy any padding of zeros needed to create 6c or 4c codes
                    # a number, always a color code (inline numbers wont get isolated like this)
                    if ($num >= 256 && $num < 512) 
                    {
                        $final .= setbg($num - 256);
                    }
                    elsif ($num >= 512)
                    {                        
                        if ( length($num) == 6 )    { %ranges = ( f => 0, b => 3, l => 3 ); }              # ~fffbbb compact code form (warning, no check for > 256 here is done, its on the programmer to use this properly!)
                        elsif ( length($num) == 4 ) { %ranges = ( f => 0, b => 2, l => 2 ); }              # ~ffbb compact code form (preferred, though limited to 0-99 it is guarenteed to not be out of range)
                        else                        { %ranges = ( f => -1 ) };                             # -anything else is not valid                        
                        if ($ranges{'f'} < 0) { $final .="<invalid_wormcc_code:$num>"; }                   # /  
                        else                  { $final .= setfg(substr($num,$ranges{'f'},$ranges{'l'})); 
                                                $final .= setbg(substr($num,$ranges{'b'},$ranges{'l'})); } # -validate the code and insert (padding with zeros is ok and suggested)
                    }
                    else    # color code is <= 255
                    {
                        $final .= setfg($num);
                    }
               }
               default
               {
                    # just text, add without discrimination (empty strings wont add anything, naturally)
                    $final .= $_item;                    
               }
           } # given           
        } # for (items)
    }
    else
    {
        # only one item, does not qualify to be interpreted as a color code (just give back same string)
        $final = $str;                       
    } # if (@items)   
    return $final;
} # sub(colorize)



# comments

  #1   (main program end of page):  first form shows multiple names given in this style except when scalar(@ARGV) == 1, second form shows current dir (cwd) when no arguments are given, forcing multimode to 0 always
  #2   function showentries(dirname=cwd,multiple_item_mode=1)
  #3   showentries() line 2: hint for this function to reveal whether we are being iterated over(1) or one-shotted(0)
  #6   unreachable is a flung around flag thats kinda ugly, i'd like to be rid of it by this time

# option processing functions

sub _s($ln,$sn=undef) { return ("$ln|" . ($sn // substr($ln,0,1)) . '=s'); }
sub _i($ln,$sn=undef) { return ("$ln|" . ($sn // substr($ln,0,1)) . '=i'); }
sub _o($ln,$sn=undef) { return ("$ln|" . ($sn // substr($ln,0,1)) . ''  ); }


my ($opt, $usage) = describe_options(
    'my-program %o <some-arg>',
    # string options
    [ _s( "sort" ),             "sort the list",  { default => "name" } ],
    # integral options
    [ _i( "columns"   ),        "output into columns shortly (def=1)",   { default  => 1 } ],
    # filler/separator
    [],
    # flag/bool options
    [ _o( 'long' ),             "long list format -not implemented yet-" ],
    [ _o( 'all' ),              "all entries" ],
    [ _o( 'almost-all','A' ),   "all entries but . and .." ],
    [ _o( 'verbose' ),          "print extra stuff" ],
    [ _o( 'help' ),             "print usage message and exit", { shortcircuit => 1 } ],
);
my $swd = path(cwd);
say($usage->text), exit if $opt->help;

# declarations

my $unreachable = 0;
my $efmt = "%25s %-s\n";

# functions

sub getentries($from)
{
#6 pathize
    $from = path($from);                                                                                                                                       #6
    
}
#5 discontinued
sub discontinued()                                                                                                                                             #5
{

#        $bits{}|= if -r; # File is readable by effective uid/gid.
#        $bits{}|= if -w; # File is writable by effective uid/gid.
#        $bits{}|= if -x; # File is executable by effective uid/gid.        
#        
#        # ruid rwx
#        $bits{}|= if -R; # File is readable by real uid/gid.
#        $bits{}|= if -W; # File is writable by real uid/gid.
#        $bits{}|= if -X; # File is executable by real uid/gid.
#              0 dev      device number of filesystem
#              1 ino      inode number
#              2 mode     file mode  (type and permissions)
#              3 nlink    number of (hard) links to the file
#              4 uid      numeric user ID of file's owner
#              5 gid      numeric group ID of file's owner
#              6 rdev     the device identifier (special files only)
#              7 size     total size of file, in bytes
#              8 atime    last access time in seconds since the epoch
#              9 mtime    last modify time in seconds since the epoch
#             10 ctime    inode change time in seconds since the epoch (*)
#             11 blksize  preferred I/O size in bytes for interacting with the file (may vary from file to file)
#             12 blocks   actual number of system-specific blocks allocated on disk (often, but not always, 512 bytes each)
#
}
sub _getstat($pathname,$blink)
{
    return path($pathname)->stat() unless $blink;
    return path($pathname)->lstat();   
}

# showentry
sub showentry($_pwd,$_item)
{
        # turn into path object -7
        $_item = path($_item);                                                                                                                                     #7
        $_pwd = path($_pwd);
    
        my $_kind = "";
        my %bits = (    cee => 0,   #c      content/exists/empty
                    dt => 0,    #d      estimated date/time from script start (Mod/Acc/Create|InodeChange)
                    euid => 0,  #e      effective uid read/write/exec
                    fdl => 0,   #f      filetype plain/directory/link
                    owner => 0, #o      euid owned/guid owned/neither
                    ruid => 0,  #r      real uid read/write/exec
                    sbcf => 0,  #s      fifo/socket/char-device/block-device flags
                    tac => 0,   #t      tty-opened/binary-file/ascii-file (kinds are estimated best guess)
                    usuid => 0, #u      setuid/setgid/sticky bits (see chmod(3))
                );
        my $bitout ="";               
        $_ = $_item;

    
        # euid rwx        
        $bits{euid}|=1 if -r;
        $bits{euid}|=2 if -w;
        $bits{euid}|=4 if -x;        
        $bits{ruid}|=1 if -R;
        $bits{ruid}|=2 if -W;
        $bits{ruid}|=4 if -X;
        $bits{owner}|=1 if -o;
        $bits{owner}|=2 if -O;        
        $bits{usuid}|=1 if -u; # File has setuid bit set.
        $bits{usuid}|=2 if -g; # File has setgid bit set.
        $bits{usuid}|=3 if -k; # File has sticky bit set.
        $bits{cee}|=1 if -e; # File exists.
        $bits{cee}|=2 if -z; # File has zero size (is empty).
        $bits{cee}|=4 if -s; # File has nonzero size (returns size in bytes).
        $bits{fdl}|=1 if -f; # File is a plain file.
        $bits{fdl}|=2 if -d; # File is a directory.
        $bits{fdl}|=3 if -l; # File is a symbolic link (false if symlinks aren't supported by the file system).
        $bits{sbcf}|=1 if -p; # File is a named pipe (FIFO), or Filehandle is a pipe.
        $bits{sbcf}|=2 if -S; # File is a socket.
        $bits{sbcf}|=4 if -b; # File is a block special file.
        $bits{sbcf}|=8 if -c; # File is a character special file.                
        unless ( -c or -t or -b )
        {
            $bits{tac}|=1 if -t; # Filehandle is opened to a tty.
            $bits{tac}|=2 if -B; # File is a "binary" file (opposite of -T).          
            $bits{tac}|=4 if -T; # File is an ASCII or UTF-8 text file (heuristic guess).            
            $bits{dt}|=1 if -M; # Script start time minus Modification time, in days.            
            $bits{dt}|=2 if -A; # Access time. #8.3
            $bits{dt}|=4 if -C; # Inode change time (Unix, may differ for other platforms) #8.5            
        }           
        $bitout="";
        for (keys(%bits)) {
            if ( $bits{$_} > 0 )  {
                    
                $bitout .= setbg($bits{$_}) . substr($_,0,1) . crst;  # use first char as signal bit
            } else { $bitout .= " "; }
        }
        my $entry = $_;                
        if ( -d ) {        
            printf(colorize("%s ~240[~28%s~242]~28"),$bitout,$entry);
        }
        else {
            printf("%s %s",$bitout,$entry);
        }        
        if ( -l )
        {
            my $linkitem = readlink($_);
            printf(colorize(" ~236-~237> ~240[~238%s~240]~28\n"),$linkitem);
        }
        else
        {
            printf("\n");
        }
}
sub dosort(@targets)
{
    my @target = @targets;
    my @result;
    
    $_ = $opt->sort;
    if ( /name/ ) 
    {
         @result = sort { $a cmp $b } @target;
    }
    elsif ( /size/ )
    {
        @result = sort {
                my $sizea = 0;
                my $sizeb = 0;
                $sizea = (stat($a))[7] if -r $a;
                $sizeb = (stat($b))[7] if -r $b;
                # unless ($opt->no_dereference) {
                $sizea = (lstat($a))[7] if -l $a;
                $sizeb = (lstat($b))[7] if -l $b;
                # }
                if ($sizea > $sizeb) {
                        return 1;
                } else {
                    if ( $sizea < $sizeb ) {
                        return -1;
                    } else {
                        return 0;
                    }
                }

        } @target;
    }
    else 
    {
        warn "the '" . $opt->sort . "' sort method not known, using the 'none' method" unless /none/;
        @result = @target;    # no sort if invalid or none
    
    }

    return @result;
}

sub showentries($wd=$swd,$multimode=1)                                                                                                                                #2
{
    chdir($wd) if -d $wd;
    given ( $wd )
    {
        when ( -d  or -e ) 
        {
            my @entries = ();
            say("\n" . $wd . "\n") if $multimode or (@entries > 1);
            unless ( -d $wd )
            {                   
                @entries = ( glob($wd) );
                printf("(warning: -a and -A are useless with single entry specified)\n") if $opt->all or $opt->almost_all;
                printf("(warning: -a and -A are useless with single entry specified)\n") if $opt->all or $opt->almost_all;

            }
            else
            {
                @entries = glob('*');
                push(@entries, grep { $_ if /^.[^.]+/ } glob('.*')) if ( $opt->almost_all or $opt->all );
                push(@entries, qw( .. . )) if $opt->all;
            }            
            showentry( $wd, "$_" ) for dosort(@entries);
            say ( "\n" . @entries . " item(s)\n" ) if $multimode or ( @entries > 1 );
            
        }
        default 
        {
            say ("$wd : not found");
        }  
    }     
    chdir($swd) if -d $wd;                                                                                                                                     #4
}

# main program

setupansi();    # needed for the Term::ANSI replacement
if (@ARGV) {
    showentries($_, 0) for @ARGV;                                                                                                                              #1
} else {
    showentries;
}    

