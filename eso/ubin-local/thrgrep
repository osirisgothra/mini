#!/bin/zsh
#
#    thrgrep
#    programs to NICE, CPUMASK, SECONTEXT, and IOPRIORITY, rolled into one
#    mini/eso/ubin-local
#    local esoteric projects/scripts/etc
#
# LICENSE, SUPPORT & AUTHOR INFORMATION
#
#    Copyright (C) 1995-2018 Gabriel Thomas Sharp
#
#    Written by Gabriel T. Sharp <21shariria@gmail.com>
#    Latest versions of this and all of my projects can be
#    obtained by visiting the repository: 
#
#    <https://github.com/osirisgothra>
#
#    Because of the global availability of github at this point, hosting
#    any additional servers for public use no longer serves a purpose. All
#    content is available 24/7 through github. (Thanks to GITHUB!).
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#  HISTORY
#
#	 Sun 14 Jun 2020 07:17:29 PM EDT
#            osirisgothra@ initially created this file
#            with the original name, thrgrep
#
#  SCRIPT COMMENTS
#
#		     As a practice and a matter of pedantic ethics, use this section to 
#		outline changes, bugs, notes, etc. You need only reference the location 
#       of or, preferably, block description or name. Don't use line numbers as 
#	    those will/may change often! You can, alternatively, use a count (for a
#		example: "next 4 lines" is a valid location as long as its also has ref
#		to block description..
#
#	SCRIPT BLOCK or LINE DESC	|	DESCRIPTION
#	============================|=============================================
#   ENDOFFILE, UNDER "FOOTNOTES"|  USED TO STORE LENGTHY DESCRIPTIONS
#								|  do NOT store index for it here, though!
#	STARTOFFILE, HERE			|  added template, use for short comments only
#
#   ==========================================================================  
#	
#
#  TARGET NOTES
#
# 	EXECUTIVE STATE CHANGES
#		marking single existing file executable
#			- mode of 'thrgrep' changed to u+rwx/og+rx.. []
#		completed (errors: 0)
#
# 	ARGUMENTUAL ANALYSIS
#       remaining arguments:
#			0 arguments, with 0 error argument(s)
#       disposition:
#			4 were used during execution of template
#   		0 were extra/unexpected error(s)
#
# 	TEMPLATE SUMMARY OF GENERATION
#	 final outcome: good
#     total errors: 0
#
# 	FINAL NOTES
#		 (Sun 14 Jun 2020 07:17:29 PM EDT): osirisgothra reammended the target results 
#
#  (this template+header was created using the template generator by Gabriel T. Sharp)
#
#	template output completed (code=OK(ERROR_NONE))
#
#



declare -gi MAXINT=32767
declare -g docloc="/usr/share/doc/paradisim/mini/ubin-local/thrgrep"
declare -g presetconfig="$HOME/.thrgreppresetrc"

! [[ -r ~/.iamosirisgothra ]] && { echo "\n NB: not intended for release of any kind use at own risk, or not at all! (ctrl+break aborts) you will have to read code to disable this message if you are not me \n"; sleep 15; }

# zmodules required 

zmodload zsh/terminfo 
zmodload zsh/mathfunc

# store original tty caller
otty=$(tty)
# restore terminal setup (keyboard mainly)
stty sane



declare -g unset_state="$(uuidgen)"


# do not change these unless you know what you are doing and understand the risks in doing so:
# they do not affect the system once thrgrep is completed, it disappears anyway. This just helps
# this process complete a bit faster. Multiple self calls will not trip this as per checking var.
#	self_nice		niceness of thrgrep script
#	self_class		io class (idle, realtime, best-effort, none)
#	self_class_level	(0-7 or just 0 for idle and none)
#	self_thrgrep_threshold	system load is at or lower, will not self thrgrep (-1 means disable and never use, 255 means disable and always use)
#
#
declare -gi self_nice=-16
declare -g self_class=realtime
declare -g self_class_level=2
declare -gF self_thrgrep_threshold=255
declare -gF self_load=${$(</proc/loadavg)[1]}
declare -gi maxstep=2
declare -gi gstart=17
declare -gi del=15

cecho()
{
	# dont use the first 16 colors, or the 16 grays at the end
	# (only use "chroma-vibrant" colors)
	dir=${RANDOM: 0:1}
	let del--
	if [[ $del -le 0 ]]; then
		del=${RANDOM: 0:2}
	
		if [[ $dir -ge 5 ]]; then
			dir=6
		else
			dir=-6
		fi
	fi

	let gstart+=$(( dir / sin(del) ))
	if [[ $gstart -ge 230 ]]; then
		gstart=23
	elif [[ $gstart -le 16 ]]; then
		gstart=223
	fi

	case $# in
		0) 	echo "ERROR:NO_STRING_GIVEN(f=$0 l=$LINENO)"
			return
			;;
		1) 	start=$gstart
		   	step=4
			[[ $step -ge $maxstep ]] && step=$maxstep
		   	str=$1
			;;
		*)	start=$1
			step=$2
			str=$3
			;;
	esac

	cur=$start
	for ((x=0;x<$#str;x++)); do		
		ch=${str: x:1}
		c $cur
		let cur+=$step
		printf "%s" "$ch"
	done
	
}
c() { echoti setaf ${1-7}; [[ $# -gt 1 ]] && { echoti setab ${2}; shift 2; if [[ $# -gt 0 ]]; then echoti $@; fi; }; }

# tests (comment these out)
# first incantation of cecho/c
#cecho 39 5 "the quick brown fox: jumped over, the; 123456789 lazy / d0gs!?"
# second incantation (random)
#cecho "the quick brown fox: jumped over, the; 123456789 lazy / d0gs!?"

echo() {
	case $# in
	1)	cecho "$@"; builtin echo "";;
	*)	builtin echo "$@";;
	esac
}


if [[ $THRGREP_CHANGED_MY_PRI != 1 ]]; then
	if ( [[ $self_load -le $self_thrgrep_threshold  ]] && [[ $self_thrgrep_threshold -le 254 ]] ) || [[ $self_thrgrep_threshold -le -1 ]]; then
		if [[ $self_thrgrep_threshold -le -1 ]]; then
			echo "skipping self threshold (its hard-disabled in the script: $0)"
		else
			echo "skipping self threshold because threshold is $self_thrgrep_threshold and load is $self_load"
		fi
	else
		if [[ $self_thrgrep_threshold -ge 255 ]]; then
			echo "setting self priority (it is hard coded in the script: $0)"
		else
			echo "setting self priority (to survive a high load ($self_load, greater than the $self_thrgrep_threshold limit) situation)..."
		fi
		echo "***beginning self priority***"
		export THRGREP_CHANGED_MY_PRI=1
		tg_name=${0##*/}
		"$0" "$tg_name" -16 realtime 2
		r=$? ps=$pipestatus
		echo "***self priority setting ends***"
		echo "self I/O and NICE setting completed (errors=$r, pipestatus=$ps ($#ps in pipeline))"
	fi
else
	echo "skipping self threshold because: threshold delegation has already executed and we are it (tasking $$ to adjust ${PPID}'s level)"
fi	


assert()
{
	# syntax: assert(directive,value) (works for all but developer tool(s) below)
	#   developer tools:
	#     assert(avg_op,opname,target,value) --> [[ value OPERATION target ]]
	#			(where OPERATION is opname replaced at runtime)
	#			(note: avg_op is not usually to be used directly by user)
	#
	directive="${1-$unset_state}"
	shift
	case $directive in
	   $unset_state) echo "super failure, not enough arguments for assert!!"
					 echo "(none at all given, not even a DIRECTIVE)"
					 echo "report code: $unset_state"
					 exit 131; sleep 12288
					;;
			 eqavg)	 assert avg_op eq $@ ;;
			 gtavg)	 assert avg_op gt $@ ;;
			 ltavg)  assert avg_op lt $@ ;;
			 geavg)  assert avg_op ge $@ ;;
			 leavg)  assert avg_op le $@ ;;
			 neavg)  assert avg_op ne $@ ;;
			 avg_op)
					 typeset -g op="${1-eq}"; shift
					 typeset -i target="${1-0}"; shift
			 		 typeset -i final=0
					 typeset -i count=$#
					 typeset -i tag=0
					 [[ $# -lt 1 ]] && { return 0 }
					 for tag; do final+=$tag; done
					 eval "[[ $final -$op $target ]]"
					;;
			 R) for tag; do assert r "$tag"; done;;
			 W) for tag; do assert w "$tag"; done;;
			 X) for tag; do  assert x "$tag"; done;;
			 D) for tag; do  assert d "$tag"; done;;
			 x) [[ -x "$*" ]];;		d) [[ -d "$*" ]];;
			 w) [[ -w "$*" ]];;
	         r) [[ -r "$*" ]];;
	 qbalanced) r=$(grep -c "[\"']" "$*"); (( r % 2 == 0 && r > 1 ));;
   qunbalanced) ! assert qbalanced;;
	   numeric) [[ "$*" =~ ^[0-9]+$ ]];;
       nimatch) ! assert imatch "$@";;
        imatch) assert match "${(U)@}";;
        nmatch) ! assert match "$@";;
         match)  [[ $1 =~ ${@: 2} ]];;
        filled) ! assert empty "$@";;
         empty)    [[ ${#${(j: :)*}} -lt 1 ]];;
             *) echo "assert failed (${directive-UNSPECIFIED} directive was unexpected) failing abnormally(130): testparams=[$@]";    false;;
	esac
	# return value will be delegated to caller by default, make sure not to do ANYTHING outside of the case
}
xassert()
{
	if assert "$@"; then
		exec 1>$otty
		exec 2>&1
		echo "failed to assert $1 $2 ..."
		echo "stopping"
		sleep 2
		echo "press a key to exit"
		read -sk1
	fi
}
if [[ $1 == custom ]]; then
	ib() {
			stty sane > $otty
			echo -e "\n\nabout to execute \"$0(${(j:,:)${(qq)@}})\"" | hi "[\"'][^\"']+[\"']"  > $otty
			echo -e "\ndetail:\n\n\tPrompt=[$1]\n\tDefaultValue=[$2]\n\tTestAgainst=[$3]\n\n" > $otty
			read -sk1
			response="$unset_state"
			# common dialog settings (here only)
			local comm=( --cancel-label Back --no-lines --output-fd 1 --backtitle "\"${THRGREP_BACKTITLE-Press Cancel or Break anytime to abort custom selection process}\"" )
			xassert filled "$3"
			xassert empty "$4"
			until [[ $response =~ ${3} ]]; do
				[[ $response != "$unset_state" ]] && {
					dialog $comm --msgbox "$response is not a valid option (expects a match to regex: $3)" 0 0
				}
				response=`dialog $comm --inputbox "$1" 0 0 "$2"`
			done
		}
	# remember DIALOGRC to be set before call(s) for custom colors!
	declare -gx proc=`ib "RegEx for Processes to Match" ".*"` || exit 127
	declare -gx nlvl=`ib "Process Niceness, -19 (fastest) to 19 (slowest)" "^-?1?[0-9]\$"` || exit 127
	declare -gx iogrp=`ib "Process IO Group (realtime,best-effort,idle)" "best-effort" "^(realtime|best-effort|idle)\$"` || exit 127
	declare -gx iopri=`ib "Process IO Priority (0=none 1=lowest .. 5*=normal .. 7=highest)" "5"` || exit 127
exit 111
	dialog --prgbox $((LINES-4?LINES-4:24)) $((COLUMNS-4?COLUMNS-4:80)) "Applying Custom Preset" "thrgrep $proc $nlvl $iogrp $iopri"
fi


declare -gxA BUILTIN_PRESETS=( "rtfast"		"-12 realtime 2"
								"rtgood"	"-14 realtime 4"
							 	"normal"	"0 best-effort 5"
								"lazy"		"12 idle 0"
							 	"javafast"	"java -14 realtime 5"
							 	"xorg"		"Xorg -14 realtime 2"  )
declare -gxA PRESETS=( )
declare -gxA err=(	unk		"127?unspecified error" )
function crash()
{
	case ${1-none} in
		none) 	echo "fatal error: crashing (no error description given (cmdline=$*)!"
			  	crash unk
				;;
		*)  	if [[ $1 =~ ^[0-9]+\\\?[a-z]+$ ]] {
					local errcode=${1%%\?*}
					local errtext=${1##*\?}
					echo "crashing (code $errcode): $errtext"
				}
				;;
	esac
}

function gather()
{	#    int gather(type)
	#	 type: owned all root service system siblings parent-siblings toplevel bottomlevel detached tty stopped stopping zombied
	#	  int: 0=ok !0=error (1=unspecified error, return code possible from last program executed)
	# type(s) implemented so far: (uncoded: owned all root) (coded: NONE YET)
	case ${1-unk} in
		unk)	echo "no type given - program error - exiting (${?-no return code available}/${pipestatus-no pipe status})"; exit ;;
		*) echo "unsupported: $1"; return 1;;
	esac

}
local function debug()
{
	#completely transparent if not enabled, let all status codes
	#fall through the cracks!
	if ((tg_debug_enable)); then
		cecho "debug($SECONDS,$PWD,$?,$pipestatus): $*"
	fi
}
assert()
{
	local R=$? PS=$pipestatus USCOR="$_" BS="$0"
	if eval "$@"; then
		return 0
	else
		echo "FATAL: ASSERT FAILED!"
		echo "-----------------------------\ncall stack:\n$(caller $MAXINT)-----------------------------\n"
		echo "pipes: $PS			status/returncode: $R"
		echo "lastparam: $USCOR		source(?stack?): $BS"
		echo "pid: $$ 				ppid: $PPID"
		tput setaf 13
		echo "[A] ABORT(DEFAULT)	[C] CONTINUE AT OWN RISK"
		tput sgr0
		while true; do read -sk1
			[[ $REPLY =~ [aAcC] ]] && break
			if [[ $REPLY == "" ]]; then
				REPLY=A
				break
			fi
			echo "Invalid Choice, please pick A or C [ENTER=C]"
		done

		case ${REPLY^^} in A) echo "aborted."; exit 124;;
                           C) echo "continuing in 5 seconds...";sleep 5s; return 122;;
			     		   *) echo "fatal??? real bad: even assert failed, must be corruption somewhere!"; exit 123;;
		esac
	fi
}
init_presets()
{
	local nopresets=0
	if [[ -r $presetconfig ]]; then
		 eval "typeset -gxA PRESETS=( `cat $presetconfig | grep '^\".*" ".*"'` )"
#		mapfile PRESETS <$presetconfig ## DISABLED (due to lack of support for named array entries)
		if [[ ${#PRESETS[@]} -lt 1 ]]; then
			echo "$presetconfig did not contain any valid presets!"
			let nopresets++
		else
			echo "$#PRESETS preset(s) loaded from $presetconfig"
		fi
	else
		let nopresets++
	fi
	if ((nopresets)); then
		echo -e "notice: no $presetconfig found, only internal presets are available at this time\n		  see $docloc (make sure ubinlocal-docs are installed) for details/examples"
		unset PRESETS
		declare -gA PRESETS=( "${(kv)BUILTIN_PRESETS[@]}" )
	fi
}
function has_preset()
{
	select_preset "$1"
	if [[ $PRESETVAL != "" ]]; then
		return 0;
	else
		return 1;
	fi
	# (1==false 0==true)
}
function select_preset()
{
	for x in "${(k)PRESETS[@]}"; do
		debug echo "checking $1 against $x"
		if [[ $1 == $x ]]; then
			echo "found $x = $PRESETS[$x]"
			PRESETNAME="$x"
			PRESETVAL="$PRESETS[$x]"
			return 0
		else
			PRESETNAME=""
		fi
	done
}
init_presets
if ! has_preset "$1"; then
	echo "processing as normal command line (no known preset named)"
else
	echo "about to use preset $PRESETNAME with value of $PRESETVAL"
	assert '[[ $PRESETVAL != "" ]]'
	if [[ "$2" != "" ]]; then
		searchterm="$2"
	else
		searchterm=""
	fi
	[[ $# -gt 2 ]] && { echo "warning: more arguments on command line in preset mode---they will be ignored"; }
	echo "transform from preset: $PRESETNAME -> $PRESETVAL"
	if [[ $PRESETVAL =~ , ]]; then
		echo "detected meta-preset, running as subcommand..."
		for x in ${(s:,:)PRESETVAL}; do
			echo "delegating thrgrep $x..."
			command "$0" "$x"
		done
		exit 122
	fi
	if [[ $searchterm != "" ]]; then
		eval set -- $searchterm $PRESETVAL
	else
		eval set -- $PRESETVAL
	fi

	echo "injecting into normal command..."
fi

if [[ $1 == "list" ]]; then
	# declare -p PRESETS
	pp=0
	echo "known presets"
	echo "---------------------------------------------------"
	for p in "${(k)PRESETS[@]}"; do
		echo "$p[[20C${PRESETS[$p]}"
		let pp++
	done
	echo "---------------------------------------------------"
	echo "$pp preset(s)"

fi

usage()
{
cat <<-EOF
					usage: thrgrep "search-regex"
					   or: thrgrep "search-regex" [nice]
					   or: thrgrep "search-regex" [nice] [be-ionice]
					   or: thrgrep "search-regex" [nice] [class] [ionice]
					   or: thrgrep [preset]

					presets are in the form of command assigning to a thrgrep
					syntax as stated above (except for the preset one of course)
					an example shown here:
						thrgrep javafast		<- typed
					inside .thrgreppresetrc or BUILTIN_PRESETS:
ORIGINALLY (when bash was the scripting language):
						[presetname]='commandline'
CHANGE:
						presetname 'commandline'
						presetname subpreset1, subpreset2, ...

					where "search-regex" is any regular expression(s) that are
					supported by pgrep (see pgrep(1) for details), and [nice] is
					an integer value, lowest values being highest priority. Accepted
					values are from -20 to 19, which is the lowest priority. Also,
					the [be-ionice] is a value 0-5 which defines which "Best Effort"
					classed nice-ness for io priority via ionice. The fourth incantation
					allows for the change of this ionice class to one of the three
					accepted classes known for ionice (realtime, best-effort, or idle).

					values accepted are subject to change with the programs that are used
					here, please refer to each separate program for up-to-date information
					on it's possible arguments:

					[nice]			see nice(1) and renice(1)
					[(be-)ionice]	see ionice(3)
					[class]			see ionice(3) or ioprio(3)
					"search-regex"	see pgrep(1) and perlreref(2) for detailed info on regexes

					regular expressions are NOT checked for syntax validity by this program
					please make sure you test them in pgrep before bringing them here as there
					may be problems when using extraneous expressions as an input expression.

					written for bash-perl programming environments
EOF
}

# renice [-n] <priority> [-p|--pid] <pid>...
# renice [-n] <priority>  -g|--pgrp <pgid>...
# renice [-n] <priority>  -u|--user <user>...
# ionice -c <0|1|2|3|none|realtime|best-effort|idle> -n <0|1|2|3|4|5|6|7> -p|--pid <pid> --t|--ignore
# ionice -c <0|1|2|3|none|realtime|best-effort|idle> -n <0|1|2|3|4|5|6|7> -P|--pgid <pgrp> --t|--ignore
# ionice -c <0|1|2|3|none|realtime|best-effort|idle> -n <0|1|2|3|4|5|6|7> -u|--uid <uid> --t|--ignore
# ionice -c <0|1|2|3|none|realtime|best-effort|idle> -n <0|1|2|3|4|5|6|7> </path/to/command> --t|--ignore
# ionice --help|-h|-V|--version

if [[ $* =~ --help ]] || [[ $# -eq 0 ]]; then
	echo -e "\nat least 1 argument is required!\n"
	usage
	exit 0
fi

CMD="$1"
shift
echo "using $CMD as criteria"
THREADS=( $(pgrep -w $CMD) )
if [[ $CMD == "all" ]]; then
	echo "special criteria 'all' found (meaning: all threads under current user)"
	BLACKLIST=( '\(sd' '^systemd' '^dbus-' )
	NAMES=( $(awk '{ print $2 ; }' <<< `pgrep -u1000 -l`) )
	# 2(0) <- loop distance-from-right(left-depth) \v/
	for x in $NAMES; do
								#1(1)
		for y in $BLACKLIST; do
									#0(2)
			if [[ $x =~ $y ]]; then
				echo "cannot do $x, its a blacklist item"
				continue 2
			fi
		done
        # echo "we should thrgrep $x $@"
		# we do, here (recalls self, but not in same symbol space)
		# debug only: # echo thrgrep $x $@
		thrgrep $x $@
		# if we had to continue inner_loop, we would actually do inner_loop-1 here (but that wouldnt be needed since its our loop anyway)
	done
	exit 0
elif [[ ${#THREADS[@]} -eq 0 ]]; then
	echo "no threads found under the given critieria: $CMD"
	exit 1
else
	if [[ $UID -eq 0 ]]; then
		echo "running as root, running in normal mode..."
		pfx=command
	else
		echo "running as a non-root user, switching to sudo mode..."
		pfx=sudo
	fi
fi
std_out="/dev/stdout"
err_out="/dev/null"

( for THREADID in "${THREADS[@]}"; do
	
	case $# in
		0)	# display only
			echo "$THREADID"
			;;
		1)	# renice only
#			[[ $1 =~ ^-?[0-9]+$ ]] || die "bad nice level value: $1"
#			[[ $THREADID =~ ^[0-9]+$ ]] || die "thread id not legal (numeric decimal integers only): $THREADID"
			$pfx renice -n $1 -p $THREADID 2>$err_out 1>$std_out 
			;;
		2)	# renice | besteffort-prio
			$pfx renice -n $1 -p $THREADID 2>$err_out 1>$std_out
			$pfx ionice -c best-effort -n $2 -p $THREADID 2>$err_out 1>$std_out
			;;
		3)	# renice | class + prio
			#echo "pfx=\"$pfx\", declaration follows:"
			#declare -p pfx
			#echo "$pfx renice -n $1 -p $THREADID 2>$err_out 1>$std_out"
			$pfx renice -n $1 -p $THREADID 2>$err_out 1>$std_out
			#echo "$pfx ionice -c $2 -n $3 -p $THREADID 2>$err_out 1>$std_out"
			$pfx ionice -c $2 -n $3 -p $THREADID 2>$err_out 1>$std_out
			;;
		*)
			usage
			break
			;;
	esac

done ) | while read r; do
			echo "$r"
		done

exit $?
#################################### /\F    N   S/\ #####################################################
#### DO NOT PLACE CODE BELOW HERE ##/  \O T/\O E/  \### END OF PROGRAM ########## KEEP ABOVE HERE #######
####################################    \O/  \T/    #####################################################

