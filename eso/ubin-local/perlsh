#!/usr/bin/env perl
eval 'exec /usr/bin/env perl -S $0 ${1+"$@"}' unless 1;

#
#   Originally Written By & Copyright (c) 2014 Hiroo Hayashi. All Rights Reserved.
#   PLEASE SEE ORIGINAL LICENSE FOR DETAILS ON USAGE RIGHTS
#

package PerlSh;
use v5.20.2;
use Path::Tiny;
use Cwd;
use strict;
use Term::ReadLine;
use POSIX;
use Term::ANSIColor 4.00 qw( :constants :constants256 colored colorstrip );
use Path::Tiny;
use Cwd;
use Data::Dumper;
use IPC::Open3;

# Constants

use constant { DFLINES => 24, DFCOLS => 80 };
use constant { PAD_L=>1, PAD_R=>1 };
use constant { PAD_LR=>PAD_L+PAD_R };

# Predeclared Subs

use subs qw( say );

# Predeclared Variables

use vars qw($PS1 $PS2 $HISTFILE $HISTSIZE $INPUTRC $STRICT $INNERRC $PS1COLOR $NO_ADORNERS $NO_ADORNERS_OR_CONTENT
            $PS1MONO $NOCOLOR %VERSION $LINES $COLUMNS $HOSTNAME $LOGNAME $CWP
            $LASTRV $USER $UID $UNAME $USERNAME $HOMEDIR $PROGNAME $AUTOCOLOR @STARTUP_COMMANDS $lastcmd_startcmd);

# Features

#use feature "signatures";                                                                # TODO: convert sigil subs to signature subs

no warnings 'deprecated';
no warnings qw(all);                                                                      # testing only


$NO_ADORNERS=0;                 # disables box adorners, just prints any contentual text
$NO_ADORNERS_OR_CONTENT=0;      # removes adorners and also any contentual text
$LINES=int(`tput lines`);
$COLUMNS=int(`tput cols`);
$PROGNAME="PerlSh";
$AUTOCOLOR=0;       # <1|0>
$NOCOLOR="both";    # <primary|secondary|both|none>
%VERSION=( major => 2, minor => 4, revision => 1 );

sub setprompt() {

    $PS2 = '[38;5;200m[1mmore[2m?[21m[22m ';
    $PS1 = "[38;5;232m[[38;5;21mP[38;5;25me[38;5;80mr[38;5;110ml[38;5;195mS[38;5;255mh[38;5;232m]:[[38;5;60mT[38;5;232m][38;5;97m2[38;5;218m>[s[38;5;111m[u ";
    $PS1 = "$PROGNAME$VERSION{major},$VERSION{minor}r$VERSION{revision}> " if $NOCOLOR =~ /^(primary|both)$/;
    $PS2 = "   |\n   +-more-< " if $NOCOLOR =~ /^(secondary|both)$/;
}
setprompt;

sub ansilen { s/^[\[[0-9;]+m//; return length($_); }
sub nonprinting { my $count = shift; return ("[s" x ($count / 3)); }

# will not allow x in setcolumn(x) to be < 0 or > COLUMNS (use other one to bypass checking)
sub setcolumn
{
    my $loc = shift // 0;
    $loc = $loc > $COLUMNS ? $COLUMNS : ( $loc < 0 ? 0 : $loc );
    my $rv = `tput hpa $loc`;
    chomp $rv;
    return $rv;
}
sub rawsetcolumn { return `tput hpa ` . shift // "0"; } # does not check x like in setcolumn(x), not called by setcolumn (preserves individuality)

sub drawbox {
    return "" if $lastcmd_startcmd;                                                              # don't adorn or ornament during startup (its real ugly to do so)
    my $db_old_uscore = $_;                                                                      # preserve $_
    my $db_side = shift // "full";                                                               # very flexible syntax, see below
    my $db_content = shift // "";
    (say($db_content),return $db_old_uscore) if $NO_ADORNERS;                                    # allow it to be turned off (adorners only)
    return $db_old_uscore if $NO_ADORNERS_OR_CONTENT;                                            # allow it to be turned off (everything)
    my $db_draw="?";
    # â”â”“â”—â”›â”£â”«â”³â”»â•‹â•¸â”ƒâ”â”â”…â”‹
    given ($db_side)
    {                                                                                            # some paramaeters for drawbox(param1 that work well (* = currently defaults to)
        $db_draw="N" when /( t(op (most)? )? | [Nn](orth)? | u( p (p er )? )? )/x;               # t, top, N, north, North, upper, up, u, etc,
        $db_draw="S" when /( b(ot (tom)?  )? | [Ss](outh)? | l( o (w(er))? )? )/x;               # south, S, bot, b, bottom, etc,
        $db_draw="I" when /( m(id (dle)?  )? | h ( oriz ( (on)? tal)? )? -? ( rule r? )? )/x;    # horizon, horizontal h-rule, etc all work
        $db_draw="C" when /(side|content(s)?|in(side)?|(full|te?xt)(area)?)/x;                   # side, content, contents, inside, in, txtarea, text, textarea, *full, etc
    }
    $_=$db_draw;
    CORE::printf("â”" . ("â”" x ($LINES - 4)) . "â”“") if /N/;
    CORE::printf("â”—" . ("â”" x ($LINES - 4)) . "â”›") if /S/;
    CORE::printf("â”£" . ("â”" x ($LINES - 4)) . "â”«") if /I/;

    my $db_col = 4;                                                                             # <- align depending on position, these are placeholders to be filled out later
    $db_col = 8 if /S/;                                                                         # <- 4(top), 6(middle), 8(bottom)
    $db_col = 6 if /I/;                                                                         # <- this will come into play as the function is more fleshed out



    $db_content =~ s/\s/â”/g unless /C/;                                                          # we dont want a line when we are "in the box"
    CORE::print( setcolumn($db_col) . "$db_content\n") if length($db_content);                        # just sets the column hard to 4
    $_ = $db_old_uscore;                                                                         # restore $_ before returning
    return $_;                                                                                   # return $_ as value (in case needed on same line)
}

$PS2 = ("  ++   ");
$HISTFILE = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlsh_history";
$HISTSIZE = 256;
$INPUTRC = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlshrc";
$INNERRC = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlshirc";
$STRICT = 0;
$HOSTNAME = $ENV{HOSTNAME};
$LOGNAME = $ENV{LOGNAME};
$USERNAME = $ENV{USERNAME};
$USER = $ENV{USER};
$HOSTNAME = $ENV{HOSTNAME};
$UNAME = $ENV{UID};
$CWP = 'main';
@STARTUP_COMMANDS=( "CORE::say('test')" );
my $HOMEDIR=path($ENV{HOME} // "/tmp");
my $homeconf = $HOMEDIR->child(".perlsh_startuprc");
    if ($homeconf->exists()) {
        print("loading $homeconf ...");
        @STARTUP_COMMANDS= grep { /^[^#]*$/ } $homeconf->lines();       
        print("loaded " . @STARTUP_COMMANDS . " startup command(s)\n") if @STARTUP_COMMANDS;
    } else {
        print("$homeconf does not exist, no commands will be executed\n");
        # comment this line to test startup commands (the hard coded ones)
        # you will also need to rename any startup config file or make changes above to make
        # the test for the file return false
        @STARTUP_COMMANDS=( );
}
  
package main;

if (-f $PerlSh::INPUTRC) {
    do $PerlSh::INPUTRC;
}

if (-f $PerlSh::INNERRC ) {
    do $PerlSh::INNERRC;
}
package PerlSh;

sub hrule {

    printf  colored("%s\n",'grey1'), "=" x ($ENV{"COLUMNS"} //     DFCOLS);

}
sub vrule {
    while(1) {
        my $item1 = shift;
        my $item2 = shift // "";
        my $L = $ENV{'COLUMNS'} // DFCOLS;
        last unless defined($item1);
        printf("%${L}s | %${L}s", $item1, $item2)
    }
}

use vars qw($term $attribs);

$term = new Term::ReadLine 'PerlSh';
$term->ornaments("1,2,3,4");
$attribs = $term->Attribs;
$term->bind_key(ord "^", 'history-expand-line', 'emacs-meta');
$term->bind_key(ord "\cv", 'display-readline-version', 'emacs-ctlx');
$term->bind_key(ord "\cc", 'abort');

if (defined &main::afterinit) {
    package main;
    &afterinit;
    package PerlSh;
}

&toplevel;


my $lastcmd="";
sub length_ansi
{
    my @results = ( );
    push(@results,( length( colorstrip($_) ) )) for @_;
    return 0 if @results == 0;
    return @results if (@results > 1);
    return $results[0] if (@results == 1);
    return length($_) if length($_) > 0;
    die("bad value/no value passed (need >= 1 or default params \$_ set");

}

sub findinpath {
    my $filename = shift;
    unless ( -r "$filename" ) {
        for (split(':',$ENV{"PATH"} // "/:.")) {
            my $testfile = path($_)->child($filename);
            return $testfile if -r $testfile;
        }
    }
    return $filename
}
sub export {}

sub failbackto
{
    my $msg = shift // die("failback syntax error: none \$msg");
    my $val = shift // die("failback failed internally: none \$val");
    warn("failing back to $val for $msg");
    return $val;
}

sub toplevel
{
    $HOMEDIR = path($ENV{"HOME"} // cwd);
    printf("using system appointed home for user: %s\n", $HOMEDIR);
    die("cannot find a user-writable home directory ($HOMEDIR either isnt writable, or is an invalid value") unless -w $HOMEDIR;

    my $COLUMNS = $ENV{"COLUMNS"} // `tput cols` // failbackto( "terminal width/columns", DFCOLS);
    my $LINES = $ENV{"LINES"} // `tput lines` // failbackto("lines per screen/rows", DFLINES);
    chomp($COLUMNS);
    chomp($LINES);
    say "using ${COLUMNS}x${LINES} terminal";
    

    print("$PS1COLOR") if length($PS1COLOR) > 0;
    print("PS1 length zero, but color prompting disabled\n") unless ( length($PS1COLOR) | length($PS1) ) > 0;

    for (@STARTUP_COMMANDS) {
        chomp;
        if (/^(print|say)/) 
        {
            eval($_);
        } 
        else 
        {
            eval("package $CWP; $_;");
        }
    }
    $term->MinLine(undef);
    $term->stifle_history($HISTSIZE);
    if (-f $HISTFILE) {
        $term->ReadHistory($HISTFILE) or warn "perlsh: cannot read history file: $!\n";
    }
    $attribs->{attempted_completion_function} = \&attempt_perl_completion;
    $attribs->{special_prefixes} = '$@%&';
    $attribs->{completion_display_matches_hook}
    = \&perl_symbol_display_match_list;
    sigaction SIGINT, new POSIX::SigAction sub {
        $term->modifying;
        $term->delete_text;
        $attribs->{point} = $attribs->{end} = 0;
        $term->redisplay;
    } or die "[31;1mError setting SIGINT handler: $![0m\n";
    my ($strict, $command, @result);
    $strict = $STRICT ? '' : 'no strict;';
    while (defined($command = &reader)) {
    # TODO: move large blocks to own sub()routines
        given ($command) {
            # strip "my" or "our" from BOLs           
            when ( m/^(my|our)( .*)/ ) {
                say("info: removed preceeding our/my from prefix - would not have expected effect in sandbox mode.");
                $command = $2;
            }
        }
        given($command) {
            when ( m/^(perlsh\.)(\S+)(\s.+)?$/ ) {
                my $_pscmd = $2;
                my @_psargs = grep { /\S+/ } split(/\s/,$3 // "");
                given ($_pscmd) {
                    # built-in extra commands (start with perlsh.<cmd> <arg1> <..>
                    when (/color/)
                    {
                        if ( @_psargs == 1) {
                            given ($_psargs[0]) {
                                $NOCOLOR = $_psargs[0] when /^(both|none|primary|secondary)$/;
                                say("color mode $_psargs[0] is invalid\n");
                            }
                        } elsif (@_psargs > 1) {
                            say("way too many arguments, only accepts both,primary,secondary,none");
                        }
                        else
                        {
                            say("current color mode is: $NOCOLOR");
                        }

                    }

                    say ("invalid perlsh subcommand, $_pscmd, ignored (with " . @_psargs . " arguments)");      # default
                }
            }
            when ( m/^(\!)(.*)$/g )
            {
                sub statuscode { my $code = shift; given($code) { return "000_NOERROR" when 0;  return "127_USER_ERROR" when 127; return "001_FAILED" when 1; }; return sprintf("%03d",$code); }
                say "command $2 returned status code: " . statuscode(system("$2")) ;
            }
            when ( m/^$/g )
            {
                say("you are in the " . (length($CWP) > 0 ? $CWP : "root (topmost)") . " package, in pwd = " . cwd . "");
            }
            default
            {
                #### OUTPUT WINDOW (-ish)

                $lastcmd = $command;
                CORE::say(colored("evaluating '$lastcmd'","rgb022")) unless $lastcmd_startcmd;
                drawbox("N","output begin here");
                @result = eval ("$strict package $CWP; $command");
                unless ($lastcmd_startcmd)
                {
                    say("");
                    drawbox("S","end output area");
                    #CORE::printf(colored("\n^^---------------------------------^^\n","rgb044"));

                    use strict;
                    if ($@)
                    {
                        drawbox("I"," Error: $@\n__"); next;
                    }
                    else
                    {
                        my %result = @result;
                        my $sresult = join(",",@result);

                        given ($command)
                        {
                            # formatting directive: stop (col 33 freeze)

                                    #### HASH
                                    when (/^\s*%[^;]+\s*/ and ((@result) % 2) == 0 )
                                    {
                                        my $_btot=0;    # grand total bytes
                                        my $_ibtot=0;   # total item bytes
                                        my $_vbtot=0;   # total value bytes
                                        my $_ktot=0;    # key(s) handled
                                        my $_etot=0;    # empty key(s)
                                        sub elide 
                                        {
                                            sub warnval 
                                            { 
                                                warn("<undef given as number, defaulting to @_>"); return shift // 1; 
                                            }
                                            my $str = shift // "<invalid data>";
                                            my $siz = shift // warnval(8);
                                            my $eln=length($str);
                                            return $str if ($eln <= $siz);
                                            my $esz=int($siz/2)-2;
                                            my $rstr=substr($str,0,$esz) . "..." . substr($str,$eln-$esz);
                                            return $rstr;                            
                                        }
                                        printf "Hash Data ".chomp($command)."\n";
                                        my $kpart = int(($COLUMNS * 0.25) - PAD_LR);
                                        my $vpart = int(($COLUMNS * 0.75) - PAD_LR);
                                        my $fmtstr="%${kpart}s,%${vpart}s\n";
                                        printf $fmtstr,"Key","KIND(Address) or Value";
                                        for my $item (keys(%result)) 
                                        {
                                            my $value = $result{$item};
                                            my $vlen = length($value);
                                            my $ilen = length($item);
                                            $_btot+=$vlen + $ilen;
                                            $_vbtot+=$vlen;
                                            $_ktot+=1;  $_ibtot += $ilen;
                                            $_etot+=1 unless $vlen;
                                            printf $fmtstr, elide($item,$kpart), elide($result{$item},$vpart); 
                                        }
                                        printf("\n%d pair(s), %d key byte(s)\n%d data bytes, %d empty key(s)\n%d total bytes in structure.\n", $_ktot,$_ibtot,$_vbtot,$_etot,$_btot);
                                    }
                                    default 
                                    {
                                        given($command) 
                                        {
                                        ### GENERIC LIST                                            printer(@result) when /(=|;)/;
                                        print colored("\nlist data =>\n" . Dumper(@result), "rgb043") when /^(@|keys\(%)/;

                                        ### HASH [FALLBACK]
                                        print colored("\nhash data =>\n" . Dumper(%result), "rgb044") when /^%/;

                                        ### SCALAR
                                        print colored("\nscalar data\n value => \"@result\"", "rgb045") when /^\$/;

                                        ### PACKAGE
                                        when (/^\s*package\s+([\w:]+)/)
                                        {
                                            $CWP = $1;
                                            print colored("\npackage change: $CWP\n", "rgb064");
                                        }
                                        ### SYNOPSIS
                                        when (/^synopsis ([A-Za-z:_]*)$/)
                                        {
                                            say("");
                                            system($command);
                                        }
                                        ### XENOPHOBIC
                                        default
                                        {
                                            say("\ngeneric data\n");
                                            printer (@result);
                                        }
                                    } # default 
                                 print("\n");
                            } # given(command)
                        } # else (if ($@) )
                    } # unless $lastcmd_startcmd
                } # default (given(command)
            } #default (given(command))
        }
    }
    &quit;

}

sub sigint
{
    $term->modifying;
    $term->delete_text;
    $attribs->{point} = $attribs->{end} = 0;
    $term->redisplay;
}

sub quit
{
    $term->WriteHistory($HISTFILE) or warn "perlsh: cannot write history file: $!\n";
    exit (0);
}

sub reader
{

    ### STARTUP COMMANDS TO BE INTERPRETED AT (suprise) STARTUP
    ### these are executed as if user typed them, not the same as the environment rcfile!
    ### warning: if you place 'exit' in the startup commands it WILL terminate the program!

    my $has_startcmds = 0;
    my $startcmds = "";
    while ( @STARTUP_COMMANDS ) {
        #say("entering loop: startup-commands=@STARTUP_COMMANDS");
        $_ = pop(@STARTUP_COMMANDS);
        #say("item found: $_");
        $startcmds.=$_;
        $startcmds.=";" if @STARTUP_COMMANDS;  # add ';' only if more commands are to be added
        #say("start commands updated: $startcmds");

        $has_startcmds = 1;
    }
    if ($has_startcmds) {
        #say("has_startcmds=$has_startcmds: \"$startcmds\"");
        $lastcmd_startcmd = 1;
        return $startcmds if $has_startcmds;
    }
    else
    {
        $lastcmd_startcmd = 0;
    }
    ### END STARTUP COMMAND CHECK

    my ($line, $command);
    $command = '';
    select()->flush();

    while (1)
    {
        $term->ornaments("setaf,24,setaf,26");
        $line = $term->readline($command ? $PS2 : prompt($PS1));
        return undef unless (defined $line);
        if ($line =~ /\\$/)
        {
            chop $line;
            $command = $command ? $command . " $line" : $line;
        }
        else
        {
            $command = $command ? $command . " $line" : $line;
            $term->addhistory($command) if (length($command) > 0);
            return $command;
        }
    }
}

sub printer
{

    my $colpad = 2;
    my (@res) = @_;
    my ($i, $k, $v);
    my $x = 0;

    my $maxw = ( $ENV{"COLUMNS"} // DFCOLS ) - $colpad;
    my $maxil = $maxw / 4;
    my $maxvl = $maxw - $maxil;
    my ($il, $vl) = (0,$maxvl);
    if ( $lastcmd =~ /^%/ )
    {
        print colored("\"$lastcmd\" evaluated to a hash object (guessed from input)\n",'cyan');
        my %hres = @res;
        $il=0;
        my $kn="-key-";
        my $vn="-value-";
        foreach $k (keys(%hres))        {
            $il = length($hres{$k}) > $il ? length($hres{$k}) : $il;
        }
        $il=$maxil unless $il < $maxil;
        $il=int($il);
        $vl=int($vl);
        my $fmtstr = "%${il}.${il}s %-${vl}.${vl}s\n";
        print($fmtstr);
        printf(colored($fmtstr,'blue'),$kn,$vn);
        foreach $k (keys(%hres))
        {
            $v = $hres{$k};
               printf(colored($fmtstr,"rgb225"),$k,$v);
        }

    }
    else
    {
        if (@res == 1)
        {
            print("'$lastcmd' returned scalar value of '", $res[0], "'\n");
        }
        elsif (@res == undef)
        {
            print("'$lastcmd' evaluated to 'undef' (undefined value)\n");
        }
        else
        {
            print("'$lastcmd' evaluated to default 'list' context:\n");

            printf("%-${il}s %s\n","index","value");
            printf("%-${il}s %s\n","index","value");
            foreach $i (@res)
            {
                printf("%-${il}d %s\n",++$x,$i);
                $LASTRV=$i unless (int($i) == 0);
            }
        }
    }
    printf("$PS1COLOR") unless length($PS1COLOR) == 0;

}

sub prompt {
    local($_) = @_;
    return &$_ if (ref($_) eq 'CODE');
    s/\\h/$HOSTNAME/g;
    s/\\u/$LOGNAME/g;
    s/\\w/$CWP/g;
    s/\\v/$LASTRV/g;
    s/\\!/$attribs->{history_base} + $attribs->{history_length}/eg;
    $_;
}



sub perl_symbol_display_match_list ($$$)
{
    my($matches, $num_matches, $max_length) = @_;
    map { $_ =~ s/^((\$#|[\@\$%&])?).*::(.+)/$3/; }(@{$matches});
    $term->display_match_list($matches);
    $term->forced_update_display;
}

sub attempt_perl_completion ($$$$) {
    my ($text, $line, $start, $end) = @_;

    no strict qw(refs);
    if (substr($line, 0, $start) =~ m/\$([\w:]+)\s*(->)?\s*{\s*['"]?$/) {

    $attribs->{completion_append_character} = '}';
    return $term->completion_matches($text,
                     \&perl_hash_key_completion_function);
    } elsif (substr($line, 0, $start) =~ m/\$([\w:]+)\s*->\s*['"]?$/) {

    $attribs->{completion_append_character} = ' ';
    return $term->completion_matches($text,
                     \&perl_method_completion_function);
    } else {
    $attribs->{completion_append_character} = '';
    return  $term->completion_matches($text,
                      \&perl_symbol_completion_function);
    }
}


use vars qw($i @matches);

sub perl_hash_key_completion_function ($$)
{
    my($text, $state) = @_;

    if ($state) {
    $i++;
    } else {

    $i = 0;
    my ($var,$arrow) = (substr($attribs->{line_buffer},
                   0, $attribs->{point} - length($text))
                =~ m/\$([\w:]+)\s*(->)?\s*{\s*['"]?$/);
    no strict qw(refs);
    $var = "${CWP}::$var" unless ($var =~ m/::/);
    if ($arrow) {
        my $hashref = eval "\$$var";
        @matches = keys %$hashref;
    } else {
        @matches = keys %$var;
    }

    }
    for (; $i <= $#matches; $i++) {
    return $matches[$i] if ($matches[$i] =~ /^\Q$text/);
    }
    return undef;
}

sub _search_ISA ($) {
    my ($mypkg) = @_;
    no strict 'refs';
    no warnings 'prototype';
    my $isa = "${mypkg}::ISA";
    return $mypkg, map _search_ISA($_), @$isa;
}

sub perl_method_completion_function ($$) {
    my($text, $state) = @_;

    if ($state) {
    $i++;
    } else {

    my ($var, $pkg, $sym, $pk);
    $i = 0;
    $var = (substr($attribs->{line_buffer},
               0, $attribs->{point} - length($text))
        =~ m/\$([\w:]+)\s*->\s*$/)[0];
    $pkg = ref eval (($var =~ m/::/) ? "\$$var" : "\$${CWP}::$var");
    no strict qw(refs);
    @matches = map { $pk = $_ . '::';
             grep (/^\w+$/
                   && ($sym = "${pk}$_", defined *$sym{CODE}),
                   keys %$pk);
             } _search_ISA($pkg);
    }
    for (; $i <= $#matches; $i++) {
    return $matches[$i] if ($matches[$i] =~ /^\Q$text/);
    }
    return undef;
}




{
    my ($prefix, %type, @keyword);

    sub perl_symbol_completion_function ($$) {
    my($text, $state) = @_;

    if ($state) {
        $i++;
    } else {

        my ($pre, $pkg, $sym);
        $i = 0;

        no strict qw(refs);
        ($prefix, $pre, $pkg) = ($text =~ m/^((\$#|[\@\$%&])?(.*::)?)/);
        @matches = grep /::$/, $pkg ? keys %$pkg : keys %::;
        $pkg = ($CWP eq 'main' ? '::' : $CWP . '::') unless $pkg;

        if ($pre) {
        @matches = (@matches,
                grep (/^\w+$/
                  && ($sym = $pkg . $_,
                      defined *$sym{$type{$pre}}),
                  keys %$pkg));
        } else {
        @matches = (@matches,
                !$prefix && @keyword,
                grep (/^\w+$/
                  && ($sym = $pkg . $_,
                      defined *$sym{CODE}
                      || defined *$sym{FILEHANDLE}
                     ),
                  keys %$pkg));
        }
    }
    my $entry;
    for (; $i <= $#matches; $i++) {
        $entry = $prefix . $matches[$i];
        return $entry if ($entry =~ /^\Q$text/);
    }
    return undef;
    }

    BEGIN {
    %type = ('$' => 'SCALAR', '*' => 'SCALAR',
         '@' => 'ARRAY', '$#' => 'ARRAY',
         '%' => 'HASH',
         '&' => 'CODE');



    @keyword = qw(
            exit quit clear ls cd chmod chown start run

            chomp chop chr crypt hex index lc lcfirst
            length oct ord pack q qq
            reverse rindex sprintf substr tr uc ucfirst
            y

            m pos quotemeta s split study qr

            abs atan2 cos exp hex int log oct rand sin
            sqrt srand

            pop push shift splice unshift

            grep join map qw reverse sort unpack

            delete each exists keys values

            binmode close closedir dbmclose dbmopen die
            eof fileno flock format getc print printf
            read readdir rewinddir seek seekdir select
            syscall sysread sysseek syswrite tell telldir
            truncate warn write

            pack read syscall sysread syswrite unpack vec

            chdir chmod chown chroot fcntl glob ioctl
            link lstat mkdir open opendir readlink rename
            rmdir stat symlink umask unlink utime

            caller continue die do dump eval exit goto
            last next redo return sub wantarray

            caller import local my package use

            defined dump eval formline local my reset
            scalar undef wantarray

            alarm exec fork getpgrp getppid getpriority
            kill pipe qx setpgrp setpriority sleep
            system times wait waitpid

            do import no package require use

            bless dbmclose dbmopen package ref tie tied
            untie use

            accept bind connect getpeername getsockname
            getsockopt listen recv send setsockopt shutdown
            socket socketpair

            msgctl msgget msgrcv msgsnd semctl semget
            semop shmctl shmget shmread shmwrite

            endgrent endhostent endnetent endpwent getgrent
            getgrgid getgrnam getlogin getpwent getpwnam
            getpwuid setgrent setpwent

            endprotoent endservent gethostbyaddr
            gethostbyname gethostent getnetbyaddr
            getnetbyname getnetent getprotobyname
            getprotobynumber getprotoent getservbyname
            getservbyport getservent sethostent setnetent
            setprotoent setservent

            gmtime localtime time times

            abs bless chomp chr exists formline glob
            import lc lcfirst map my no prototype qx qw
            readline readpipe ref sub sysopen tie tied
            uc ucfirst untie use

            dbmclose dbmopen
           );
    }
}

__END__

=pod

Before invoking, this program reads F<~/.perlshrc> and evaluates the
content of the file.

When this program is terminated, the content of the history buffer is
saved in a file F<~/.perlsh_history>, and it is read at next
invoking.

=head1 VARIABLES

You can customize the behavior of C<perlsh> by setting following
variables in F<~/.perlshrc>;

=over 4

=item C<$PerlSh::PS1>

The primary prompt string.  The following backslash-escaped special
characters can be used.

    \h: host name
    \u: user name
    \w: package name
    \!: history number

The default value is `C<\w[\!]$ >'.

=item C<$PerlSh::PS2>

The secondary prompt string.  The default value is `C<E<gt> >'.

=item C<$PerlSh::HISTFILE>

The name of the file to which the command history is saved.  The
default value is C<~/.perlsh_history>.

=item C<$PerlSh::HISTSIZE>

If not C<undef>, this is the maximum number of commands to remember in
the history.  The default value is 256.

=item C<$PerlSh::STRICT>

If true, restrict unsafe constructs.  See C<use strict> in perl man
page.  The default value is 0;

=back

=head1 FILES

=over 4

=item F<~/.perlshrc>

This file is eval-ed at initialization.  If a subroutine C<afterinit>
is defined in this file, it will be eval-ed after initialization.
Here is a sample.



    sub h { map { sprintf("0x%x", $_ ) } @_;}

    sub tk {
        $t->tkRunning(1);
        use Tk;
        $mw = MainWindow->new();
    }


    sub afterinit {
        *t = \$PerlSh::term;
        *a = \$PerlSh::attribs;
    }

=item F<~/.perlsh_history>

=item F<~/.inputrc>

A initialization file for the GNU Readline Library.  Refer its manual
for details.

=back

=head1 SEE ALSO

L<Term::ReadLine::Gnu|http://search.cpan.org/dist/Term-ReadLine-Gnu/>

L<GNU Readline Library|http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html>

=head1 AUTHOR

Hiroo Hayashi <hiroo.hayashi@computer.org>

            Main Author of the original file.
            This file is a derivitive of his 'perlsh'.

=head1 CONTRIB

Gabriel T. Sharp <21shariria@gmail.com>

=over 4

=item C<Contributing Author (not fully in circulation)
            Stored in github/osirisgothra/mini.git under eso/ubin-local/perlsh
            (If there are further notes, they would be in README.md)
            Contributed startup code additions (@INC checking, colorization,
            Data::Dumper integration, Term::ANSIColor and Path::Tiny support)
            Also added some minor program flow plus extra commands/interpreters, etc.>

=back

=head1 CONTRIB NOTES

=over 4

=item CONTRIB-NOTE 9629 (approximate file position in characters)

=back

=begin text

        DEFERRED SIGNALS in perlipc(5):
            http://perldoc.perl.org/perlipc.html#Deferred-Signals-%28Safe-Signals%29

            The line referred by 9629 originally was:

                $SIG{INT} = sub { ... <rest of block>

            Changed to prevent crashes/noncleanups from SIGINT signals.

        These lines were changed to increase compatibility and bolster resilliance.

REFERENCES

        perlsh(1)  original version as mentioned above
        perlpod(1) required to read this document
        perldoc(1) preferred parser for this document
        man(1)     can be used as a generic reader for this document
        vim(1)
        nano(1)    these were all used to update or write the perlpod source
        atom(1)


PERLSH - perlsh(3pm) - Perl (Modified) Shell Reference - (Read this document with perlpod, perldoc, or man reader)


=end text




=cut
