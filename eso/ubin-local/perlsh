#!/usr/bin/perl
	#-editor settings----------------------------------------------------------------------------------
	# editor setup:
	# vi: fdm=indent:fen:fcl=all:fmr={,}:fdo=insert,find:bs=2:noet:ts=2:mls=2:noconfirm:cc=120:paste
	# nano: fmt=perl5
	# other editors are not supported (yet) to do anything but read the text
	#-end editor settings----- ------------------------------------------------------------------------
eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}' if 0; # prevent a shell from sourcing it (via 'source' or '.')
#	
#   High-Level Code: Copyright (c) 2019 Gabriel Sharp. All Rights Reserved.
#	Core-Level Code: Copyright (c) 2014 Hiroo Hayashi. All Rights Reserved.
#
#   Modifications/License
#
#	This program is free software; you can redistribute it and/or
#	modify it under the same terms as Perl itself.
#  
#   This program is modified heavily, but must adhere to the original author's
#   license terms for the author's code. The high-level code volunteeringly
#   also employs this same license terms in a 1:1 manner (entire program+data)
#
#   * stty required for terminal size requests, otherwise size from COLUMNS and LINES are used,
#     these may not be exported by most shells by default, so you must make sure they are. In
#     the case that stty is not available (ie, tiny installs) the default BIOS screen sizes
#     will be assumed (usually 80x24 is a safe size for such guesses). You could also change
#     the default manually below.
#
# 	ANNOTATION(S)
#
#		symbol name[type]	| short description (and/or *sectname for further notes)
#		====================+=========================================================================
#	 	ansilen <str>		| returns length of string in printable chars, excluding ansi escape (cc27+lbrace) sequences
#		PS1COLOR/PS2COLOR/	| colorized prompts declaration (autodetected by terminal)
#		PS1MONO/PS1MONO		| plain (no escapes, true UTF-8 encoded) text prompts
#							| *see note 'STYLE 1/2,PROMPTS'
#		NOCOLOR             | hard option to force readline prompting when ansi just
#							| does not work or causes problems with your system (on by 
#							| default)
#       ====================+================================================================================================================================================================================================================================================================================================================================================================================================================================================
# 
# EXTRA NOTATIONS
#
# 	STYLE 1/2,PROMPTS
#	There are two prompt styles, color or mono (monochrome, only silver/grey/black/white)
# 	for color, make sure PS1COLOR has your colorized prompt, when it does
#   PS1 is used to lie to readline about the prompt, this will resolve the 
#   issue of nonprinting characters being counted as one space
#   we do this by not passing a color string, just a bunch of 
#   save-cursor sequences since they dont ever write anything 
#   to the screen. For mono, make sure PS1COLOR is empty (but
#   not undefined!) so that ansilen returns zero (like ansilen(""))
#  set PS1MONO however you like, if its empty too, you will see a 
#  single warning when you run perlsh first-time w/o 'iff')
#

use v5.20.2;
use Path::Tiny;

my $debuginc=0;
if ($debuginc) {
	sub dprint { print(@_); }
} else {
	sub dprint { }
}

BEGIN { 
	my @NEWINC = ( );
	foreach (@INC) {
		my $src = path($_);
		my $real = $src->realpath();
		if ( $src eq $real ) {
			print("$src (real directory)\n");
		} else {
			print("$src (fake) -- will add $real due to $src's fakeness");
			unshift(@NEWINC,$real);
		}		
	}
	foreach (@NEWINC) {
		push(@INC,$_);
		print("$_ (real directory) added\n");

	}
}
print("\nresulting INCs:\n");
my $n=0; print($n++.": $_ \n") for @INC; 



package PerlSh;
use strict;
no warnings qw(all);
use Term::ReadLine;
use POSIX;			#  for sigaction below
use Term::ANSIColor;
use Path::Tiny;
use Cwd;
use Data::Dumper;
use IPC::Open3;
use constant { DFLINES => 24, DFCOLS => 80 };
use subs qw( say );
no warnings 'deprecated';
use vars qw($PS1 $PS2 $HISTFILE $HISTSIZE $INPUTRC $STRICT $INNERRC $PS1COLOR $PS1MONO $NOCOLOR
	    $HOSTNAME $LOGNAME $CWP $LASTRV $USER $UID $UNAME $USERNAME $homedir);

## COLOR/RGB TERMINAL SUPPORT ##

$NOCOLOR=1; 
$PS1 = '$ ';
$PS2 = 'more? '; # REDID FROM: PS2=[1;36mmore[38;5;250>[0m\n'; PS1=same

$PS1COLOR = "[38;5;232m[[38;5;21mP[38;5;25me[38;5;80mr[38;5;110ml[38;5;195mS[38;5;255mh[38;5;232m]:[[38;5;60mT[38;5;232m][38;5;97m2[38;5;218m>[s[38;5;111m[u ";
 $PS1MONO = "PerlSh II: ";

sub ansilen { s/^[\[[0-9;]+m//; return length($_); }
sub nonprinting { my $count = shift; return ("[s" x ($count / 3)); }

if ($NOCOLOR == 1) {
	$PS1 = $PS1MONO; # forced by hardwired setting (set by user)
	$PS1COLOR="";    # this tells prompters to not draw color prompt
} else {
	if (length($PS1COLOR) > 0) {
		$PS1 = "[s" x 5;
	} else {
		$PS1 = $PS1MONO;
	}
}

## END COLOR/TERM SUPPORT ###

$PS2 = ("  ++   ");
$HISTFILE = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlsh_history";
$HISTSIZE = 256;
$INPUTRC = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlshrc";
$INNERRC = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlshirc";
$STRICT = 0;
$HOSTNAME = $ENV{HOSTNAME};
$LOGNAME = $ENV{LOGNAME};
$USERNAME = $ENV{USERNAME};
$USER = $ENV{USER};
$HOSTNAME = $ENV{HOSTNAME};
$UNAME = $ENV{UID};
$CWP = 'main';			# current working package

package main;
if (-f $PerlSh::INPUTRC) {
    do $PerlSh::INPUTRC;
}

if (-f $PerlSh::INNERRC ) {
	do $PerlSh::INNERRC;
}
package PerlSh;

sub hrule {
	
    printf  colored("%s\n",'grey1'), "_" x ($ENV{"COLUMNS"} // 	DFCOLS);
 # colored('=' x $ENV{"COLUMNS"},'red') . "\n";
}
sub vrule {
	while(1) {
		my $item1 = shift;
		my $item2 = shift // "";
		my $L = $ENV{'COLUMNS'} // DFCOLS;
		last unless defined($item1);
		printf("%${L}s | %${L}s", $item1, $item2)
	}
}
# --------- CURRENT PROGRESS -- LAST LINE PROGRESS

use vars qw($term $attribs);	# to access as `$PerlSh::term' from prompt
$term = new Term::ReadLine 'PerlSh';
$term->ornaments("1,2,3,4");

$attribs = $term->Attribs;

$term->bind_key(ord "^", 'history-expand-line', 'emacs-meta');
$term->bind_key(ord "\cv", 'display-readline-version', 'emacs-ctlx');
$term->bind_key(ord "\cc", 'abort'); # not works yet FIXME!!!

if (defined &main::afterinit) {
    package main;
    &afterinit;
    package PerlSh;
}

&toplevel;			# never returns

########################################################################
my $lastcmd="";
sub length_ansi
{
	my @results = ( );
	push(@results,( length( colorstrip($_) ) )) for @_;
	return 0 if @results == 0;	# no elements, zero, scalar
	return @results if (@results > 1); # multiple elements (2 or more), list
	return $results[0] if (@results == 1); # single element, scalar
	return length($_) if length($_) > 0; # default param, single element, scalar
	die("bad value/no value passed (need >= 1 or default params \$_ set");
	
}

# findinpath(filename): trys to resolve if not a direct path (relative or absolute), try to get it from PATH or from the three places we know exist for sure: root, currentdir, parentdir (parent=root when we are root)
# returns filename untouched if failed, translated file in a path object if successful
sub findinpath {
	my $filename = shift;
	unless ( -r "$filename" ) {
		for (split(':',$ENV{"PATH"} // "/:.")) {
			my $testfile = path($_)->child($filename);
			return $testfile if -r $testfile;
		}
	}
	return $filename
}
sub export {}	# dummy function for resize usage
sub toplevel 
{
	# store home directory
	$homedir = path($ENV{"HOME"} // cwd);
	# check terminal sizes - these lines will cause both to become undef if one is
	my $COLUMNS = $ENV{"COLUMNS"} // ($ENV{"LINES"} = undef);
	my $LINES = $ENV{"LINES"} // ($ENV{"COLUMNS"} = undef);	
	unless (defined($COLUMNS))
	{	
		# prefer resize over stty (resize uses stty if needed anyway)
		# these are binary programs that cannot be run inline
		# they should be at least version 2.6.2 binaries
		if ( -x findinpath('resize') ) {
			# modern-day method of finding size on most nix based systems
			eval for grep { /COLUMNS|LINES/ && s/^/\$/g } qx(resize); 
		}
		elsif( -x findinpath('stty') ) {
			# works on older systems plus smaller systems with minimalistic terminal support
			($LINES, $COLUMNS) = split(/\s/, qx(stty size));
		}
		else {
			# no other methods, we want to refrain from specialized modules that arent always around
			# and also from directly using ansi sequences (this can cause race conditions or lockups
			# on older systems where ansi support was buggy).
			$ENV{"COLUMNS"} = DFCOLS;
			$ENV{"LINES"} = DFLINES;
			
		}	
	}
	else {
		say("using hard-coded terminal settings from LINES/COLUMNS ($LINES/$COLUMNS)");
	}
	say("COLUMNS too small, setting to default (".DFCOLS.")"),$COLUMNS=DFCOLS if ($COLUMNS < 8);
	say("LINES too small, setting to default (".DFLINES.")"),$LINES=DFLINES if ($LINES < 10);
	say "using ${COLUMNS}x${LINES} terminal";	
	print("$PS1COLOR") if length($PS1COLOR) > 0;
	print("PS1 length zero, but color prompting disabled\n") unless ( length($PS1COLOR) | length($PS1) ) > 0;
    # disable implicit add_history() call
    $term->MinLine(undef);
    $term->stifle_history($HISTSIZE);
    if (-f $HISTFILE) {
		$term->ReadHistory($HISTFILE) or warn "perlsh: cannot read history file: $!\n";
    }
    $attribs->{attempted_completion_function} = \&attempt_perl_completion;
    $attribs->{special_prefixes} = '$@%&';
    $attribs->{completion_display_matches_hook}
	= \&perl_symbol_display_match_list;

    # See http://perldoc.perl.org/perlipc.html#Deferred-Signals-%28Safe-Signals%29
    # was '$SIG{INT} = sub { ...'
    
	sigaction SIGINT, new POSIX::SigAction sub {
		$term->modifying;
		$term->delete_text;
		$attribs->{point} = $attribs->{end} = 0;
		$term->redisplay;
    } or die "[31;1mError setting SIGINT handler: $![0m\n";

    my ($strict, $command, @result);
    $strict = $STRICT ? '' : 'no strict;';
    
	while (defined($command = &reader)) 
	{
		if ( $command =~ m/^(\!)(.*)$/g )
		{	
			sub statuscode { my $code = shift; given($code) { return "000_NOERROR" when 0;  return "127_USER_ERROR" when 127; return "001_FAILED" when 1; }; return sprintf("%03d",$code); }
			say "command $2 returned status code: " . statuscode(system("$2")) ;
		}
		elsif ( $command eq "" )
		{	
		}
		else
		{
	    	$lastcmd = $command;
			hrule();
			CORE::say(colored("evaluating '$lastcmd'","rgb022"));		
    		hrule();
			@result = eval ("$strict package $CWP; $command");
			hrule();
			CORE::say(colored(@result . " result(s)\n", 'rgb024'));
			hrule();
			use strict;
			if ($@) { print colored("Error: $@\n","red"); next; }
			hrule;
			print colored("\nData Dump:\n\n" . Dumper(@result), "rgb034");
			hrule;
			printer (@result);
			$CWP = $1 if ($command =~ /^\s*package\s+([\w:]+)/);
			hrule;
		}
    }
    &quit;
    
}

sub sigint 
{
    $term->modifying;
    $term->delete_text;
    $attribs->{point} = $attribs->{end} = 0;
    $term->redisplay;
}

sub quit 
{
    $term->WriteHistory($HISTFILE) or warn "perlsh: cannot write history file: $!\n";
    exit (0);
}

sub reader 
{
    my ($line, $command);
    $command = '';
    select()->flush();
    
    while (1) 
	{
		$term->ornaments("setaf,4,setaf,6");
		$line = $term->readline($command ? $PS2 : prompt($PS1));
		return undef unless (defined $line);	
		if ($line =~ /\\$/) 
		{
	    	chop $line;
		    $command = $command ? $command . " $line" : $line;
		} 
		else 
		{
		    $command = $command ? $command . " $line" : $line;
		    $term->addhistory($command) if (length($command) > 0);
		    return $command;
		}
    }
}

sub printer 
{
	
	my $colpad = 2;		# number of spaces between [key/index](e)s and [value]s
    my (@res) = @_;     # result or results (argument passed)
    my ($i, $k, $v);	# [index, keyname], value (index is for ARRAYs, keyname is for HASHes)
    my $x = 0;			# running count for ARRAY data
    # ic: number of elements + pad   il: length of largest numeric index
	my $maxw = ( $ENV{"COLUMNS"} // DFCOLS ) - $colpad;
	my $maxil = $maxw / 4;
	my $maxvl = $maxw - $maxil;
	my ($il, $vl) = (0,$maxvl);
	if ( $lastcmd =~ /^%/ )
	{
		print colored("\"$lastcmd\" evaluated to a hash object (guessed from input)\n",'cyan');
		my %hres = @res;
		$il=0;
		my $kn="-key-";
		my $vn="-value-";
		foreach $k (keys(%hres))		{
			$il = length($hres{$k}) > $il ? length($hres{$k}) : $il;
		}	
		$il=$maxil unless $il < $maxil;
		$il=int($il);
		$vl=int($vl);
		my $fmtstr = "%${il}.${il}s %-${vl}.${vl}s\n";
		print($fmtstr);
	    printf(colored($fmtstr,'blue'),$kn,$vn);
		foreach $k (keys(%hres)) 
		{
			$v = $hres{$k};
		   	printf(colored($fmtstr,"rgb225"),$k,$v); # "[$x] [$i]"
		}
			
	}
	else
	{
		if (@res == 1)
		{
			print("'$lastcmd' returned scalar value of '", $res[0], "'\n");
		}
		elsif (@res == undef)
		{
			print("'$lastcmd' evaluated to 'undef' (undefined value)\n");
		}
		else
		{
			print("'$lastcmd' evaluated to default 'list' context:\n");
			
	    	printf("%-${il}s %s\n","index","value");
	    	printf("%-${il}s %s\n","index","value");
    		foreach $i (@res) 
    		{ 
	    		printf("%-${il}d %s\n",++$x,$i); # "[$x] [$i]"
    			$LASTRV=$i unless (int($i) == 0);    	
	    	}
		}
    }    
	printf("$PS1COLOR") unless length($PS1COLOR) == 0;
   
}

sub prompt {
    local($_) = @_;
    # if reference to a subroutine return the return value of it
    return &$_ if (ref($_) eq 'CODE');

    # \h: hostname, \u: username, \w: package name, \!: history number
    s/\\h/$HOSTNAME/g;
    s/\\u/$LOGNAME/g;
    s/\\w/$CWP/g;
    s/\\v/$LASTRV/g;
    s/\\!/$attribs->{history_base} + $attribs->{history_length}/eg;
    $_;
}

#
#	custom completion for Perl
#

sub perl_symbol_display_match_list ($$$) 
{
    my($matches, $num_matches, $max_length) = @_;
    map { $_ =~ s/^((\$#|[\@\$%&])?).*::(.+)/$3/; }(@{$matches});
    $term->display_match_list($matches);
    $term->forced_update_display;
}

sub attempt_perl_completion ($$$$) {
    my ($text, $line, $start, $end) = @_;
    
    no strict qw(refs);
    if (substr($line, 0, $start) =~ m/\$([\w:]+)\s*(->)?\s*{\s*['"]?$/) {
	# $foo{key, $foo->{key
	$attribs->{completion_append_character} = '}';
	return $term->completion_matches($text,
					 \&perl_hash_key_completion_function);
    } elsif (substr($line, 0, $start) =~ m/\$([\w:]+)\s*->\s*['"]?$/) {
	# $foo->method
	$attribs->{completion_append_character} = ' ';
	return $term->completion_matches($text,
					 \&perl_method_completion_function);
    } else { # Perl symbol completion
	$attribs->{completion_append_character} = '';
	return  $term->completion_matches($text,
					  \&perl_symbol_completion_function);
    }
}

# static global variables for completion functions
use vars qw($i @matches);

sub perl_hash_key_completion_function ($$) 
{
    my($text, $state) = @_;
    
    if ($state) {
	$i++;
    } else {
	# the first call
	$i = 0;			# clear index
	my ($var,$arrow) = (substr($attribs->{line_buffer},
				   0, $attribs->{point} - length($text))
			    =~ m/\$([\w:]+)\s*(->)?\s*{\s*['"]?$/); # });
	no strict qw(refs);
	$var = "${CWP}::$var" unless ($var =~ m/::/);
	if ($arrow) {
	    my $hashref = eval "\$$var";
	    @matches = keys %$hashref;
	} else {
	    @matches = keys %$var;
	}
	
    }
    for (; $i <= $#matches; $i++) {
	return $matches[$i] if ($matches[$i] =~ /^\Q$text/);
    }
    return undef;
}

sub _search_ISA ($) {
    my ($mypkg) = @_;
    no strict 'refs';
    no warnings 'prototype';
    my $isa = "${mypkg}::ISA";
    return $mypkg, map _search_ISA($_), @$isa;
}

sub perl_method_completion_function ($$) {
    my($text, $state) = @_;
    
    if ($state) {
	$i++;
    } else {
	# the first call
	my ($var, $pkg, $sym, $pk);
	$i = 0;			# clear index
	$var = (substr($attribs->{line_buffer},
		       0, $attribs->{point} - length($text))
		=~ m/\$([\w:]+)\s*->\s*$/)[0];
	$pkg = ref eval (($var =~ m/::/) ? "\$$var" : "\$${CWP}::$var");
	no strict qw(refs);
	@matches = map { $pk = $_ . '::';
			 grep (/^\w+$/
			       && ($sym = "${pk}$_", defined *$sym{CODE}),
			       keys %$pk);
		     } _search_ISA($pkg);
    }
    for (; $i <= $#matches; $i++) {
	return $matches[$i] if ($matches[$i] =~ /^\Q$text/);
    }
    return undef;
}

#
#	Perl symbol name completion
#
{
    my ($prefix, %type, @keyword);

    sub perl_symbol_completion_function ($$) {
	my($text, $state) = @_;

	if ($state) {
	    $i++;
	} else {
	    # the first call
	    my ($pre, $pkg, $sym);
	    $i = 0;		# clear index

	    no strict qw(refs);
	    ($prefix, $pre, $pkg) = ($text =~ m/^((\$#|[\@\$%&])?(.*::)?)/);
	    @matches = grep /::$/, $pkg ? keys %$pkg : keys %::;
	    $pkg = ($CWP eq 'main' ? '::' : $CWP . '::') unless $pkg;

	    if ($pre) {		# $foo, @foo, $#foo, %foo, &foo
		@matches = (@matches,
			    grep (/^\w+$/
				  && ($sym = $pkg . $_,
				      defined *$sym{$type{$pre}}),
				  keys %$pkg));
	    } else {		# foo
		@matches = (@matches,
			    !$prefix && @keyword,
			    grep (/^\w+$/
				  && ($sym = $pkg . $_,
				      defined *$sym{CODE}
				      || defined *$sym{FILEHANDLE}
				     ),
				  keys %$pkg));
	    }
	}
	my $entry;
	for (; $i <= $#matches; $i++) {
	    $entry = $prefix . $matches[$i];
	    return $entry if ($entry =~ /^\Q$text/);
	}
	return undef;
    }

    BEGIN {
	%type = ('$' => 'SCALAR', '*' => 'SCALAR',
		 '@' => 'ARRAY', '$#' => 'ARRAY',
		 '%' => 'HASH',
		 '&' => 'CODE'); # '

	# from perl5.004_02 perlfunc
	@keyword = qw(
		    chomp chop chr crypt hex index lc lcfirst
		    length oct ord pack q qq
		    reverse rindex sprintf substr tr uc ucfirst
		    y
		    
		    m pos quotemeta s split study qr

		    abs atan2 cos exp hex int log oct rand sin
		    sqrt srand

		    pop push shift splice unshift

		    grep join map qw reverse sort unpack
		    
		    delete each exists keys values
		    
		    binmode close closedir dbmclose dbmopen die
		    eof fileno flock format getc print printf
		    read readdir rewinddir seek seekdir select
		    syscall sysread sysseek syswrite tell telldir
		    truncate warn write
		    
		    pack read syscall sysread syswrite unpack vec
		    
		    chdir chmod chown chroot fcntl glob ioctl
		    link lstat mkdir open opendir readlink rename
		    rmdir stat symlink umask unlink utime
		    
		    caller continue die do dump eval exit goto
		    last next redo return sub wantarray
		    
		    caller import local my package use
		    
		    defined dump eval formline local my reset
		    scalar undef wantarray
		    
		    alarm exec fork getpgrp getppid getpriority
		    kill pipe qx setpgrp setpriority sleep
		    system times wait waitpid
		    
		    do import no package require use
		    
		    bless dbmclose dbmopen package ref tie tied
		    untie use
		    
		    accept bind connect getpeername getsockname
		    getsockopt listen recv send setsockopt shutdown
		    socket socketpair
		    
		    msgctl msgget msgrcv msgsnd semctl semget
		    semop shmctl shmget shmread shmwrite
		    
		    endgrent endhostent endnetent endpwent getgrent
		    getgrgid getgrnam getlogin getpwent getpwnam
		    getpwuid setgrent setpwent
		    
		    endprotoent endservent gethostbyaddr
		    gethostbyname gethostent getnetbyaddr
		    getnetbyname getnetent getprotobyname
		    getprotobynumber getprotoent getservbyname
		    getservbyport getservent sethostent setnetent
		    setprotoent setservent
		    
		    gmtime localtime time times
		    
		    abs bless chomp chr exists formline glob
		    import lc lcfirst map my no prototype qx qw
		    readline readpipe ref sub sysopen tie tied
		    uc ucfirst untie use
		    
		    dbmclose dbmopen
		   );
    }
}

__END__

=pod

Before invoking, this program reads F<~/.perlshrc> and evaluates the
content of the file.

When this program is terminated, the content of the history buffer is
saved in a file F<~/.perlsh_history>, and it is read at next
invoking.

=head1 VARIABLES

You can customize the behavior of C<perlsh> by setting following
variables in F<~/.perlshrc>;

=over 4

=item C<$PerlSh::PS1>

The primary prompt string.  The following backslash-escaped special
characters can be used.

	\h: host name
	\u: user name
	\w: package name
	\!: history number

The default value is `C<\w[\!]$ >'.

=item C<$PerlSh::PS2>

The secondary prompt string.  The default value is `C<E<gt> >'.

=item C<$PerlSh::HISTFILE>

The name of the file to which the command history is saved.  The
default value is C<~/.perlsh_history>.

=item C<$PerlSh::HISTSIZE>

If not C<undef>, this is the maximum number of commands to remember in
the history.  The default value is 256.

=item C<$PerlSh::STRICT>

If true, restrict unsafe constructs.  See C<use strict> in perl man
page.  The default value is 0;

=back

=head1 FILES

=over 4

=item F<~/.perlshrc>

This file is eval-ed at initialization.  If a subroutine C<afterinit>
is defined in this file, it will be eval-ed after initialization.
Here is a sample.

	# -*- mode: perl -*-
	# decimal to hexa
	sub h { map { sprintf("0x%x", $_ ) } @_;}

	sub tk {
	    $t->tkRunning(1);
	    use Tk;
	    $mw = MainWindow->new();
	}

	# for debugging Term::ReadLine::Gnu
	sub afterinit {
	    *t = \$PerlSh::term;
	    *a = \$PerlSh::attribs;
	}

=item F<~/.perlsh_history>

=item F<~/.inputrc>

A initialization file for the GNU Readline Library.  Refer its manual
for details.

=back

=head1 SEE ALSO

L<Term::ReadLine::Gnu|http://search.cpan.org/dist/Term-ReadLine-Gnu/>

L<GNU Readline Library|http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html>

=head1 AUTHOR

Hiroo Hayashi <hiroo.hayashi@computer.org>

=cut
