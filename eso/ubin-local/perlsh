#!/usr/bin/env perl
eval 'exec /usr/bin/env perl -S $0 ${1+"$@"}' unless 1;

#
#   Originally Written By & Copyright (c) 2014 Hiroo Hayashi. All Rights Reserved.
#   PLEASE SEE ORIGINAL LICENSE FOR DETAILS ON USAGE RIGHTS
#
use Time::HiRes;
my $start_time = Time::HiRes::gettimeofday();

package PerlSh;
use v5.20.2;
use utf8;
use Encode;         
use Path::Tiny;
use Cwd;
use strict;
use Term::ReadLine;
use Term::Put;
use POSIX;
use Path::Tiny;
use Data::Dumper;
use IPC::Open3;

# Constants

use constant { DFLINES => 24, DFCOLS => 80 };
use constant { PAD_L=>1, PAD_R=>1 };
use constant { PAD_LR=>PAD_L+PAD_R };

# Predeclared Subs

use subs qw( say );

# Predeclared Variables (please add newest entries to beginning fno)

use vars qw($noecho $PS1 $PS2 $HISTFILE $HISTSIZE $INPUTRC $STRICT $INNERRC $PS1COLOR $NO_ADORNERS $NO_ADORNERS_OR_CONTENT
            $PS1MONO $NOCOLOR %VERSION $LINES $COLUMNS $HOSTNAME $LOGNAME $CWP $thispid
            $LASTRV $USER $UID $UNAME $USERNAME $HOMEDIR $PROGPATH $PROGNAME $AUTOCOLOR @STARTUP_COMMANDS $lastcmd_startcmd $add_to_hist $usehist $forked $hasforked );

# Features

use feature "signatures";                                                                # TODO: convert sigil subs to signature subs

no warnings 'deprecated';
no warnings qw(all);                                                                      # testing only

# defaults

my $editor = path( ( -x "/usr/bin/editor" ) ? "/usr/bin/editor" : "/bin/nano" )->_resolve_symlinks();


warn("editor '$editor' was not found -- external edit functions will be disabled") unless $editor->exists();

# debug of certain things set to 0 to prevent message for a particular thing:
# note: not all these are used all the time and may be added/removed at any time
#       devs: try to stick with these if you need a new value, follow simmilar conventions
#             for naming them:

my $debug_find = 0;
my $debug_general = 0;
my $debug_startup = 0;
my $debug_sig = 0;
my $term = new Term::Put();

#

$NO_ADORNERS=0;                 # disables box adorners, just prints any contentual text
$NO_ADORNERS_OR_CONTENT=0;      # removes adorners and also any contentual text
$PROGNAME="PerlSh";
$PROGPATH=path($0);
$AUTOCOLOR=0;       # <1|0>
$NOCOLOR="both";    # <primary|secondary|both|none>
%VERSION=( major => 2, minor => 4, revision => 1 );


# Tip Of the Day Entries (TODEs)

my @tode = (       "You can use perlsh to do stuff, lots of stuff, and even things.",
                "You can change the prompt by modifying \$PS1",
                "You can ! to run external commands (like !ls)",
                "You can view some details just by using ENTER on a blank line.",
                "You can restart (and reload the source code) by using the restart command \"restart\".",
                "You can get perlhelp via perldoc, from within perlsh using the ? prefix.",
                "The ?& prefix is used to look up help on functions only.",
                'The ?$ prefix is used to look up variable help.',
                'The ?? or ?~ prefix is used to query the perldoc FAQ',
                'You can just type the variable name to get a custom dump of the variable',
                'You can use the use statements to load more packages, and some are loaded at startup too',
                'You can use ~/.perlsh_startup to load packages and other stuff that you dont want to redo each time you use perlsh',
                'You can get the latest version of perlsh form its original author, but it wont have these extras, for that you need to go to the perlsh fork page, github.com/osirisgothra/mini and find the stand-alone perlsh file!',
                'You can edit this source like I did to make it have more features, and to even add more tips (or get rid or turn them off completely!)',
                'There are several special modules embedded in Perl::Sh that you can use from within the interpreter. These modules are internal and arent used in general for programming',
                'Color prompts are disabled in the code, but can be re-enabled (because they can be incompatible with some terminals, which is a contraversial bug in Term::ReadLine::Gnu)',
          );
          # TODO: add more todes

my $banner = '
   PerlSh Enhanced
   (c)2019-20 Gabriel T. Sharp <21shariria@gmail.com>
   (c)2014-20 Base Perl::Sh Designed By Hiroo Hayashi

    NEW CODE LICENSED AS GNU GPL VERSION 3 <https://www.gnu.org/gpl3>
    PLEASE SEE ORIGINAL LICENSE FOR DETAILS ON USAGE RIGHTS
';
$usehist = 1;

say $banner;

sub get_runtime()
{
 my $stop_time = Time::HiRes::gettimeofday();
 return sprintf("%.2f\n", $stop_time - $start_time);
}

sub get_totd() {

    my $totds = @tode // 0;
    my $randomtip = int(rand()*$totds);
    return "There are no tips currently configured (uncomment or insert tips as instructed by the INSTALL to show them" if $totds == 0;
    return "\tDid you know?\n\t\t" . $tode[$randomtip];
}
sub setprompt() {

    $PS1 = "perlsh>";
    $PS2 = ">>> ";
}
sub expandpromptstring($str)
{
    my $PKGNAME = length($CWP) > 0 ? $CWP : "main";
    my $WD = Cwd();
    #my $HIST = $NUMHIST > 0 ? $NUMHIST : "(empty)";
    #my $SEC = $SECONDS_SINCE_RUN;

    local $_;
    $_  = $str;   # important, make sure $_ is localized so we dont mess with the caller's or "global" $_, whichever might be active
    # expansions to be done on $_ are local, and we MUST NOT modify $str !!!

    s/^pkg/$PKGNAME/g;
    # s/^hist/$HIST/g;
    s/^wd/$WD/g;
    # s/^sec/$SEC/g;



}
sub zmdec($in)
{
    if ($in == -1 || $in == 0) {
        return $in;
    } else {
        return $in - 1;
    }
}
sub findexec($name) 
{ 
    return (findexecs($name))[0] // undef; 
}
sub findexecs($name) 
{
    my @found = findfiles("(?<=\/)$name\$",$ENV{PATH},1);           # see section: CONTRIB perldoc (in pod view)
    if (@found) {
        return @found;
    } else {
        return ();
    }
}
sub findfiles($mask, $path=$ENV{PATH}, $maxdepth=-1, $mindepth=-1)
{
    my @results = ();
    return @results if $maxdepth == 0;
    for (split(":",$path))
    {
        chomp($_);
        if ( -r -d $_ )         {
        print("scanning $_ for [$mask]\n") if $debug_find;   # debug only
            my $curpath = path($_)->realpath();
            my @items = grep { /$mask/ } $curpath->children();
            for my $i (@items) {
                print("found $i ok\n") if $debug_find;
                push(@results, $i);
            }
        print("nothing in $_\n") unless @items or (not $debug_find);# debug only
        }
    }
    return @results;


}
sub perlhelp($context, $section="N")    # N=all
{
    my $pd = findexec("perldoc");
    if ( -r $context ) {
        my $manpath=findexec("man") // warn("couldnt find man!!!");
        system($manpath,$context) or warn("tried to manify $context but couldnt, sorry: $! $?\n");
        return;
    }
    $_ = $section // "";
    say("called with section=[$section] context=[$context]");
    $_ = "N" unless /\A(\$|&|~|\?|N|F)\z/;
    my @flags = ();
    sub ctx($item) { my $oldus=$_; my $res=""; given($item) {
        $res="function" when /-f/;
        $res="variable" when /-v/;
        $res="frequently asked question (FAQ) keyword" when /-q/;
        $res="linux man(ual) page" when /man/;
        $res="regular plain old document (POD) file" when /""/;
        $res="unknown thingy";}
        $_ = $oldus; return $res;   
    }

    given($_) {
        @flags = qw( -f -v -q "" man ) when /[NF]/; # NOTE: be sure not to use quotes when adding new items to this list!! (it is LITERAL)
        @flags = qw( -f ) when /&/;
        @flags = qw( -v ) when /\$/;
        @flags = qw( -q ) when /[~\?]/;
        @flags = qw( "" ) when /n/;
        default { @flags = (); }
    }
    my $stopatfirst = $section eq "F" ? 1 : 0;
    say("found $pd, using it with pfx=" . join(",",@flags) . " and ctx=[$context]");

    unless (-x $pd ) {
        say "fatal, cannot find perldoc" ;
        return "";
    }
    else
    {
        for my $flag ( @flags ) {
            printf("checking to see if %s is %s\n",$context,ctx($flag));
            if ($flag eq "man")
            {
                printf("about to use man on $context\n");
                system("/bin/man",$context);
            }
            elsif  ($flag ne '""' )
            {  system($pd,$flag,$context);  }
            else
            {  system($pd,$context); }          # <- handles "" flag (usually a pod name)

            if ( $? == 0 )
            {
                say("stopping after first found document") if $stopatfirst;
                return if $stopatfirst;
            }
        }
    }


}



# will not allow x in setcolumn(x) to be < 0 or > COLUMNS (use other one to bypass checking)
sub setcolumn
{
    my $COLUMNS = $term->cols;
    my $loc = shift // 0;
    $loc = $loc > $COLUMNS ? $COLUMNS : ( $loc < 0 ? 0 : $loc );
    my $rv = `tput hpa $loc`;
    chomp $rv;
    return $rv;
}
sub rawsetcolumn { return `tput hpa ` . shift // "0"; } # does not check x like in setcolumn(x), not called by setcolumn (preserves individuality)

sub drawbox {

    return "" if $lastcmd_startcmd;                                                              # don't adorn or ornament during startup (its real ugly to do so)
    my $COLUMNS = $term->cols;
    my $LINES = $term->lines;

    my $db_old_uscore = $_;                                                                      # preserve $_
    my $db_side = shift // "full";                                                               # very flexible syntax, see below
    my $db_content = shift // "";
    (say($db_content),return $db_old_uscore) if $NO_ADORNERS;                                    # allow it to be turned off (adorners only)
    return $db_old_uscore if $NO_ADORNERS_OR_CONTENT;                                            # allow it to be turned off (everything)
    my $db_draw="?";
    # ‚îè‚îì‚îó‚îõ‚î£‚î´‚î≥‚îª‚ïã‚ï∏‚îÉ‚îÅ‚îÅ‚îÖ‚îã
    given ($db_side)
    {                                                                                            # some paramaeters for drawbox(param1 that work well (* = currently defaults to)
        $db_draw="N" when /( t(op (most)? )? | [Nn](orth)? | u( p (p er )? )? )/x;               # t, top, N, north, North, upper, up, u, etc,
        $db_draw="S" when /( b(ot (tom)?  )? | [Ss](outh)? | l( o (w(er))? )? )/x;               # south, S, bot, b, bottom, etc,
        $db_draw="I" when /( m(id (dle)?  )? | h ( oriz ( (on)? tal)? )? -? ( rule r? )? )/x;    # horizon, horizontal h-rule, etc all work
        $db_draw="C" when /(side|content(s)?|in(side)?|(full|te?xt)(area)?)/x;                   # side, content, contents, inside, in, txtarea, text, textarea, *full, etc
    }
    $_=$db_draw;
    CORE::printf("‚îè" . ("‚îÅ" x ($LINES - 4)) . "‚îì") if /N/;
    CORE::printf("‚îó" . ("‚îÅ" x ($LINES - 4)) . "‚îõ") if /S/;
    CORE::printf("‚î£" . ("‚îÅ" x ($LINES - 4)) . "‚î´") if /I/;

    my $db_col = 4;                                                                             # <- align depending on position, these are placeholders to be filled out later
    $db_col = 8 if /S/;                                                                         # <- 4(top), 6(middle), 8(bottom)
    $db_col = 6 if /I/;                                                                         # <- this will come into play as the function is more fleshed out



    $db_content =~ s/\s/‚îÅ/g unless /C/;                                                          # we dont want a line when we are "in the box"
    CORE::print( setcolumn($db_col) . "$db_content\n") if length($db_content);                        # just sets the column hard to 4
    $_ = $db_old_uscore;                                                                         # restore $_ before returning
    return $_;                                                                                   # return $_ as value (in case needed on same line)
}

$PS2 = ("  ++   ");
$HISTFILE = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlsh_history";
$HISTSIZE = 256;
$INPUTRC = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlshrc";
$INNERRC = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlshirc";
$STRICT = 0;
$HOSTNAME = $ENV{HOSTNAME};
$LOGNAME = $ENV{LOGNAME};
$USERNAME = $ENV{USERNAME};
$USER = $ENV{USER};
$HOSTNAME = $ENV{HOSTNAME};
$UNAME = $ENV{UID};
$CWP = 'main';
@STARTUP_COMMANDS=( "CORE::say('test')" );
my $HOMEDIR=path($ENV{HOME} // "/tmp");
my $homeconf = $HOMEDIR->child(".perlsh_startuprc");
    if ($homeconf->exists()) {
        print("loading $homeconf ...");
        @STARTUP_COMMANDS= grep { /^[^#]*$/ } $homeconf->lines();
        print("loaded " . @STARTUP_COMMANDS . " startup command(s)\n") if @STARTUP_COMMANDS;
    } else {
        print("$homeconf does not exist, no commands will be executed\n");
        # comment this line to test startup commands (the hard coded ones)
        # you will also need to rename any startup config file or make changes above to make
        # the test for the file return false
        @STARTUP_COMMANDS=( );
}

package main;

if (-f $PerlSh::INPUTRC) {
    do $PerlSh::INPUTRC;
}

if (-f $PerlSh::INNERRC ) {
    do $PerlSh::INNERRC;
}
package PerlSh;

sub hrule {

   $term->printf("~8%s~7\n", "=" x $term->cols // DFCOLS);

}
sub vrule {
    while(1) {
        my $item1 = shift;
        my $item2 = shift // "";
        my $L = $ENV{'COLUMNS'} // DFCOLS;
        last unless defined($item1);
        printf("%${L}s | %${L}s", $item1, $item2)
    }
}

use vars qw($linereader $attribs $term);

$linereader = new Term::ReadLine 'PerlSh';
$linereader->ornaments("1,2,3,4");
$attribs = $linereader->Attribs;
$linereader->bind_key(ord "^", 'history-expand-line', 'emacs-meta');
$linereader->bind_key(ord "\cv", 'display-readline-version', 'emacs-ctlx');
$linereader->bind_key(ord "\cc", 'abort');

if (defined &main::afterinit) {
    package main;
    &afterinit;
    package PerlSh;
}

&toplevel;
my $lastcmd="";

sub findinpath {
    my $filename = shift;
    unless ( -r "$filename" ) {
        for (split(':',$ENV{"PATH"} // "/:.")) {
            my $testfile = path($_)->child($filename);
            return $testfile if -r $testfile;
        }
    }
    return $filename
}
sub export {}

sub failbackto
{
    my $msg = shift // die("failback syntax error: none \$msg");
    my $val = shift // die("failback failed internally: none \$val");
    warn("failing back to $val for $msg");
    return $val;
}

sub toplevel()          #9TC
{
    my $logfile = "/tmp/perlsh-bgload";

    #####THREAD 1 #####################
    setprompt;   
    $HOMEDIR = path($ENV{"HOME"} // cwd);
    printf("using system appointed home for user: %s\n", $HOMEDIR);
    die("cannot find a user-writable home directory ($HOMEDIR either isnt writable, or is an invalid value") unless -w $HOMEDIR;
    my $COLUMNS = $term->cols;
    my $LINES = $term->lines;
    say "using ${COLUMNS}x${LINES} terminal";
    print("$PS1COLOR") if length($PS1COLOR) > 0;
    print("PS1 length zero, but color prompting disabled\n") unless ( length($PS1COLOR) | length($PS1) ) > 0;
    hrule;
    printf GREEN "";
    my $totd = get_totd;
    printf "$totd\n";
    hrule;
    $linereader->MinLine(undef);
    $linereader->stifle_history($HISTSIZE);
    if (-f $HISTFILE) { $linereader->ReadHistory($HISTFILE) or warn "perlsh: cannot read history file: $!\n"; }
    $attribs->{attempted_completion_function} = \&attempt_perl_completion;
    $attribs->{special_prefixes} = '$@%&';
    $attribs->{completion_display_matches_hook} = \&perl_symbol_display_match_list;
    sigaction SIGINT, new POSIX::SigAction sub {
        $linereader->modifying;
        $linereader->delete_text;
        $attribs->{point} = $attribs->{end} = 0;
        $linereader->redisplay;
    } or die "[31;1mError setting SIGINT handler: $![0m\n";
    my ($strict, $command, @result);
    $strict = $STRICT ? '' : 'no strict;';
    $term->put("sgr0");

    
    
    my $forkpid = fork();
    unless ($forkpid) {
    ####THREAD 2 ####################################################################
        STDOUT->autoflush(1);
        printf("[s[1;1H[0;33;1;41mdoing startup commands[K[0m[1;1H[u");
        printf("[u [u");
#        printf(prompt($PS1));        #10
        path($logfile)->touch();
        sleep(1);

        select $logfile;
        for my $startup_command (@STARTUP_COMMANDS) {
            handle_command($startup_command,$strict,1);
        }
        select STDOUT;
        printf("[s[1;1H[0;33;1;42mstartup commands loaded (type scout to see its output, if any)[K[0m\n[u");
        sleep(3);
        printf("[s[1;1H[0m[K[u");
#        printf(prompt($PS1));
        STDOUT->autoflush(0);
        exit();
    #### THREAD2 EXIT ###############################################################
    }
    
    
    
    while (defined($command = &reader)) {
        handle_command($command,$strict,$noecho);
    }         
    &quit;
    #####THREAD1 RETURN#################

}
sub handle_command($command,$strict,$silent)    #9MT
{
    my $logfile = path("/tmp/perlsh-bgload");

    given ($command) {
        when ( m/^\s*(my|our)( .*)/ ) {
            say("info: removed preceeding our/my from prefix - would not have expected effect in sandbox mode.");
            $command = $2;
        }
        
    }
    given($command) {
        when ( /^scout$/ ) {
            say ("\n".$logfile->slurp()."\n");            
        }
        when ( m/^[\$\&\%][_A-Za-z][_A-Za-z0-9]*$/ )
        {                
            eval ("$strict package $CWP; my \$d=Data::Dumper::Dumper(\\$command); \$d =~ s/VAR1/$command/g;say(\$d); " );
        }                        
        when ( m/^(perlsh\.)(\S+)(\s.+)?$/ ) {
            my $_pscmd = $2;
            my @_psargs = grep { /\S+/ } split(/\s/,$3 // "");
            given ($_pscmd) {
                # perlsh.color [color]
                when (/color/)
                {
                    if ( @_psargs == 1) {
                        given ($_psargs[0]) {
                            $NOCOLOR = $_psargs[0] when /^(both|none|primary|secondary)$/;
                            say("color mode $_psargs[0] is invalid\n");
                        }
                    } elsif (@_psargs > 1) {
                        say("way too many arguments, only accepts both,primary,secondary,none");
                    }
                    else
                    {
                        say("current color mode is: $NOCOLOR");
                    }

                }
                say ("invalid perlsh subcommand, $_pscmd, ignored (with " . @_psargs . " arguments)"); 
            }
        }
        when ( m/^(\!)(.*)$/g )
        {              
            sub statuscode { my $code = shift; given($code) { return "000_NOERROR" when 0;  return "127_USER_ERROR" when 127; return "001_FAILED" when 1; }; return sprintf("%03d",$code); }
            say "command $2 returned status code: " . statuscode(system("$2")) ;
        }            
        when ( m/\A(restart|ed(it)?(source|src))\z/ )
        {
            my $skiprun=0;
            if ( m/\Aed/ ) 
            {
                if ($editor->exists() ) 
                {
                    if ( $PROGPATH->exists() ) 
                    {
                        say("about to edit $PROGNAME path, $PROGPATH...");
                        unless ( system($editor,$PROGPATH)) 
                        {                               
                            warn("launching $editor onto $PROGPATH gave unexpected return code: $? (last extended info=[$!])");
                            $skiprun++;
                        }
                    } 
                    else 
                    {
                        say("$PROGNAME($PROGPATH) cannot be read, make sure you can access it");
                        $skiprun++;
                    }
                } 
                else 
                {
                    say("editor functions are not available due to missing default (in etc/alternatives) editor on this system");
                    $skiprun++;
                }             
            }                
	        SKIPRUN:while($skiprun > 0) 
    		{
                say("(restarting perlsh, you will lose all state data), is this ok? type 'y' or 'n' and press enter:");
                my $response = ( lc(readline()) );
                chomp($response);
                # reset here, just in case
                last SKIPRUN if $response =~ /n/;
                if ($response =~ /y/) {
                    $term->csay("~2restarting~8...~7");
                    exec($0,"@ARGV") if $response =~ /y/;   # note, not coming back from this, jump to line 1 while purging any state (as in exec(2))
                }
                say("INVALID CHOICE, PLEASE PICK EITHER Y or N!");
            }
        }
        when ( m/^\?\S+/g )
        {
            my $pfx;
            my $cmd;
            my $rest = substr($command,1);
            # internal help
            $_ = $rest;
            if ( /^(\?|\$|\&|\~|N)/ ) {
                $pfx = substr($rest,0,1);
                $cmd = substr($rest,1);
            } else {
                $pfx = "F"; # firstfound
                $cmd = $rest;
            }
            say("calling perlhelp with cmd=[$cmd] pfx=[$pfx]");
            perlhelp($cmd,$pfx);


        }
        when (m/^hist( (on|off|-?-h(elp)?))?$/g)
        {
    		(say("history disabled"),$usehist=0) when /off/;
    		(say("history enabled"),$usehist=1) when /on/;
    		say("history is " . w
    		 $usehist ? "on":"off" ) when /^hist$/;
    		say("syntax: hist [on|off]") when /hist (--)?h(elp)?$/g;
    	}
        when (m/^noecho$/g)
        {
            $noecho ^= 1;
            say("the NOECHO mode is now " . ($noecho ? "on" : "off"));
        }            
        when ( m/^$/g )
        {
            unless ($silent) {                
                my $PPID = getppid();
                say("- You're in the " . (length($CWP) > 0 ? $CWP : "root (topmost)") . " package, in pwd = " . cwd . "");
                say("  Our PID is $$ (child of $PPID)");
                say("  The Current User is " . $ENV{USER} . "(" . $ENV{UID} . "), Parent Shell is " . ($ENV{SHELL} // "unknown") . ".");
                say("  The Open FDs are: " . path("/proc/self/fd")->children() . "");
                
            }
        }
        default
        {
            $lastcmd = $command;
            $term->csay("~22evaluating ~8'~1$lastcmd~8'~7") unless $silent;
            drawbox("N","output begin here") unless $silent;
            my @result = eval ("$strict package $CWP; $command");                
            unless ($silent)
            {
                say("");
                drawbox("S","end output area");                              
                use strict;
                if ($@)
                {
                    drawbox("I"," Error: $@\n__"); next;
                }
                else
                {
                    my %result = @result;
                    my $sresult = join(",",@result);
                    given ($command)
                    {                       
                                when (/^\s*%[^;]+\s*/ and ((@result) % 2) == 0 )
                                {
                                    my $_btot=0;    # grand total bytes
                                    my $_ibtot=0;   # total item bytes
                                    my $_vbtot=0;   # total value bytes
                                    my $_ktot=0;    # key(s) handled
                                    my $_etot=0;    # empty key(s)
                                    sub elide
                                    {
                                        sub warnval
                                        {
                                            warn("<undef given as number, defaulting to @_>"); return shift // 1;
                                        }
                                        my $str = shift // "<invalid data>";
                                        my $siz = shift // warnval(8);
                                        my $eln=length($str);
                                        return $str if ($eln <= $siz);
                                        my $esz=int($siz/2)-2;
                                        my $rstr=substr($str,0,$esz) . "..." . substr($str,$eln-$esz);
                                        return $rstr;
                                    }
                                    $term->csay("~7Hash Data of symbol ~1$_~7");
                                    my $kpart = int(($COLUMNS * 0.25) - PAD_LR);
                                    my $vpart = int(($COLUMNS * 0.75) - PAD_LR);
                                    my $fmtstr="%-${kpart}s %-${vpart}s\n";
                                    printf $fmtstr,"Key","KIND(Address) or Value";
                                    my @sorted  = sort { $a cmp $b } keys %result;
                                    for my $item (@sorted)
                                    {
                                        my $value = $result{$item};
                                        my $vlen = length($value);
                                        my $ilen = length($item);
                                        $_btot+=$vlen + $ilen;
                                        $_vbtot+=$vlen;
                                        $_ktot+=1;  $_ibtot += $ilen;
                                        $_etot+=1 unless $vlen;
                                        printf $fmtstr, elide($item,$kpart), elide($result{$item},$vpart);
                                    }
                                    printf("\n%d pair(s), %d key byte(s)\n%d data bytes, %d empty key(s)\n%d total bytes in structure.\n", $_ktot,$_ibtot,$_vbtot,$_etot,$_btot);
                                }
                                default
                                {
                                    given($command)
                                    {
                                    $term->csay("\nlist data =>\n" . Dumper(@result)) when /^(@|keys\(%)/;
                                    $term->csay("\nhash data =>\n" . Dumper(%result)) when /^%/;                                        
                                    $term->csay("\nscalar data\n value => \"@result\"") when /^\$/;

                                    when (/^\s*package\s+([\w:]+)/)
                                    {
                                        $CWP = $1;
                                        $term->csay("\n~122package change~8:~128 $CWP~7\n");
                                    }                                        
                                    when (/^synopsis ([A-Za-z:_]*)$/)
                                    {
                                        say("");
                                        system($command);
                                    }                                        
                                    default
                                    {
                                        say("\ngeneric or unknown datatype\n");
                                        printer (@result);
                                    }
                                } # default
                             print("\n");
                        } # given(command)
                    } # else (if ($@) )
                } # unless $silent
            } # default (given(command)
        } #default (given(command))
    }
}


sub sigint
{
    $linereader->modifying;
    $linereader->delete_text;
    $attribs->{point} = $attribs->{end} = 0;
    $linereader->redisplay;
}

sub quit
{
    $linereader->WriteHistory($HISTFILE) or warn "perlsh: cannot write history file: $!\n";
    exit (0);
}

sub reader
{
    my ($line, $command);
    $command = '';
    select()->flush();    

    while (1)
    {        
        
        $linereader->ornaments("setaf,24,setaf,26");
        $line = $linereader->readline($command ? $PS2 : prompt($PS1));
	    $add_to_hist=$usehist;
        
        return undef unless (defined $line);
        if ($line =~ /\\$/)
        {
            chop $line;
            $command = $command ? $command . " $line" : $line;
        }
        else
        {
            $command = $command ? $command . " $line" : $line;
            $linereader->addhistory($command) if (length($command) > 0) and $add_to_hist == 1;
            return $command;
        }
    }
}


use constant { USE_KEYS => 1, USE_VALUES => 0, LONGEST_OF => 0, SHORTEST_OF => 1, AVERAGE_OF => 2, MAX_STR_LEN  =>  16384, MIN_STR_LEN => 0 };
sub estelem($target,$bkey=USE_KEYS, $comp=SHORTEST_OF)
{
   my %target = %$target;
   my $est = ($comp==SHORTEST_OF ? MAX_STR_LEN : MIN_STR_LEN); #3a       
   my $thislen = ($bkey == USE_KEYS ? length($_) : length(%target{$_}));
   for (keys(%target)) {
        if ($comp == SHORTEST_OF) {
            $est = $thislen if $est > $thislen;
        } elsif ($comp == LONGEST_OF) {
            $est = $thislen if $est < $thislen;
        } elsif ($comp == AVERAGE_OF) {
            $est+=$thislen;
        }
    } 
    return $est / ($comp == 2 ? scalar(keys(%target)) : 1); #3b
}
sub longestelem($target,$bkey=USE_KEYS) {  return  estelem($target,$bkey,LONGEST_OF); }
sub shortestelem($target,$bkey=USE_KEYS) {  return  estelem($target,$bkey,SHORTEST_OF); }
sub averageelem($target,$bkey=USE_KEYS) {  return  estelem($target,$bkey,AVERAGE_OF); }
sub longestkey($target) { return longestelem($target,USE_KEYS); }
sub longestval($target) { return longestelem($target,USE_VALUES); }
sub shortestkey($target) { return shortestelem($target,USE_KEYS); }
sub shortestval($target) { return shortestelem($target,USE_VALUES); }
sub averagekey($target) { return averageelem($target,USE_KEYS); }
sub averageval($target) { return averageelem($target,USE_VALUES); }
sub printer
{
    my $colpad = 2;
    my (@res) = @_;
    my ($i, $k, $v);
    my $x = 0;

    my $maxw = ( $ENV{"COLUMNS"} // DFCOLS ) - $colpad;
    my $maxil = $maxw / 4;
    my $maxvl = $maxw - $maxil;
    my ($il, $vl) = (0,$maxvl);
    if ( $lastcmd =~ /^%/ )
    {
        $term->csay("~8\"~2$lastcmd~8\"~24 evaluated to a hash object ~8(~2guessed from input~8)~7\n");
        my %hres = @res;
        $il=0;
        my $kn="-key-";
        my $vn="-value-";
        foreach $k (keys(%hres))        {
            $il = length($hres{$k}) > $il ? length($hres{$k}) : $il;
        }
        $il=$maxil unless $il < $maxil;
        $il=int($il);
        $vl=int($vl);
        my $fmtstr = "~1%${il}.${il}s ~22%-${vl}.${vl}s~7\n";
        $term->printf($fmtstr,$kn,$vn);
        foreach $k (keys(%hres))
        {
            $v = $hres{$k};
            $term->printf($fmtstr,$k,$v);
        }

    }
    else
    {
        if (@res == 1)
        {
            print("'$lastcmd' returned scalar value of '", $res[0], "'\n");

        }
        elsif (@res == undef)
        {
            print("'$lastcmd' evaluated to 'undef' (undefined value)\n");
        }
        else
        {
            print("'$lastcmd' evaluated to nonscalar context:\n");
            if ( scalar(@res) % 2 )
            {
                printf("\n** Outputting as List **\n");
                printf("\n");
                # cant be a hash, uneven
                printf("%-${il}s %s\n","index","value");
                printf("=" x $COLUMNS - 2);

                foreach $i (@res)
                {
                    printf("%-${il}d %s\n",++$x,$i);
                    $LASTRV=$i unless (int($i) == 0);
                }
            }
            else
            {
                printf("\n** Outputting as Hash **\n");
                printf("\n");
                # interpret as hash (even member count)
                my %hres = @res;
                $il = 0;
                $il = ( length($_) > $il ? length($_) : $il ) for keys(%hres);
                printf("=" x ($COLUMNS - 2)               );
                printf("\n%-${il}s %s\n","key","value");
                printf("=" x ($COLUMNS - 2)               );
                printf "\n";
                foreach $i (keys(%hres))
                {
                    printf("%-${il}s %s\n",$i,$hres{$i});
                    $LASTRV=$i unless (int($i) == 0);
                }
            }

            printf("=" x $COLUMNS - 2);

        }
    }
    printf("$PS1COLOR") unless length($PS1COLOR) == 0;

}

sub prompt(@values) #9MT
{
    local($_) = @values;
    return &$_ if (ref($_) eq 'CODE');
    s/\\h/$HOSTNAME/g;
    s/\\u/$LOGNAME/g;
    s/\\w/$CWP/g;
    s/\\v/$LASTRV/g;
    s/\\!/$attribs->{history_base} + $attribs->{history_length}/eg;
    $_;
}



sub perl_symbol_display_match_list ($matches, $num_matches, $max_length)
{
#    my($matches, $num_matches, $max_length) = @_;
    map { $_ =~ s/^((\$#|[\@\$%&])?).*::(.+)/$3/; }(@{$matches});
    $linereader->display_match_list($matches);
    $linereader->forced_update_display;
}

sub attempt_perl_completion ($text, $line, $start, $end) {

    no strict qw(refs);
    if (substr($line, 0, $start) =~ m/\$([\w:]+)\s*(->)?\s*{\s*['"]?$/) {

    $attribs->{completion_append_character} = '}';
    return $linereader->completion_matches($text,
                     \&perl_hash_key_completion_function);
    } elsif (substr($line, 0, $start) =~ m/\$([\w:]+)\s*->\s*['"]?$/) {

    $attribs->{completion_append_character} = ' ';
    return $linereader->completion_matches($text,
                     \&perl_method_completion_function);
    } else {
    $attribs->{completion_append_character} = '';
    return  $linereader->completion_matches($text,
                      \&perl_symbol_completion_function);
    }
}


use vars qw($i @matches);

sub perl_hash_key_completion_function ($text, $state)
{

    if ($state) {
    $i++;
    } else {

    $i = 0;
    my ($var,$arrow) = (substr($attribs->{line_buffer},
                   0, $attribs->{point} - length($text))
                =~ m/\$([\w:]+)\s*(->)?\s*{\s*['"]?$/);
    no strict qw(refs);
    $var = "${CWP}::$var" unless ($var =~ m/::/);
    if ($arrow) {
        my $hashref = eval "\$$var";
        @matches = keys %$hashref;
    } else {
        @matches = keys %$var;
    }

    }
    for (; $i <= $#matches; $i++) {
    return $matches[$i] if ($matches[$i] =~ /^\Q$text/);
    }
    return undef;
}

sub _search_ISA ($) {
    my ($mypkg) = @_;
    no strict 'refs';
    no warnings 'prototype';
    my $isa = "${mypkg}::ISA";
    return $mypkg, map _search_ISA($_), @$isa;
}

sub perl_method_completion_function ($text,$state)
{

    if ($state)
    {
        $i++;
    }
    else
    {

        my ($var, $pkg, $sym, $pk);
        $i = 0;
        $var = (substr($attribs->{line_buffer},
                   0, $attribs->{point} - length($text))
            =~ m/\$([\w:]+)\s*->\s*$/)[0];
        $pkg = ref eval (($var =~ m/::/) ? "\$$var" : "\$${CWP}::$var");
        no strict qw(refs);
        @matches = map {
                            $pk = $_ . '::';
                             grep (  /^\w+$/ && ($sym = "${pk}$_",
                                     defined *$sym{CODE}),
                                     keys %$pk
                                  );
        } _search_ISA($pkg);
    }
    for (; $i <= $#matches; $i++)
    {
        return $matches[$i] if ($matches[$i] =~ /^\Q$text/);
    }
    return undef;
}


{
    my ($prefix, %type, @keyword);

sub perl_symbol_completion_function ($text,$state)
{
    if ($state)
    {
        $i++;
    }
    else
    {

        my ($pre, $pkg, $sym);
        $i = 0;

        no strict qw(refs);
        ($prefix, $pre, $pkg) = ($text =~ m/^((\$#|[\@\$%&])?(.*::)?)/);
        @matches = grep /::$/, $pkg ? keys %$pkg : keys %::;
        $pkg = ($CWP eq 'main' ? '::' : $CWP . '::') unless $pkg;

        if ($pre) {
        @matches = (@matches,
                grep (/^\w+$/
                  && ($sym = $pkg . $_,
                      defined *$sym{$type{$pre}}),
                  keys %$pkg));
        } else {
        @matches = (@matches,
                !$prefix && @keyword,
                grep (/^\w+$/
                  && ($sym = $pkg . $_,
                      defined *$sym{CODE}
                      || defined *$sym{FILEHANDLE}
                     ),
                  keys %$pkg));
        }
    }
    my $entry;
    for (; $i <= $#matches; $i++) {
        $entry = $prefix . $matches[$i];
        return $entry if ($entry =~ /^\Q$text/);
    }
    return undef;
    }

    BEGIN {
    %type = ('$' => 'SCALAR', '*' => 'SCALAR',
         '@' => 'ARRAY', '$#' => 'ARRAY',
         '%' => 'HASH',
         '&' => 'CODE');



    @keyword = qw(
            exit quit clear ls cd chmod chown start run

            chomp chop chr crypt hex index lc lcfirst
            length oct ord pack q qq
            reverse rindex sprintf substr tr uc ucfirst
            y

            m pos quotemeta s split study qr

            abs atan2 cos exp hex int log oct rand sin
            sqrt srand

            pop push shift splice unshift

            grep join map qw reverse sort unpack

            delete each exists keys values

            binmode close closedir dbmclose dbmopen die
            eof fileno flock format getc print printf
            read readdir rewinddir seek seekdir select
            syscall sysread sysseek syswrite tell telldir
            truncate warn write

            pack read syscall sysread syswrite unpack vec

            chdir chmod chown chroot fcntl glob ioctl
            link lstat mkdir open opendir readlink rename
            rmdir stat symlink umask unlink utime

            caller continue die do dump eval exit goto
            last next redo return sub wantarray

            caller import local my package use

            defined dump eval formline local my reset
            scalar undef wantarray

            alarm exec fork getpgrp getppid getpriority
            kill pipe qx setpgrp setpriority sleep
            system times wait waitpid

            do import no package require use

            bless dbmclose dbmopen package ref tie tied
            untie use

            accept bind connect getpeername getsockname
            getsockopt listen recv send setsockopt shutdown
            socket socketpair

            msgctl msgget msgrcv msgsnd semctl semget
            semop shmctl shmget shmread shmwrite

            endgrent endhostent endnetent endpwent getgrent
            getgrgid getgrnam getlogin getpwent getpwnam
            getpwuid setgrent setpwent

            endprotoent endservent gethostbyaddr
            gethostbyname gethostent getnetbyaddr
            getnetbyname getnetent getprotobyname
            getprotobynumber getprotoent getservbyname
            getservbyport getservent sethostent setnetent
            setprotoent setservent

            gmtime localtime time times

            abs bless chomp chr exists formline glob
            import lc lcfirst map my no prototype qx qw
            readline readpipe ref sub sysopen tie tied
            uc ucfirst untie use

            dbmclose dbmopen
           );
    }
}

__END__

=pod

Before invoking, this program reads F<~/.perlshrc> and evaluates the
content of the file.

When this program is terminated, the content of the history buffer is
saved in a file F<~/.perlsh_history>, and it is read at next
invoking.

=head1 VARIABLES

You can customize the behavior of C<perlsh> by setting following
variables in F<~/.perlshrc>;

=over 4

=item C<$PerlSh::PS1>

The primary prompt string.  The following backslash-escaped special
characters can be used.

    \h: host name
    \u: user name
    \w: package name
    \!: history number

The default value is `C<\w[\!]$ >'.

=item C<$PerlSh::PS2>

The secondary prompt string.  The default value is `C<E<gt> >'.

=item C<$PerlSh::HISTFILE>

The name of the file to which the command history is saved.  The
default value is C<~/.perlsh_history>.

=item C<$PerlSh::HISTSIZE>

If not C<undef>, this is the maximum number of commands to remember in
the history.  The default value is 256.

=item C<$PerlSh::STRICT>

If true, restrict unsafe constructs.  See C<use strict> in perl man
page.  The default value is 0;

=back

=head1 FILES

=over 4

=item F<~/.perlshrc>

This file is eval-ed at initialization.  If a subroutine C<afterinit>
is defined in this file, it will be eval-ed after initialization.
Here is a sample.



    sub h { map { sprintf("0x%x", $_ ) } @_;}

    sub tk {
        $t->tkRunning(1);
        use Tk;
        $mw = MainWindow->new();
    }


    sub afterinit {
        *t = \$PerlSh::term;
        *a = \$PerlSh::attribs;
    }

=item F<~/.perlsh_history>

=item F<~/.inputrc>

A initialization file for the GNU Readline Library.  Refer its manual
for details.

=back

=head1 SEE ALSO

L<Term::ReadLine::Gnu|http://search.cpan.org/dist/Term-ReadLine-Gnu/>

L<GNU Readline Library|http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html>

=head1 AUTHOR

Hiroo Hayashi <hiroo.hayashi@computer.org>

            Main Author of the original file.
            This file is a derivitive of his 'perlsh'.

=head1 CONTRIB

Gabriel T. Sharp <21shariria@gmail.com>

=over 4

=item C<Contributing Author (not fully in circulation)
            Stored in github/osirisgothra/mini.git under eso/ubin-local/perlsh
            (If there are further notes, they would be in README.md)
            Contributed startup code additions (@INC checking, colorization,
            Data::Dumper integration, Term::ANSIColor and Path::Tiny support)
            Also added some minor program flow plus extra commands/interpreters, etc.>

=back

=head1 CONTRIB NOTES
=over 4
=item CONTRIB-NOTE perldoc (affected function)
=back
=begin text

The following code was removed from the perldoc's findfiles routine, as it is listed below. It was
a depth aware version of the current, shorter version. It is no longer being used at all because
it is for recursion under path objects to allow for deeper searches (for perldoc, etc)  but later
was deemed to be unsanitary and insecure, so it was rewritten for just top-level PATH items:

#           for my $curfile ($curpath->children())
#            {
#
#
#                print("+--scanning $curfile for [$mask]\n");
#                if ($curfile->basename() =~ /$mask/) {
#                    push(@results,$curfile) if ( $mindepth != 0 );
#                }
#                if (-d -r -x $curfile) {
#                    push(@results,findfiles($mask,$curfile,zmdec($maxdepth),zmdec($mindepth)) );       # grab these too, if depth is ok
#                }
#
#            }

Also, any "/home/xxx/..." paths may be sanitized out in a later version, should it prove a security risk. At this time, this is not
the case but that could change in the future.

=end text
=item CONTRIB-NOTE 9629 (approximate file position in characters)

=back

=begin text

        DEFERRED SIGNALS in perlipc(5):
            http://perldoc.perl.org/perlipc.html#Deferred-Signals-%28Safe-Signals%29

            The line referred by 9629 originally was:

                $SIG{INT} = sub { ... <rest of block>

            Changed to prevent crashes/noncleanups from SIGINT signals.

        These lines were changed to increase compatibility and bolster resilliance.


CSCS2k COMMENTS

#1   STARTUP COMMANDS

     startup now moved to act just like typed in commands
     entered in, in fact uses the same loop and is read in
     the same way, instead of being emulated, which causes the
     no longer needed code here to be used. The reason its simpler
     is because of delegation. Delegation causes the work shifting
     to the main loop, and the reader 'shifts' a startup command off
     each time it reruns, until it is empty which eliminated the need
     for a separate loop along with a flag to indicate it was done..
     all were not even needed for the new method
     the only possible risk is security and sanitation which isnt done anymore
     except when it applies to the command line. 

    # THIS BLOCK IS TO BE REMOVED WHEN NEW SYSTEM IS WORKING 100%
    #    ### STARTUP COMMANDS TO BE INTERPRETED AT (suprise) STARTUP
    #    ### these are executed as if user typed them, not the same as the environment rcfile!
    #    ### warning: if you place 'exit' in the startup commands it WILL terminate the program!
    #
    #    my $has_startcmds = 0;
    #    my $startcmds = "";
    #    while ( @STARTUP_COMMANDS ) {
    #        #say("entering loop: startup-commands=@STARTUP_COMMANDS");
    #        $_ = pop(@STARTUP_COMMANDS);
    #        #say("item found: $_");
    #        $startcmds.=$_;
    #        $startcmds.=";" if @STARTUP_COMMANDS;  # add ';' only if more commands are to be added
    #        #say("start commands updated: $startcmds");
    #
    #        $has_startcmds = 1;
    #    }
    #    if ($has_startcmds) {
    #        #say("has_startcmds=$has_startcmds: \"$startcmds\"");
    #        $lastcmd_startcmd = 1;
    #        return $startcmds if $has_startcmds;
    #    }
    #    else
    #    {
    #        $lastcmd_startcmd = 0;
    #    }
    #    ### END STARTUP COMMAND CHECK
    # END REMOVEME

#3
    #3b) return average when comp is in AVERAGE_OF mode
         return count when comp is in SHORTEST or LONGEST mode
         when in USE_KEYS mode, selects keys instead of when using USE_VALS mode
    #3a) LONGEST_OF? MAX_STR_LEN  SHORTEST_OF/AVERAGE_OF: MIN_STR_LEN

#2     commands (primary) execution:
            EMPTY LINE - not an error, but not processed either, shows statistics
            noecho - toggle the noecho mode on and off
            ?[string] - GET HELP/MANUAL:  ?MODULE, ?$VAR, ?&FUNC ?~FAQ ??PERLMOD 
            none-of-above - execute as perl code in current module ($CWP)
            !EXTERNALCOMMAND - run command externally and come back
            restart - or matches (restart|ed(it)?(source|src))\z) - edit & restart, cmd = restart, edit, source, src or combo (edsrc, restartsource)            
                   (restart SKIPRUN:...):                 # restart perlsh (reloads the code by exec-ing into a new instance (never to return unless an error launching perlsh happens)
            (empty line) - statistics: (todo: add in more stuff like: command history counts, last few commands entered, allocated vars, etc)

            output values for ^ in this order:

            GENERIC LIST                                         
            HASH [FALLBACK]
            SCALAR
            PACKAGE
            SYNOPSIS
            XENOPHOBIC

            may be replaced by dumper output (wip)

#9 Multithreading

    Not used much in this program but is needed for one specific task. That is, the startup commands
    which are obviously, executed when perlsh first starts. These tend to take a few seconds depending
    on what you have in your configuration and may be really inconvienient to wait for when you want
    to do a quick check with perlsh. For this reason, perlsh puts the loading of startup commands into
    a background thread, additionally, waits a second before even executing them in case you are just
    executing perlsh in a 'quickie' situation. Messages, at this point are very beta and may be removed
    entirely due to annoyances when typing a quickie. At this time, the prompt is redrawn when a message
    comes through however, screen flashing might be a better way to go, or using ANSI to just draw a status
    text at the bottom of the screen (or the top). This feature is still being developed so expect it to
    change, alot.

    On the drawing board is the idea for background calls for long-running commands, like for shells when you
    do a File::Find or something. Its concept-only but may be added later. Such commands would end with a '&!'
    so expect syntax handling for that to show up just prior to its implementation.

    #9MT    Multi-Threadable Subroutines

    Any sub(routine) marked with 9MT needs to make sure it is thread safe. Mainly, a note for programmers at this
    point. Developers should know this and be aware to keep all data and calls thread safe. Also avoid letting these
    routines create threads themselves as this would greatly increase overhead.

    #9TC    Multi-Theaded: Thread Creator   

    Subroutines marked with this, are creators of additional threads and should be handled extra carefully. One wrong
    call to one of these and you could end up deadlocking the system. Also, it should go without saying that these subroutines
    should also be thread safe, inheriting all the attributes a 9MT marked subroutine would have.

    All threads should be clearly marked, starting at thread 1 (the caller thread). The first fork would be thread 2, then
    3 and so on, make sure they are all clearly marked and have a clear exit path. Threads that have no exit path are forbidden
    and should never be used due to their being proned to the creation of ZOMBIE PROCESSES.

#10 MT Logging

    while in other thread, output will go to $logfile
    this is not completed as of yet -- more stuff has to be done
    to get everything in handle_command to redirect to logfile
    for now, it is classed experimentally incomplete

    If this were my own code (100%) I would have finished this,
    but someone else's base code ended up being a bad idea. I am
    rewriting my own perl shell soon, just havent had time to do it.

    the two printf are commented out since jump-prompting is now
    used, but may be abandoned later or removed if jumping was
    a good idea (?) and works out in the future.
    
           
REFERENCES

        perlsh(1)  original version as mentioned above
        perlpod(1) required to read this document
        perldoc(1) preferred parser for this document
        man(1)     can be used as a generic reader for this document
        vim(1)
        nano(1)    these were all used to update or write the perlpod source
        atom(1)


PERLSH - perlsh(3pm) - Perl (Modified) Shell Reference - (Read this document with perlpod, perldoc, or man reader)


=end text




=cut
