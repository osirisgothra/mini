#!/usr/bin/env perl
eval 'exec /usr/bin/env perl -S $0 ${1+"$@"}' unless 1;

#
#   Originally Written By & Copyright (c) 2014 Hiroo Hayashi. All Rights Reserved.
#   PLEASE SEE ORIGINAL LICENSE FOR DETAILS ON USAGE RIGHTS
#
use Time::HiRes;
my $start_time = Time::HiRes::gettimeofday();

package PerlSh;
use v5.20.2;
use Path::Tiny;
use Cwd;
use strict;
use Term::ReadLine;
use Term::Put;
use POSIX;
use Term::ANSIColor 4.00 qw( :constants :constants256 colored colorstrip ); # TODO: Remove --- assumes too much unfortunately!, superceding with Term::Put which acurrately puts the right color sequences
use Path::Tiny;
use Data::Dumper;
use IPC::Open3;

# Constants

use constant { DFLINES => 24, DFCOLS => 80 };
use constant { PAD_L=>1, PAD_R=>1 };
use constant { PAD_LR=>PAD_L+PAD_R };

# Predeclared Subs

use subs qw( say );

# Predeclared Variables (please add newest entries to beginning fno)

use vars qw($noecho $PS1 $PS2 $HISTFILE $HISTSIZE $INPUTRC $STRICT $INNERRC $PS1COLOR $NO_ADORNERS $NO_ADORNERS_OR_CONTENT
            $PS1MONO $NOCOLOR %VERSION $LINES $COLUMNS $HOSTNAME $LOGNAME $CWP
            $LASTRV $USER $UID $UNAME $USERNAME $HOMEDIR $PROGPATH $PROGNAME $AUTOCOLOR @STARTUP_COMMANDS $lastcmd_startcmd);

# Features

use feature "signatures";                                                                # TODO: convert sigil subs to signature subs

no warnings 'deprecated';
no warnings qw(all);                                                                      # testing only

# defaults

my $editor = path( ( -x "/usr/bin/editor" ) ? "/usr/bin/editor" : "/bin/nano" )->_resolve_symlinks();


warn("editor '$editor' was not found -- external edit functions will be disabled") unless $editor->exists();

# debug of certain things set to 0 to prevent message for a particular thing:
# note: not all these are used all the time and may be added/removed at any time
#       devs: try to stick with these if you need a new value, follow simmilar conventions
#             for naming them:

my $debug_find = 0;
my $debug_general = 0;
my $debug_startup = 0;
my $debug_sig = 0;
my $tput = new Term::Put();

#

$NO_ADORNERS=0;                 # disables box adorners, just prints any contentual text
$NO_ADORNERS_OR_CONTENT=0;      # removes adorners and also any contentual text
$PROGNAME="PerlSh";
$PROGPATH=path($0);
$AUTOCOLOR=0;       # <1|0>
$NOCOLOR="both";    # <primary|secondary|both|none>
%VERSION=( major => 2, minor => 4, revision => 1 );

# Tip Of the Day Entries (TODEs)

my @tode = (       "You can use perlsh to do stuff, lots of stuff, and even things.",
                "You can change the prompt by modifying \$PS1",
                "You can ! to run external commands (like !ls)",
                "You can view some details just by using ENTER on a blank line.",
                "You can restart (and reload the source code) by using the restart command \"restart\".",
                "You can get perlhelp via perldoc, from within perlsh using the ? prefix.",
                "The ?& prefix is used to look up help on functions only.",
                'The ?$ prefix is used to look up variable help.',
                'The ?? or ?~ prefix is used to query the perldoc FAQ',
                'You can just type the variable name to get a custom dump of the variable',
                'You can use the use statements to load more packages, and some are loaded at startup too',
                'You can use ~/.perlsh_startup to load packages and other stuff that you dont want to redo each time you use perlsh',
                'You can get the latest version of perlsh form its original author, but it wont have these extras, for that you need to go to the perlsh fork page, github.com/osirisgothra/mini and find the stand-alone perlsh file!',
                'You can edit this source like I did to make it have more features, and to even add more tips (or get rid or turn them off completely!)',
                'There are several special modules embedded in Perl::Sh that you can use from within the interpreter. These modules are internal and arent used in general for programming',
                'Color prompts are disabled in the code, but can be re-enabled (because they can be incompatible with some terminals, which is a contraversial bug in Term::ReadLine::Gnu)',
          );
          # TODO: add more todes

my $banner = '
   PerlSh Enhanced
   (c)2019-20 Gabriel T. Sharp <21shariria@gmail.com>
   (c)2014-20 Base Perl::Sh Designed By Hiroo Hayashi

    NEW CODE LICENSED AS GNU GPL VERSION 3 <https://www.gnu.org/gpl3>
    PLEASE SEE ORIGINAL LICENSE FOR DETAILS ON USAGE RIGHTS
';
say $banner;

sub get_runtime()
{
 my $stop_time = Time::HiRes::gettimeofday();
 return sprintf("%.2f\n", $stop_time - $start_time);
}

sub get_totd() {

    my $totds = @tode // 0;
    my $randomtip = int(rand()*$totds);
    return "There are no tips currently configured (uncomment or insert tips as instructed by the INSTALL to show them" if $totds == 0;
    return "\tDid you know?\n\t\t" . $tode[$randomtip];
}
sub setprompt() {

    # color prompts disabled (see tips for the why)
    #$PS2 = '[38;5;200m[1mmore[2m?[21m[22m ';
    #$PS1 = "[38;5;232m[[38;5;21mP[38;5;25me[38;5;80mr[38;5;110ml[38;5;195mS[38;5;255mh[38;5;232m]:[[38;5;60mT[38;5;232m][38;5;97m2[38;5;218m>[s[38;5;111m[u ";
    # a demo of the new prompt system
    #$PS1 = "^pkg ^wd ^hist ^sec> "
    $PS1 = "perlsh>"; #old faithful
    $PS2 = ">>> ";
}
sub expandpromptstring($str)
{
    my $PKGNAME = length($CWP) > 0 ? $CWP : "main";
    my $WD = Cwd();
    #my $HIST = $NUMHIST > 0 ? $NUMHIST : "(empty)";
    #my $SEC = $SECONDS_SINCE_RUN;

    local $_;
    $_  = $str;   # important, make sure $_ is localized so we dont mess with the caller's or "global" $_, whichever might be active
    # expansions to be done on $_ are local, and we MUST NOT modify $str !!!

    s/^pkg/$PKGNAME/g;
    # s/^hist/$HIST/g;
    s/^wd/$WD/g;
    # s/^sec/$SEC/g;



}



setprompt;
sub zmdec($in)
{
    if ($in == -1 || $in == 0) {
        return $in;
    } else {
        return $in - 1;
    }
}

sub ansilen { s/^[\[[0-9;]+m//; return length($_); }
sub nonprinting { my $count = shift; return ("[s" x ($count / 3)); }
sub findexec($name) { return (findexecs($name))[0] // undef; }
sub findexecs($name) {
    my @found = findfiles("(?<=\/)$name\$",$ENV{PATH},1);           # see section: CONTRIB perldoc (in pod view)
    if (@found) {
        return @found;
    } else {
        return ();
    }
}
sub findfiles($mask, $path=$ENV{PATH}, $maxdepth=-1, $mindepth=-1)
{
    my @results = ();
    return @results if $maxdepth == 0;
    for (split(":",$path))
    {
        chomp($_);
        if ( -r -d $_ )         {
        print("scanning $_ for [$mask]\n") if $debug_find;   # debug only
            my $curpath = path($_)->realpath();
            my @items = grep { /$mask/ } $curpath->children();
            for my $i (@items) {
                print("found $i ok\n") if $debug_find;
                push(@results, $i);
            }
        print("nothing in $_\n") unless @items or (not $debug_find);# debug only
        }
    }
    return @results;


}

sub perlhelp($context, $section="N")    # N=all
{
    #  get perldoc path, then (maybe) get man path if needed
    my $pd = findexec("perldoc");
    if ( -r $context ) {
        # manpath does not need to fall out of scope, it only does undefined with a warning!
        my $manpath=findexec("man") // warn("couldnt find man!!!");
        system($manpath,$context) or warn("tried to manify $context but couldnt, sorry: $! $?\n");
        return;
    }
    $_ = $section // "";
    say("called with section=[$section] context=[$context]");
    $_ = "N" unless /\A(\$|&|~|\?|N|F)\z/;
    my @flags = ();
    sub ctx($item) { my $oldus=$_; my $res=""; given($item) {
        $res="function" when /-f/;
        $res="variable" when /-v/;
        $res="frequently asked question (FAQ) keyword" when /-q/;
        $res="linux man(ual) page" when /man/;
        $res="regular plain old document (POD) file" when /""/;
        $res="unknown thingy";}
        $_ = $oldus; return $res;   # restore scalar-uscore because given changes it (given the chance (sorry for the pun)!)
    }

    given($_) {
        @flags = qw( -f -v -q "" man ) when /[NF]/; # NOTE: be sure not to use quotes when adding new items to this list!! (it is LITERAL)
        @flags = qw( -f ) when /&/;
        @flags = qw( -v ) when /\$/;
        @flags = qw( -q ) when /[~\?]/;
        @flags = qw( "" ) when /n/;
        default { @flags = (); }
    }
    my $stopatfirst = $section eq "F" ? 1 : 0;
    say("found $pd, using it with pfx=" . join(",",@flags) . " and ctx=[$context]");

    unless (-x $pd ) {
        say "fatal, cannot find perldoc" ;
        return "";
    }
    else
    {
        for my $flag ( @flags ) {
            printf("checking to see if %s is %s\n",$context,ctx($flag));
            if ($flag eq "man")
            {
                printf("about to use man on $context\n");
                system("/bin/man",$context);
            }
            elsif  ($flag ne '""' )
            {  system($pd,$flag,$context);  }
            else
            {  system($pd,$context); }          # <- handles "" flag (usually a pod name)

            if ( $? == 0 )
            {
                say("stopping after first found document") if $stopatfirst;
                return if $stopatfirst;
            }
        }
    }


}



# will not allow x in setcolumn(x) to be < 0 or > COLUMNS (use other one to bypass checking)
sub setcolumn
{
    my $loc = shift // 0;
    $loc = $loc > $COLUMNS ? $COLUMNS : ( $loc < 0 ? 0 : $loc );
    my $rv = `tput hpa $loc`;
    chomp $rv;
    return $rv;
}
sub rawsetcolumn { return `tput hpa ` . shift // "0"; } # does not check x like in setcolumn(x), not called by setcolumn (preserves individuality)

sub drawbox {
    return "" if $lastcmd_startcmd;                                                              # don't adorn or ornament during startup (its real ugly to do so)
    my $db_old_uscore = $_;                                                                      # preserve $_
    my $db_side = shift // "full";                                                               # very flexible syntax, see below
    my $db_content = shift // "";
    (say($db_content),return $db_old_uscore) if $NO_ADORNERS;                                    # allow it to be turned off (adorners only)
    return $db_old_uscore if $NO_ADORNERS_OR_CONTENT;                                            # allow it to be turned off (everything)
    my $db_draw="?";
    # â”â”“â”—â”›â”£â”«â”³â”»â•‹â•¸â”ƒâ”â”â”…â”‹
    given ($db_side)
    {                                                                                            # some paramaeters for drawbox(param1 that work well (* = currently defaults to)
        $db_draw="N" when /( t(op (most)? )? | [Nn](orth)? | u( p (p er )? )? )/x;               # t, top, N, north, North, upper, up, u, etc,
        $db_draw="S" when /( b(ot (tom)?  )? | [Ss](outh)? | l( o (w(er))? )? )/x;               # south, S, bot, b, bottom, etc,
        $db_draw="I" when /( m(id (dle)?  )? | h ( oriz ( (on)? tal)? )? -? ( rule r? )? )/x;    # horizon, horizontal h-rule, etc all work
        $db_draw="C" when /(side|content(s)?|in(side)?|(full|te?xt)(area)?)/x;                   # side, content, contents, inside, in, txtarea, text, textarea, *full, etc
    }
    $_=$db_draw;
    CORE::printf("â”" . ("â”" x ($LINES - 4)) . "â”“") if /N/;
    CORE::printf("â”—" . ("â”" x ($LINES - 4)) . "â”›") if /S/;
    CORE::printf("â”£" . ("â”" x ($LINES - 4)) . "â”«") if /I/;

    my $db_col = 4;                                                                             # <- align depending on position, these are placeholders to be filled out later
    $db_col = 8 if /S/;                                                                         # <- 4(top), 6(middle), 8(bottom)
    $db_col = 6 if /I/;                                                                         # <- this will come into play as the function is more fleshed out



    $db_content =~ s/\s/â”/g unless /C/;                                                          # we dont want a line when we are "in the box"
    CORE::print( setcolumn($db_col) . "$db_content\n") if length($db_content);                        # just sets the column hard to 4
    $_ = $db_old_uscore;                                                                         # restore $_ before returning
    return $_;                                                                                   # return $_ as value (in case needed on same line)
}

$PS2 = ("  ++   ");
$HISTFILE = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlsh_history";
$HISTSIZE = 256;
$INPUTRC = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlshrc";
$INNERRC = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlshirc";
$STRICT = 0;
$HOSTNAME = $ENV{HOSTNAME};
$LOGNAME = $ENV{LOGNAME};
$USERNAME = $ENV{USERNAME};
$USER = $ENV{USER};
$HOSTNAME = $ENV{HOSTNAME};
$UNAME = $ENV{UID};
$CWP = 'main';
@STARTUP_COMMANDS=( "CORE::say('test')" );
my $HOMEDIR=path($ENV{HOME} // "/tmp");
my $homeconf = $HOMEDIR->child(".perlsh_startuprc");
    if ($homeconf->exists()) {
        print("loading $homeconf ...");
        @STARTUP_COMMANDS= grep { /^[^#]*$/ } $homeconf->lines();
        print("loaded " . @STARTUP_COMMANDS . " startup command(s)\n") if @STARTUP_COMMANDS;
    } else {
        print("$homeconf does not exist, no commands will be executed\n");
        # comment this line to test startup commands (the hard coded ones)
        # you will also need to rename any startup config file or make changes above to make
        # the test for the file return false
        @STARTUP_COMMANDS=( );
}

package main;

if (-f $PerlSh::INPUTRC) {
    do $PerlSh::INPUTRC;
}

if (-f $PerlSh::INNERRC ) {
    do $PerlSh::INNERRC;
}
package PerlSh;

sub hrule {

    printf  colored("%s\n",'grey1'), "=" x ($ENV{"COLUMNS"} //     DFCOLS);

}
sub vrule {
    while(1) {
        my $item1 = shift;
        my $item2 = shift // "";
        my $L = $ENV{'COLUMNS'} // DFCOLS;
        last unless defined($item1);
        printf("%${L}s | %${L}s", $item1, $item2)
    }
}

use vars qw($term $attribs);

$term = new Term::ReadLine 'PerlSh';
$term->ornaments("1,2,3,4");
$attribs = $term->Attribs;
$term->bind_key(ord "^", 'history-expand-line', 'emacs-meta');
$term->bind_key(ord "\cv", 'display-readline-version', 'emacs-ctlx');
$term->bind_key(ord "\cc", 'abort');

if (defined &main::afterinit) {
    package main;
    &afterinit;
    package PerlSh;
}

&toplevel;


my $lastcmd="";
sub length_ansi
{
    my @results = ( );
    push(@results,( length( colorstrip($_) ) )) for @_;
    return 0 if @results == 0;
    return @results if (@results > 1);
    return $results[0] if (@results == 1);
    return length($_) if length($_) > 0;
    die("bad value/no value passed (need >= 1 or default params \$_ set");

}

sub findinpath {
    my $filename = shift;
    unless ( -r "$filename" ) {
        for (split(':',$ENV{"PATH"} // "/:.")) {
            my $testfile = path($_)->child($filename);
            return $testfile if -r $testfile;
        }
    }
    return $filename
}
sub export {}

sub failbackto
{
    my $msg = shift // die("failback syntax error: none \$msg");
    my $val = shift // die("failback failed internally: none \$val");
    warn("failing back to $val for $msg");
    return $val;
}

sub toplevel
{
    $HOMEDIR = path($ENV{"HOME"} // cwd);
    printf("using system appointed home for user: %s\n", $HOMEDIR);
    die("cannot find a user-writable home directory ($HOMEDIR either isnt writable, or is an invalid value") unless -w $HOMEDIR;

    my $COLUMNS = $tput->cols;
    my $LINES = $tput->lines;
    say "using ${COLUMNS}x${LINES} terminal";


    print("$PS1COLOR") if length($PS1COLOR) > 0;
    print("PS1 length zero, but color prompting disabled\n") unless ( length($PS1COLOR) | length($PS1) ) > 0;
    hrule;
    printf GREEN "";
    my $totd = get_totd;
    printf "$totd\n";
    hrule;

    $term->MinLine(undef);
    $term->stifle_history($HISTSIZE);
    if (-f $HISTFILE) { $term->ReadHistory($HISTFILE) or warn "perlsh: cannot read history file: $!\n"; }
    $attribs->{attempted_completion_function} = \&attempt_perl_completion;
    $attribs->{special_prefixes} = '$@%&';
    $attribs->{completion_display_matches_hook} = \&perl_symbol_display_match_list;
    sigaction SIGINT, new POSIX::SigAction sub {
        $term->modifying;
        $term->delete_text;
        $attribs->{point} = $attribs->{end} = 0;
        $term->redisplay;
    } or die "[31;1mError setting SIGINT handler: $![0m\n";
    my ($strict, $command, @result);
    $strict = $STRICT ? '' : 'no strict;';
    say("[0m") if $ENV{TERM};     ### TODO: add support from Term::Put when its completed
    ### READ A COMMAND FROM USER OR STARTUPFILE
    while (defined($command = &reader)) {

        # PREPROCESSORS
        given ($command) {
            # strip "my" or "our" from BOLs
            when ( m/^(my|our)( .*)/ ) {
                say("info: removed preceeding our/my from prefix - would not have expected effect in sandbox mode.");
                $command = $2;
            }
        }
        # INTERPRETER
        given($command) {
            # perlsh.COMMANDs     (perlsh.XXX [arg ([arg [...])])
            when ( m/^(perlsh\.)(\S+)(\s.+)?$/ ) {
                my $_pscmd = $2;
                my @_psargs = grep { /\S+/ } split(/\s/,$3 // "");
                given ($_pscmd) {
                    # perlsh.color [color]
                    when (/color/)
                    {
                        if ( @_psargs == 1) {
                            given ($_psargs[0]) {
                                $NOCOLOR = $_psargs[0] when /^(both|none|primary|secondary)$/;
                                say("color mode $_psargs[0] is invalid\n");
                            }
                        } elsif (@_psargs > 1) {
                            say("way too many arguments, only accepts both,primary,secondary,none");
                        }
                        else
                        {
                            say("current color mode is: $NOCOLOR");
                        }

                    }
                    say ("invalid perlsh subcommand, $_pscmd, ignored (with " . @_psargs . " arguments)");      # default
                }
            }
            # !EXTERNALCOMMAND
            when ( m/^(\!)(.*)$/g )
            {              
                sub statuscode { my $code = shift; given($code) { return "000_NOERROR" when 0;  return "127_USER_ERROR" when 127; return "001_FAILED" when 1; }; return sprintf("%03d",$code); }
                say "command $2 returned status code: " . statuscode(system("$2")) ;
            }
            # edit & restart, cmd = restart, edit, source, src or combo (edsrc, restartsource)            
            when ( m/\A(restart|ed(it)?(source|src))\z/ )
            {
                my $skiprun=0;
                if ( m/\Aed/ ) 
                {
                    if ($editor->exists() ) 
                    {
                        if ( $PROGPATH->exists() ) 
                        {
                            say("about to edit $PROGNAME path, $PROGPATH...");
                            unless ( system($editor,$PROGPATH)) 
                            {                               
                                warn("launching $editor onto $PROGPATH gave unexpected return code: $? (last extended info=[$!])");
                                $skiprun++;
                            }
                        } 
                        else 
                        {
                            say("$PROGNAME($PROGPATH) cannot be read, make sure you can access it");
                            $skiprun++;
                        }
                    } 
                    else 
                    {
                        say("editor functions are not available due to missing default (in etc/alternatives) editor on this system");
                        $skiprun++;
                    }             
                }
                
                # restart perlsh (reloads the code by exec-ing into a new instance (never to return unless an error launching perlsh happens)

		        SKIPRUN:while($skiprun > 0) 
        		{
                    say("(restarting perlsh, you will lose all state data), is this ok? type 'y' or 'n' and press enter:");
                    my $response = ( lc(readline()) );
                    chomp($response);
                    # reset here, just in case
                    last SKIPRUN if $response =~ /n/;
                    if ($response =~ /y/) {
                        say("[0m[2J[1;1H[s[0mrestarting...");
                        exec($0,"@ARGV") if $response =~ /y/;   # note, not coming back from this, jump to line 1 while purging any state (as in exec(2))
                    }
                    say("INVALID CHOICE, PLEASE PICK EITHER Y or N!");
                }
            }
            # GET HELP/MANUAL:  ?MODULE, ?$VAR, ?&FUNC ?~FAQ ??PERLMOD 
            when ( m/^\?\S+/g )
            {
                my $pfx;
                my $cmd;
                my $rest = substr($command,1);
                # internal help
                $_ = $rest;
                if ( /^(\?|\$|\&|\~|N)/ ) {
                    $pfx = substr($rest,0,1);
                    $cmd = substr($rest,1);
                } else {
                    $pfx = "F"; # firstfound
                    $cmd = $rest;
                }
                say("calling perlhelp with cmd=[$cmd] pfx=[$pfx]");
                perlhelp($cmd,$pfx);


            }
            # noecho - toggle the noecho mode on and off
            when (m/^noecho$/g)
            {
                $noecho^=1;     # just toggle it
                say("the NOECHO mode is now " . ($noecho ? "on" : "off"));
            }
            # EMPTY LINE, not an error, but not processed either
            # ----------- so show some useful statistics, if not in noecho mode
            when ( m/^$/g )
            {
                unless ($lastcmd_startcmd) {
                    # user pressed ENTER: display some useful state information (WIP)
                    my $PPID = getppid();
                    say("- You're in the " . (length($CWP) > 0 ? $CWP : "root (topmost)") . " package, in pwd = " . cwd . "");
                    say("  Our PID is $$ (child of $PPID)");
                    say("  The Current User is " . $ENV{USER} . "(" . $ENV{UID} . "), Parent Shell is " . ($ENV{SHELL} // "unknown") . ".");
                    say("  The Open FDs are: " . path("/proc/self/fd")->children() . "");
                    #PLAN: add in more stuff like: command history counts, last few commands entered, allocated vars, etc
                }
            }
            # ELSE: process as a perl statement
            default
            {
                #### OUTPUT WINDOW (-ish)

                $lastcmd = $command;
                CORE::say(colored("evaluating '$lastcmd'","rgb022")) unless $lastcmd_startcmd;
                drawbox("N","output begin here");
                @result = eval ("$strict package $CWP; $command");                
                unless ($lastcmd_startcmd)
                {
                    say("");
                    drawbox("S","end output area");
                    #CORE::printf(colored("\n^^---------------------------------^^\n","rgb044"));
                    use strict;
                    if ($@)
                    {
                        drawbox("I"," Error: $@\n__"); next;
                    }
                    else
                    {
                        my %result = @result;
                        my $sresult = join(",",@result);

                        given ($command)
                        {
                            # formatting directive: stop (col 33 freeze)

                                    #### HASH
                                    when (/^\s*%[^;]+\s*/ and ((@result) % 2) == 0 )
                                    {
                                        my $_btot=0;    # grand total bytes
                                        my $_ibtot=0;   # total item bytes
                                        my $_vbtot=0;   # total value bytes
                                        my $_ktot=0;    # key(s) handled
                                        my $_etot=0;    # empty key(s)
                                        sub elide
                                        {
                                            sub warnval
                                            {
                                                warn("<undef given as number, defaulting to @_>"); return shift // 1;
                                            }
                                            my $str = shift // "<invalid data>";
                                            my $siz = shift // warnval(8);
                                            my $eln=length($str);
                                            return $str if ($eln <= $siz);
                                            my $esz=int($siz/2)-2;
                                            my $rstr=substr($str,0,$esz) . "..." . substr($str,$eln-$esz);
                                            return $rstr;
                                        }
                                        print ("Hash Data of symbol " . RED . "$_" . RESET . "\n");
                                        my $kpart = int(($COLUMNS * 0.25) - PAD_LR);
                                        my $vpart = int(($COLUMNS * 0.75) - PAD_LR);
                                        my $fmtstr="%-${kpart}s %-${vpart}s\n";
                                        printf $fmtstr,"Key","KIND(Address) or Value";
                                        my @sorted  = sort { $a cmp $b } keys %result;
                                        for my $item (@sorted)
                                        {
                                            my $value = $result{$item};
                                            my $vlen = length($value);
                                            my $ilen = length($item);
                                            $_btot+=$vlen + $ilen;
                                            $_vbtot+=$vlen;
                                            $_ktot+=1;  $_ibtot += $ilen;
                                            $_etot+=1 unless $vlen;
                                            printf $fmtstr, elide($item,$kpart), elide($result{$item},$vpart);
                                        }
                                        printf("\n%d pair(s), %d key byte(s)\n%d data bytes, %d empty key(s)\n%d total bytes in structure.\n", $_ktot,$_ibtot,$_vbtot,$_etot,$_btot);
                                    }
                                    default
                                    {
                                        given($command)
                                        {
                                        ### GENERIC LIST                                            printer(@result) when /(=|;)/;
                                        print colored("\nlist data =>\n" . Dumper(@result), "rgb043") when /^(@|keys\(%)/;

                                        ### HASH [FALLBACK]
                                        print colored("\nhash data =>\n" . Dumper(%result), "rgb044") when /^%/;

                                        ### SCALAR
                                        print colored("\nscalar data\n value => \"@result\"", "rgb045") when /^\$/;

                                        ### PACKAGE
                                        when (/^\s*package\s+([\w:]+)/)
                                        {
                                            $CWP = $1;
                                            print ( colored("\npackage change: $CWP\n", "rgb054"));
                                        }
                                        ### SYNOPSIS
                                        when (/^synopsis ([A-Za-z:_]*)$/)
                                        {
                                            say("");
                                            system($command);
                                        }
                                        ### XENOPHOBIC
                                        default
                                        {
                                            say("\ngeneric data\n");
                                            printer (@result);
                                        }
                                    } # default
                                 print("\n");
                            } # given(command)
                        } # else (if ($@) )
                    } # unless $lastcmd_startcmd
                } # default (given(command)
            } #default (given(command))
        }
    }
    &quit;

}

sub sigint
{
    $term->modifying;
    $term->delete_text;
    $attribs->{point} = $attribs->{end} = 0;
    $term->redisplay;
}

sub quit
{
    $term->WriteHistory($HISTFILE) or warn "perlsh: cannot write history file: $!\n";
    exit (0);
}

sub reader
{
    my ($line, $command);
    $command = '';
    select()->flush();

    while (1)
    {
        $term->ornaments("setaf,24,setaf,26");
        # startup commands get executed just like
        # regular typed-in commands, its a convience mechanism
        # so must be handled exactly (exactly) the same, not
        # emulated in some other routine as it was before.
        # the flag is needed only to suppress the usuall decorative
        # stuff from showing per command. (You can also do this by
        # using the noecho command)
        if (@STARTUP_COMMANDS) {
            $line = shift(@STARTUP_COMMANDS);
            $lastcmd_startcmd=1;
        } else {            
            $line = $term->readline($command ? $PS2 : prompt($PS1));
            $lastcmd_startcmd=$noecho;
        }
        
        return undef unless (defined $line);
        if ($line =~ /\\$/)
        {
            chop $line;
            $command = $command ? $command . " $line" : $line;
        }
        else
        {
            $command = $command ? $command . " $line" : $line;
            $term->addhistory($command) if (length($command) > 0);
            return $command;
        }
    }
}


use constant { USE_KEYS => 1, USE_VALUES => 0, LONGEST_OF => 0, SHORTEST_OF => 1, AVERAGE_OF => 2, MAX_STR_LEN  =>  16384, MIN_STR_LEN => 0 };
sub estelem($target,$bkey=USE_KEYS, $comp=SHORTEST_OF)
{
   my %target = %$target;
   my $est = ($comp==SHORTEST_OF ? MAX_STR_LEN : MIN_STR_LEN);    # LONGEST_OF? MAX_STR_LEN  SHORTEST_OF/AVERAGE_OF: MIN_STR_LEN
   my $thislen = ($bkey == USE_KEYS ? length($_) : length(%target{$_}));
   for (keys(%target)) {
        if ($comp == SHORTEST_OF) {
            $est = $thislen if $est > $thislen;
        } elsif ($comp == LONGEST_OF) {
            $est = $thislen if $est < $thislen;
        } elsif ($comp == AVERAGE_OF) {
            $est+=$thislen;
        }
    }
    # return average when comp is in AVERAGE_OF mode
    # return count when comp is in SHORTEST or LONGEST mode
    # when in USE_KEYS mode, selects keys instead of when using USE_VALS mode
    return $est / ($comp == 2 ? scalar(keys(%target)) : 1);
}
sub longestelem($target,$bkey=USE_KEYS) {  return  estelem($target,$bkey,LONGEST_OF); }
sub shortestelem($target,$bkey=USE_KEYS) {  return  estelem($target,$bkey,SHORTEST_OF); }
sub averageelem($target,$bkey=USE_KEYS) {  return  estelem($target,$bkey,AVERAGE_OF); }
sub longestkey($target) { return longestelem($target,USE_KEYS); }
sub longestval($target) { return longestelem($target,USE_VALUES); }
sub shortestkey($target) { return shortestelem($target,USE_KEYS); }
sub shortestval($target) { return shortestelem($target,USE_VALUES); }
sub averagekey($target) { return averageelem($target,USE_KEYS); }
sub averageval($target) { return averageelem($target,USE_VALUES); }



sub printer
{

    my $colpad = 2;
    my (@res) = @_;
    my ($i, $k, $v);
    my $x = 0;

    my $maxw = ( $ENV{"COLUMNS"} // DFCOLS ) - $colpad;
    my $maxil = $maxw / 4;
    my $maxvl = $maxw - $maxil;
    my ($il, $vl) = (0,$maxvl);
    if ( $lastcmd =~ /^%/ )
    {
        print colored("\"$lastcmd\" evaluated to a hash object (guessed from input)\n",'cyan');
        my %hres = @res;
        $il=0;
        my $kn="-key-";
        my $vn="-value-";
        foreach $k (keys(%hres))        {
            $il = length($hres{$k}) > $il ? length($hres{$k}) : $il;
        }
        $il=$maxil unless $il < $maxil;
        $il=int($il);
        $vl=int($vl);
        my $fmtstr = "%${il}.${il}s %-${vl}.${vl}s\n";
        print($fmtstr);
        printf(colored($fmtstr,'blue'),$kn,$vn);
        foreach $k (keys(%hres))
        {
            $v = $hres{$k};
               printf(colored($fmtstr,"rgb225"),$k,$v);
        }

    }
    else
    {
        if (@res == 1)
        {
            print("'$lastcmd' returned scalar value of '", $res[0], "'\n");

        }
        elsif (@res == undef)
        {
            print("'$lastcmd' evaluated to 'undef' (undefined value)\n");
        }
        else
        {
            print("'$lastcmd' evaluated to nonscalar context:\n");
            if ( scalar(@res) % 2 )
            {
                printf("\n** Outputting as List **\n");
                printf("\n");
                # cant be a hash, uneven
                printf("%-${il}s %s\n","index","value");
                printf("=" x $COLUMNS - 2);

                foreach $i (@res)
                {
                    printf("%-${il}d %s\n",++$x,$i);
                    $LASTRV=$i unless (int($i) == 0);
                }
            }
            else
            {
                printf("\n** Outputting as Hash **\n");
                printf("\n");
                # interpret as hash (even member count)
                my %hres = @res;
                $il = 0;
                $il = ( length($_) > $il ? length($_) : $il ) for keys(%hres);
                printf("=" x ($COLUMNS - 2)               );
                printf("\n%-${il}s %s\n","key","value");
                printf("=" x ($COLUMNS - 2)               );
                printf "\n";
                foreach $i (keys(%hres))
                {
                    printf("%-${il}s %s\n",$i,$hres{$i});
                    $LASTRV=$i unless (int($i) == 0);
                }
            }

            printf("=" x $COLUMNS - 2);

        }
    }
    printf("$PS1COLOR") unless length($PS1COLOR) == 0;

}

sub prompt {
    local($_) = @_;
    return &$_ if (ref($_) eq 'CODE');
    s/\\h/$HOSTNAME/g;
    s/\\u/$LOGNAME/g;
    s/\\w/$CWP/g;
    s/\\v/$LASTRV/g;
    s/\\!/$attribs->{history_base} + $attribs->{history_length}/eg;
    $_;
}



sub perl_symbol_display_match_list ($matches, $num_matches, $max_length)
{
#    my($matches, $num_matches, $max_length) = @_;
    map { $_ =~ s/^((\$#|[\@\$%&])?).*::(.+)/$3/; }(@{$matches});
    $term->display_match_list($matches);
    $term->forced_update_display;
}

sub attempt_perl_completion ($text, $line, $start, $end) {

    no strict qw(refs);
    if (substr($line, 0, $start) =~ m/\$([\w:]+)\s*(->)?\s*{\s*['"]?$/) {

    $attribs->{completion_append_character} = '}';
    return $term->completion_matches($text,
                     \&perl_hash_key_completion_function);
    } elsif (substr($line, 0, $start) =~ m/\$([\w:]+)\s*->\s*['"]?$/) {

    $attribs->{completion_append_character} = ' ';
    return $term->completion_matches($text,
                     \&perl_method_completion_function);
    } else {
    $attribs->{completion_append_character} = '';
    return  $term->completion_matches($text,
                      \&perl_symbol_completion_function);
    }
}


use vars qw($i @matches);

sub perl_hash_key_completion_function ($text, $state)
{

    if ($state) {
    $i++;
    } else {

    $i = 0;
    my ($var,$arrow) = (substr($attribs->{line_buffer},
                   0, $attribs->{point} - length($text))
                =~ m/\$([\w:]+)\s*(->)?\s*{\s*['"]?$/);
    no strict qw(refs);
    $var = "${CWP}::$var" unless ($var =~ m/::/);
    if ($arrow) {
        my $hashref = eval "\$$var";
        @matches = keys %$hashref;
    } else {
        @matches = keys %$var;
    }

    }
    for (; $i <= $#matches; $i++) {
    return $matches[$i] if ($matches[$i] =~ /^\Q$text/);
    }
    return undef;
}

sub _search_ISA ($) {
    my ($mypkg) = @_;
    no strict 'refs';
    no warnings 'prototype';
    my $isa = "${mypkg}::ISA";
    return $mypkg, map _search_ISA($_), @$isa;
}

sub perl_method_completion_function ($text,$state)
{

    if ($state)
    {
        $i++;
    }
    else
    {

        my ($var, $pkg, $sym, $pk);
        $i = 0;
        $var = (substr($attribs->{line_buffer},
                   0, $attribs->{point} - length($text))
            =~ m/\$([\w:]+)\s*->\s*$/)[0];
        $pkg = ref eval (($var =~ m/::/) ? "\$$var" : "\$${CWP}::$var");
        no strict qw(refs);
        @matches = map {
                            $pk = $_ . '::';
                             grep (  /^\w+$/ && ($sym = "${pk}$_",
                                     defined *$sym{CODE}),
                                     keys %$pk
                                  );
        } _search_ISA($pkg);
    }
    for (; $i <= $#matches; $i++)
    {
        return $matches[$i] if ($matches[$i] =~ /^\Q$text/);
    }
    return undef;
}


{
    my ($prefix, %type, @keyword);

sub perl_symbol_completion_function ($text,$state)
{
    if ($state)
    {
        $i++;
    }
    else
    {

        my ($pre, $pkg, $sym);
        $i = 0;

        no strict qw(refs);
        ($prefix, $pre, $pkg) = ($text =~ m/^((\$#|[\@\$%&])?(.*::)?)/);
        @matches = grep /::$/, $pkg ? keys %$pkg : keys %::;
        $pkg = ($CWP eq 'main' ? '::' : $CWP . '::') unless $pkg;

        if ($pre) {
        @matches = (@matches,
                grep (/^\w+$/
                  && ($sym = $pkg . $_,
                      defined *$sym{$type{$pre}}),
                  keys %$pkg));
        } else {
        @matches = (@matches,
                !$prefix && @keyword,
                grep (/^\w+$/
                  && ($sym = $pkg . $_,
                      defined *$sym{CODE}
                      || defined *$sym{FILEHANDLE}
                     ),
                  keys %$pkg));
        }
    }
    my $entry;
    for (; $i <= $#matches; $i++) {
        $entry = $prefix . $matches[$i];
        return $entry if ($entry =~ /^\Q$text/);
    }
    return undef;
    }

    BEGIN {
    %type = ('$' => 'SCALAR', '*' => 'SCALAR',
         '@' => 'ARRAY', '$#' => 'ARRAY',
         '%' => 'HASH',
         '&' => 'CODE');



    @keyword = qw(
            exit quit clear ls cd chmod chown start run

            chomp chop chr crypt hex index lc lcfirst
            length oct ord pack q qq
            reverse rindex sprintf substr tr uc ucfirst
            y

            m pos quotemeta s split study qr

            abs atan2 cos exp hex int log oct rand sin
            sqrt srand

            pop push shift splice unshift

            grep join map qw reverse sort unpack

            delete each exists keys values

            binmode close closedir dbmclose dbmopen die
            eof fileno flock format getc print printf
            read readdir rewinddir seek seekdir select
            syscall sysread sysseek syswrite tell telldir
            truncate warn write

            pack read syscall sysread syswrite unpack vec

            chdir chmod chown chroot fcntl glob ioctl
            link lstat mkdir open opendir readlink rename
            rmdir stat symlink umask unlink utime

            caller continue die do dump eval exit goto
            last next redo return sub wantarray

            caller import local my package use

            defined dump eval formline local my reset
            scalar undef wantarray

            alarm exec fork getpgrp getppid getpriority
            kill pipe qx setpgrp setpriority sleep
            system times wait waitpid

            do import no package require use

            bless dbmclose dbmopen package ref tie tied
            untie use

            accept bind connect getpeername getsockname
            getsockopt listen recv send setsockopt shutdown
            socket socketpair

            msgctl msgget msgrcv msgsnd semctl semget
            semop shmctl shmget shmread shmwrite

            endgrent endhostent endnetent endpwent getgrent
            getgrgid getgrnam getlogin getpwent getpwnam
            getpwuid setgrent setpwent

            endprotoent endservent gethostbyaddr
            gethostbyname gethostent getnetbyaddr
            getnetbyname getnetent getprotobyname
            getprotobynumber getprotoent getservbyname
            getservbyport getservent sethostent setnetent
            setprotoent setservent

            gmtime localtime time times

            abs bless chomp chr exists formline glob
            import lc lcfirst map my no prototype qx qw
            readline readpipe ref sub sysopen tie tied
            uc ucfirst untie use

            dbmclose dbmopen
           );
    }
}

__END__

=pod

Before invoking, this program reads F<~/.perlshrc> and evaluates the
content of the file.

When this program is terminated, the content of the history buffer is
saved in a file F<~/.perlsh_history>, and it is read at next
invoking.

=head1 VARIABLES

You can customize the behavior of C<perlsh> by setting following
variables in F<~/.perlshrc>;

=over 4

=item C<$PerlSh::PS1>

The primary prompt string.  The following backslash-escaped special
characters can be used.

    \h: host name
    \u: user name
    \w: package name
    \!: history number

The default value is `C<\w[\!]$ >'.

=item C<$PerlSh::PS2>

The secondary prompt string.  The default value is `C<E<gt> >'.

=item C<$PerlSh::HISTFILE>

The name of the file to which the command history is saved.  The
default value is C<~/.perlsh_history>.

=item C<$PerlSh::HISTSIZE>

If not C<undef>, this is the maximum number of commands to remember in
the history.  The default value is 256.

=item C<$PerlSh::STRICT>

If true, restrict unsafe constructs.  See C<use strict> in perl man
page.  The default value is 0;

=back

=head1 FILES

=over 4

=item F<~/.perlshrc>

This file is eval-ed at initialization.  If a subroutine C<afterinit>
is defined in this file, it will be eval-ed after initialization.
Here is a sample.



    sub h { map { sprintf("0x%x", $_ ) } @_;}

    sub tk {
        $t->tkRunning(1);
        use Tk;
        $mw = MainWindow->new();
    }


    sub afterinit {
        *t = \$PerlSh::term;
        *a = \$PerlSh::attribs;
    }

=item F<~/.perlsh_history>

=item F<~/.inputrc>

A initialization file for the GNU Readline Library.  Refer its manual
for details.

=back

=head1 SEE ALSO

L<Term::ReadLine::Gnu|http://search.cpan.org/dist/Term-ReadLine-Gnu/>

L<GNU Readline Library|http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html>

=head1 AUTHOR

Hiroo Hayashi <hiroo.hayashi@computer.org>

            Main Author of the original file.
            This file is a derivitive of his 'perlsh'.

=head1 CONTRIB

Gabriel T. Sharp <21shariria@gmail.com>

=over 4

=item C<Contributing Author (not fully in circulation)
            Stored in github/osirisgothra/mini.git under eso/ubin-local/perlsh
            (If there are further notes, they would be in README.md)
            Contributed startup code additions (@INC checking, colorization,
            Data::Dumper integration, Term::ANSIColor and Path::Tiny support)
            Also added some minor program flow plus extra commands/interpreters, etc.>

=back

=head1 CONTRIB NOTES
=over 4
=item CONTRIB-NOTE perldoc (affected function)
=back
=begin text

The following code was removed from the perldoc's findfiles routine, as it is listed below. It was
a depth aware version of the current, shorter version. It is no longer being used at all because
it is for recursion under path objects to allow for deeper searches (for perldoc, etc)  but later
was deemed to be unsanitary and insecure, so it was rewritten for just top-level PATH items:

#           for my $curfile ($curpath->children())
#            {
#
#
#                print("+--scanning $curfile for [$mask]\n");
#                if ($curfile->basename() =~ /$mask/) {
#                    push(@results,$curfile) if ( $mindepth != 0 );
#                }
#                if (-d -r -x $curfile) {
#                    push(@results,findfiles($mask,$curfile,zmdec($maxdepth),zmdec($mindepth)) );       # grab these too, if depth is ok
#                }
#
#            }

Also, any "/home/xxx/..." paths may be sanitized out in a later version, should it prove a security risk. At this time, this is not
the case but that could change in the future.

=end text
=item CONTRIB-NOTE 9629 (approximate file position in characters)

=back

=begin text

        DEFERRED SIGNALS in perlipc(5):
            http://perldoc.perl.org/perlipc.html#Deferred-Signals-%28Safe-Signals%29

            The line referred by 9629 originally was:

                $SIG{INT} = sub { ... <rest of block>

            Changed to prevent crashes/noncleanups from SIGINT signals.

        These lines were changed to increase compatibility and bolster resilliance.

REMOVED CODE AND COMMENTS


1) STARTUP COMMANDS
# startup now moved to act just like typed in commands
# entered in, in fact uses the same loop and is read in
# the same way, instead of being emulated, which causes the
# no longer needed code here to be used. The reason its simpler
# is because of delegation. Delegation causes the work shifting
# to the main loop, and the reader 'shifts' a startup command off
# each time it reruns, until it is empty which eliminated the need
# for a separate loop along with a flag to indicate it was done..
# all were not even needed for the new method
# the only possible risk is security and sanitation which isnt done anymore
# except when it applies to the command line. 

# DISREGARD ALL DATA BETWEEN HERE AND...
# THIS BLOCK IS TO BE REMOVED WHEN NEW SYSTEM IS WORKING 100%
#    ### STARTUP COMMANDS TO BE INTERPRETED AT (suprise) STARTUP
#    ### these are executed as if user typed them, not the same as the environment rcfile!
#    ### warning: if you place 'exit' in the startup commands it WILL terminate the program!
#
#    my $has_startcmds = 0;
#    my $startcmds = "";
#    while ( @STARTUP_COMMANDS ) {
#        #say("entering loop: startup-commands=@STARTUP_COMMANDS");
#        $_ = pop(@STARTUP_COMMANDS);
#        #say("item found: $_");
#        $startcmds.=$_;
#        $startcmds.=";" if @STARTUP_COMMANDS;  # add ';' only if more commands are to be added
#        #say("start commands updated: $startcmds");
#
#        $has_startcmds = 1;
#    }
#    if ($has_startcmds) {
#        #say("has_startcmds=$has_startcmds: \"$startcmds\"");
#        $lastcmd_startcmd = 1;
#        return $startcmds if $has_startcmds;
#    }
#    else
#    {
#        $lastcmd_startcmd = 0;
#    }
#    ### END STARTUP COMMAND CHECK
# ...HERE

END CODE COMMENTS SECTION



REFERENCES

        perlsh(1)  original version as mentioned above
        perlpod(1) required to read this document
        perldoc(1) preferred parser for this document
        man(1)     can be used as a generic reader for this document
        vim(1)
        nano(1)    these were all used to update or write the perlpod source
        atom(1)


PERLSH - perlsh(3pm) - Perl (Modified) Shell Reference - (Read this document with perlpod, perldoc, or man reader)


=end text




=cut
