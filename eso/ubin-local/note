#!/bin/perl

use warnings;
use strict;
use v5.20.2;
use Path::Tiny;
use Time::HiRes;
use POSIX qw( floor exit );
use Getopt::Long::Descriptive;
use IO::Handle;

my ($opt, $usage) = describe_options(
    'note %o EVENT [EVENT2...]',
    [ 'probe|p', "use modprobe to temporarily enable pcspkr" ],
    [],
    [ 'verbose|v',  "print extra stuff"            ],
    [ 'help',       "print usage message and exit", { shortcircuit => 1 } ],
);

print($usage->text), exit if $opt->help;
if ( $opt->probe ) { qx(sudo modprobe pcspkr); unless(fork) { `sync`; exit; }; sleep(2); }    #1
sub spkoff() { if ( $opt->probe ) { qx(sudo modprobe -r pcspkr); };
END { spkoff(); } } #2
$SIG{"HUP"} = $SIG{"QUIT"} = $SIG{"INT"} = \&spkoff; #2
no warnings 'experimental';
use feature 'signatures';

my %xlat = (    
    "A" => "A5",
    "A#" => "A5#",
    "B" => "B5",
    "C" => "C5",
    "C#" => "C5#",
    "D" => "D5",
    "D#" => "D5#",
    "E" => "E5",
    "F" => "E5#",
    "F#" => "F5",    
    "G" => "F5#",
    "G#" => "G5",
);    
my %note = ( 
   "C3" =>    "130.81,9121",
   "C3#" =>    "138.59,8609",
   "D3" =>    "146.83,8126",
   "D3#" =>    "155.56,7670",
   "E3" =>    "164.81,7239",
   "F3" =>    "174.61,6833",
   "F3#" =>    "185.00,6449",
   "G3" =>    "196.00,6087",
   "G3#" =>    "207.65,5746",
   "A4" =>    "220.00,5423",
   "A4#" =>    "233.08,5119",
   "B4" =>    "246.94,4831",
   "C4" =>    "261.63,4560",
   "C4#" =>    "277.18,4304",
   "D4" =>    "293.66,4063",
   "D4#" =>    "311.13,3834",
   "E4" =>    "329.63,3619",
   "F4" =>    "349.23,3416",
   "F4#" =>    "369.99,3224",
   "G4" =>    "391.00,3043",
   "G4#" =>    "415.30,2873",
   "A5" =>    "440.00,2711",
   "A5#" =>    "466.16,2559",
   "B5" =>    "493.88,2415",
   "C5" =>    "523.25,2280",
   "C5#" =>    "554.37,2152",
   "D5" =>    "587.33,2031",
   "D5#" =>    "622.25,1917",
   "E5" =>    "659.26,1809",
   "F5" =>    "698.46,1715",
   "F5#" =>    "739.99,1612",
   "G5" =>    "783.99,1521",
   "G5#" =>    "830.61,1436",
   "A6" =>    "880.00,1355",
   "A6#" =>    "923.33,1292",
   "B6" =>    "987.77,1207",
   "C6" =>    "1046.50,1140"
);
my $l=250;
NEXTNOTE: while (@ARGV) {
    my $x = shift(@ARGV);    
    say("processing argument: $x");    
    if ( $x =~ /^([qwhe])(.+)/ ) {
        unshift(@ARGV,$2);
        unshift(@ARGV,$1);
        say("adding params $1 and $2 back to stack");
        next;    
    } else {
        given($x) {
            $x=1 when /q/;
            $x=2 when /h/;
            $x=4 when /w/;
            $x=0.5 when /e/;
        }
    }
    for my $y ( keys(%xlat) ) {
       $x=$xlat{$y} if ($x eq $y);        
    }        
    if ( $x =~ '^[\.0-9]+$' ) {
        $l=( int( $x * 250 ) );
        say("duration switch: $l");
    }
    elsif ( $x eq "r" ) {
        say("resting for $l");
        Time::HiRes::sleep ( $l / 1000 );
    }
    else {
        given ($x) {
            when(/([A-G]b[3-6]|[A-G][3-6]b)/) {
                say("this program does not use flats, please use the sharp equivalent (ie, use A# instead of Bb)");
            }        
            when(/([A-G])(#)([3-6])/) {
                my $oldx = $x;
                $x = $1 . $3 . $2; 
                say("corrected placement of # in $oldx to $x");
            }
        }
        say("x=$x l=$l");       
        if ( $note{$x} ) {
            say("play note: $note{$x} at $l duration");
            system("beep","-f",$note{$x},"-l",$l) and die("call failed: $! $?");
        } else { 
            die("bad note: $x\n"); 
        }
    }
}
exit(0);

# CSCS compliant on Sun 02 May 2021 05:06:43 PM EDT
#
# #1       cannot do this in a BEGIN (like we do with turning it back off) because options cannot be processed yet
#          and therefore cannot know if the bus is to be probed or not -- it is ill advised to try to self-read the arguments (not to mention, very duplicative and pointless)
#
# #2       we CAN do it here, since we already know what has happened throughout the program
#          as a plus, can be attached to a signal HUP, INT, etc
#
# #3       sync(1) could cause a large delay if not forked, and may not work at all when a large synchronous file operation
#          is currently underway --- you would have to wait until ALL data was done transfering to the devices
#          this is usually the case for transfers to/from USB devices (including USB drives, thumbdrives, SD cards, cameras, phones, etc)
#          a fork and then sync, waiting 2 seconds, always tests successful on my end, if you encounter any problems
#          just send your hw specs to the author with a detailed account for what happens.
