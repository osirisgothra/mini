#!/bin/zsh
#
#    image-dims
#    get sizes and/or format of an image or images
#    mini/eso
#    small projects and stand-alone programs or documents, esoteric or dependant
#
#    Copyright (C) 1995-2021 Gabriel T. Sharp
#
#    Written by Gabriel T. Sharp <21shariria@gmail.com>
#    Latest versions of this and all projects can be
#    obtained by visiting the repository at:
#
#    <https://github.com/osirisgothra>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#    HISTORY
#
#	 Sun 28 Feb 2021 07:11:56 AM EST
#            osirisgothra@ initially created this file
#            with the original name, image-dims
#            reached release state on same day
#
#    CSCS2020 COMPLIANCE
#
#            The Author has verfied that the file adheres to the '2020 Columnized Strict Commenting Scheme' which is
#            also known as the "2020/CSCS". This scheme requires that 1) all comments are in the form of footnotes
#            with only a refnum in the far right column. This is in an effort to join the massive need for commenting
#            your code reformation goin on all over the world, 2) footnotes are at the END of the file, beyond any
#            executable code or other footnotes. Are easy to read and spot. 3) Do not count for more than 20% of the file's size.
#            3-CODE Status: PASS PASS PASS (all 100%) A score of 80% or better is required to be 2020CSCS compliant.
#
#            [ Current score is 100% since file contains no extraneous comments -- this was tested Feb 28, 2021 and does not
#              guarentee status beyond file's state on that day it is up to author to keep compliance updated every 6 months ]
#
#  This template and header was created using the template generator by Gabriel T. Sharp
#  You can download the latest version at: <https://www.github.com/osirisgothra/mini.git/eso/ubin-local/template>
#  (the url is subject to changes on github's behalf, please submit a pull request to fix or request a fix on any url changes)
#

declare -ga opts
declare -gi quiet_level=0
declare -g version_text="$(tput setaf 124)image-dims$(tput sgr0) Version 1.0 (C)2020 Gabriel T. Sharp, Licensed under GNU LGPL3 at https://gpl.gnu.org/gpl3.html"
declare -gi width=0 height=0 colors=0
declare -g format=none filetype=none
declare -g help_text="image-dims
get sizes and/or format of an image or images

SYNTAX

	image-dims [OPTIONS] FILENAME(S) ...

OPTIONS
  --format -f   format the output
  --raw    -r   show identify raw output
  --extra  -x   show identify raw extra output
  --help   -h	show this help text
  --version-v   display version information and exit (also shows license info)
  --quiet  -q   increase quiet level by one (quiet level is always zero if left alone)

ARGUMENTS

	FILENAMES	One or more filenames that must exist and be readable by the current user.

LICENSE

	GNU LGPL3 is available in full at the GNU GPL website, or through the google voice command 'show me GNU LGPL VERSION 3'

"

qecho() {
	if [[ $quiet_level -gt 0 ]]; then
		return 127
	else
		builtin echo "$@"
	fi
}

is() {
    case $1 in
        quiet)  ((quiet_level > 0));;
      verbose)  ((quiet_level < 0));;
       normal)  ((quiet_level == 0));;
     notquiet)  ((quiet_level <= 0));;
            *)  ((quiet_level == 1));;
    esac
}
ffail() {
    echo "$0 ($(date)): ${2-general failure}(${1-2}"
    exit ${1-2}
}
setopt aliases
alias fail='fail $LINENO'
declare -gi rawmode=0 xtramode=0 fmtmode=0

if opts=( `getopt -n $0 -o rxfhvqV -l verbose,help,version,quiet,raw,extra,format -- "$@"` ); then
	eval set -- "${opts[@]}"
	while [[ $# -ge 0 ]]; do
		curopt=$1
		nextopt=${2-none}
		shift
		case $curopt in
		    --raw|-r)   rawmode=1;;
		    --extra|-x) xtramode=1;;
		    --format|-f) fmtmode=1;;
			--help|-h)	echo "$help_text"; exit 127;;
			--version|-v) echo "$version_text"; exit 127;;
            --verbose|-V) let quiet_level--;;
			--quiet|-q) let quiet_level++;;
			--) is verbose && echo "done with options";  break;;
			*)	is verbose && echo "handling option: $curopt (next:$nextopt)";;
		esac
	done
	imgcount=$#
	declare -gi curimg=0
	for arg; do
		let curimg++
		case $arg in
			*)	is verbose && echo "handling argument: $arg"
                if [[ -r $arg ]]; then
                    filetype=`mimetype -b $arg`
                    if [[ ${filetype%%/*} != image ]]; then
                        fail "$arg is not an image, this program is for images only"
                    else
                        if ((rawmode && xtramode == 0)); then
                            identify-im6 $arg
                        elif ((xtramode)); then
                            identify-im6 -verbose $arg
                        else

                            ebool() {
                                [[ $# -lt 1 ]] && fail "bad boolcond args"
                                eval "[[ $@ ]]" && echo 1 && return 0
                                echo 0; return 1;
                            }
                            fmtr() {
                                s=$?
                                [[ $1 -eq 0 ]] && { cat; return $s }
                                case $1 in
                                    1) perl -wpe 's/ (\(|\[)/\n\t\t\t\t$1/g;s/\)/\n)/g';;
                                    *) echo "unknown format mode $1 -- "; cat;;
                                esac
                            }

                            fileinfo=( `identify-im6 $arg` )
                            if [[ -r ${arg:c} ]]; then
                                inpath=true
                            else
                                inpath=false
                            fi
                            imgsize=$fileinfo[3]
                            declare -gA image=("name" $arg
                                               "basename" ${arg:t}
                                               "dir" ${arg:h}
                                               "ext" ${arg:e}
                                               "size" $fileinfo[3]
                                               "format" "$fileinfo[2] $fileinfo[5] $fileinfo[6]"
                                               "width" ${imgsize%%x*}
                                               "height" ${imgsize##*x}
                                               "colors" `identify-im6 -verbose $arg | grep -Po '(?<=Colors:\s).*'`
                                               "incmdpath" $inpath
                                               "readable" `ebool -r $arg`
                                               "writable" `ebool -w $arg`
                                               "blockdev" `ebool -b $arg`
                                               "chardev" `ebool -c $arg`
                                               "directory" `ebool -d $arg`
                                               "exists" `ebool -e $arg`
                                               "normal" `ebool -f $arg`
                                               "sgid" `ebool -g $arg`
                                               "egid_owned" `ebool -G $arg`
                                               "sticky" `ebool -k $arg`
                                               "symlink" `ebool -L $arg`
                                               "euid_owned" `ebool -O $arg`
                                               "namedpipe" `ebool -p $arg`
                                               "nonempty" `ebool -s $arg`
                                               "socket" `ebool -S $arg`
                                               "suid" `ebool -u $arg`
                                               "executable" `ebool -x $arg`
                                                )
                            [[ $imgcount -lt 2 ]] && curimgno="" || curimgno=$curimg
                            declare -p image 2>&1 | fmtr $fmtmode | perl -wpe 's/(?<=typeset -A )image/image'$curimgno'/g'
                            unset image
                        fi
                    fi
                else
                    fail "$arg is unreadable, file(s) must exist and be readable by current user (${USER-you})"
                fi
			;;
		esac
	done

else
	is notquiet && echo "error, code is $?, exiting with fail"
fi


# CSCS2020 Compliant Comments
#
# #0 this section contains any tagged comments needed
# <empty at this time>