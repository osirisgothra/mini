#!/usr/bin/perl -w
# prenote: file has UTF-8 encoding, be sure you use a compatible text viewer/editor to edit this file
#          most characters will look normal even in an incompatible editor but will encounter "garbage" wherever introducers and extended characters are used
#===============================================================================
#
#         FILE:  jrun
#
#        USAGE:  ./jrun
#
#  DESCRIPTION: a custom menu for some of my guitar-supporting apps
#	  SETTINGS: warnings(-experimental),strict
#	   VERSION: perl 5.20.2 or better (latest test: in 5.30)
#	   MODULES: Path::Tiny(c) JSON(c)		[ (c) = core modules ]
#PERL FEATURES: signatures (5.20+)
#      OPTIONS: Preferrable to use the menu, but, you can specify the program name on the command line
# REQUIREMENTS: Path::Tiny (usually distributed with perl)
#         BUGS: Static, does not self configure at this time as it is hardcoded (See Cs21k) #0
#        NOTES: - Cs21k Compliant commentting, see Cs21k at the end of the file                 
#               - This is a very, very esoteric script, its proabably not going to be what anyone else wants so before executing it make sure it does what you want --- dont expect too much out of a simple little program like this one
#       AUTHOR: Gabriel Thomas Sharp (gt), osirisgothra@hotmail.com
#      COMPANY: Paradisim NCNP (Non-Corporate, Non-Profit)
# PROG VERSION: 1.0 (using identical file version and program version per static project rules)
#     PORTABLE: LEVEL 1 (Unix styled operating systems only)
#				      - relies on xterm		- assumes user is using X-compatible window system that utilizes DISPLAY, display/desktop manager, preferrs I3 or compatible (planning to add dwm and other high-level dm support too)
#					  - uses globs			- relies on the presence of /proc filesystem, /bin, and the usual programs found inside of it
#               you /can/ use with "beginner" dwms like xfce and ubuntu/gnome, but those dont really need a program like this as they have a desktop and icons, etc (this is for a different type of workspace and workflow system)
#	PORT-LEVEL: can be ported to other unix-like operating systems that have a window manager under wayland, unity, X, etc and keep their processes in /proc
#      CREATED:  10/06/2020 10:12:03 AM
#     REVISION:  No Revisions Made
#===============================================================================
# keep package directive right here, do not put any noncomment/nonblank/nonbang before it!
package Paradisim::MiniProjects::Esoteric::User::Binaries::Local::JustRun;				# define our namespace	(resolves to git branch: git://paradisim/mini.git/eso/ubin-local/jrun;

use strict;					# keep references strict as possible (no delegation of implicit references)
use warnings;				# warnings on all other things unless specified
use v5.20.2;				# signatures are needed, this version lock supports them
no warnings 'experimental';	# allow using signatures without warnings
use feature 'signatures';	# allow using sub proc($arg,...) {} instead of sub proc { my $arg = shift, ...; }
use Path::Tiny qw(path);				# core module for handling paths in an oop sort of way
use JSON;					# this is a core module that autoselects JSON::XS, JSON::PP, JSON::?? whatever is found first
use Term::ReadKey;
use POSIX;
use Carp;
use vars qw ( @precmds @exitcmds $i3width $i3height @argv $argc $i3workspace $i3menuworkspace $i3exitworkspace $hasi3 $debugging );

confess("Term::Put required, this is a private module from github/osirisgothra/perl") unless eval "require Term::Put";
`sudo modprobe snd_emu10k1; sudo alsactl init`;

# variables

my $term = new Term::Put(); # pass nothing and let Term::Put deduce the terminal itself (via $TERM or other queries)

# subs

sub false { return (0 or (shift // 0)); }
sub true { return (1 and (shift // 1)); }
sub echo { return CORE::say(@_ > 0 ? @_ : ""); }
sub secho($sdelay,$smsg) {	echo($smsg); sleep(abs($sdelay) // 0);	} # undef will be promoted to '0'
sub findi3() { (path($_)->slurp() =~ /i3\n/ == 1 ? return 1 : 0 ) for glob "/proc/[0-9]*/comm"; return 0; }		# this is unportable <- but i3 doesnt run on any other os anyway, so its cool
sub signal_map($signal)
{
	given($signal)
	{
		csecho (1.5,"\n[SIGINT] Please use [q] to exit the program\n") when /INT/;
		csecho (1.5,"\n[CtrlZ] Please use [q] to exit, or a command to officially stop me\n") when /TSTP/;
		ReadMode("cbreak") when /CONT/;
		ReadMode("normal") when /QUIT/;
		default {
			csecho (2,"\nUnwittingly caught $signal but didnt do anything with it\n");
		}
	}
	&display_menu_text() if defined(&display_menu_text);

}
sub run_with_statusmsg($statmsg, $cmd)
{
	echo("$statmsg") unless ( $statmsg =~ /^debug-/ && $debugging == 0 );
    system($cmd);
    if ($? != 0) { die("fatal: run of $cmd failed! ($! $?)"); }
}
sub run_jackenabledapp($targetitem)
{
	printf("\nstarting the run of $targetitem... (this window will become jack monitoring status window)\n");
    run_with_statusmsg("starting jack/dbus...\n", "/usr/bin/jack_control start");
	set_i3_workspace($i3workspace,0);
    run_with_statusmsg("running $targetitem...\n", "$targetitem");
    run_with_statusmsg("stopping jack/dbus...\n", "/usr/bin/jack_control exit");
	set_i3_workspace($i3menuworkspace,0);
}
sub clear_screen()
{
     	echo("\n[1;1H[2J");	

}
sub display_menu_text()
{    
	clear_screen();
    my @menutext = (
                    "%12┏━━━━━━━━━━━━━⇛ ⋀⋀∆∶∏ ⋀⋀∈∏⋃ ⇚━━━━━━━━━━━━━━━┓",
                    "┃ ℜ rakarrack            ℮  renoise         ┃",
                    "┃ ⅁ guitarix             ℚ  quit or exit    ┃",
                    "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛",
                    "(press [r], [g], [e] or [q] to quit)"
                );
    say($term->colorize($_)) for @menutext;                
}
sub execute_menu_item($item) 
{
    $_ = $item;   

            run_jackenabledapp("/usr/bin/rakarrack") if /^r(rakarrack)?/;
            run_jackenabledapp("/usr/bin/guitarix") if /^g(uitarix)?/;
			run_jackenabledapp("/usr/local/bin/renoise") if /^e|^renoise/;
			if (/--help/) { 
			    print("usage: jrun [rakarrack|guitarix|renoise] or [r|g|e]\n");
			}
		
    if ($argv[0]) {
        `jackoff`;
        exit;
    }
    return;
}
sub get_i3_workspaces()
{
    unless ( `pgrep i3` )
    {
        return undef;;
    }
    
	my @workspaces = @{ JSON::decode_json( `i3-msg -t get_workspaces` ) };
	for my $w (@workspaces) {
		my $wsname = $$w{name};
		if ( $$w{focused} ) {
			$i3exitworkspace = $wsname;
		}
	}
}
sub set_i3_workspace($target,$movefirst)
{
	if ($hasi3) {
		if ($movefirst) {
			`/usr/bin/i3-msg move workspace \"$target\" 2>&1`;
		}
		 `/usr/bin/i3-msg workspace \"$target\" 2>&1`  ;
	}
}
sub set_window_geometry()
{
	if ($hasi3)		# TODO: add support for non-i3 wms
	{
		my @i3cmds =( 	"resize set width $i3width px &> /dev/null",
						"resize set height $i3height px &> /dev/null",
						"move position center &> /dev/null",
					);
		system("/usr/bin/i3-msg $_") for @i3cmds;
	}
}
sub read_single_key()
{
      while (1) {                                                                                                                                                                                                                                                             
		 my $char = Term::ReadKey::ReadKey(0);                                                                                                                                                                                                                                                 
         last unless defined $char;                                                                                                                                                                                                                                          
         return $char;
      }                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                              
}

# variables

$debugging = 0;
@precmds = ( "killall -SIGSTOP java 2> /dev/null 1> /dev/null" );
@exitcmds = ( "killall -SIGCONT java 2> /dev/null 1> /dev/null" );
$i3width = "579";
$i3height = "120";
@argv = @ARGV;
$argc = scalar(@ARGV);
$i3workspace = "95 GUITAR";
$i3menuworkspace = "94 GUITAR-MENU";
$i3exitworkspace = $i3menuworkspace;		#1
$hasi3 = findi3() ? 1 : 0;

# compiler

BEGIN { 
    ReadMode('cbreak'); 
}
END   { 
    ReadMode('normal'); 
}

# program

die("Requires X style window manager (NOT for windows or macos, and must be ported to distant cousins of linux") unless $ENV{DISPLAY} =~ /\A:[0-9]+(\.[0-9]+)?\z/; #5
$SIG{$_} = \&signal_map for qw( INT TSTP QUIT CONT STOP );
system($_) for @precmds;
get_i3_workspaces();
set_i3_workspace($i3menuworkspace,1);
set_window_geometry();
given ($argc) {
    when (/0/) {
        my $endit=0;
        until ($endit) {
        	`sync`;
			clear_screen();
            display_menu_text();
            my $input = read_single_key();
            chomp $input;
            given ($input) {
                $endit = 1 when /q/;
                default {
                    unless ( execute_menu_item($input) ) {
                    echo("invalid command, try again or type q to quit"); }
                }
            }
        }
    }
    when (/1/) {
        unless (execute_menu_item($argv[0])) {
            echo("unknown action: $argv[0]");
        }
    }
    default {
        echo("you must either specify a subprogram or provide no arguments to have a menu of choices given!");
        sleep(5);
        set_i3_workspace($i3exitworkspace,0);
        exit(127);
    }
} #given($argc)
set_i3_workspace($i3exitworkspace,0);
system($_) for @exitcmds;
exit(0);

#Cs21k

#0 if a config is added, this will need to be dynamic instead of static (mark is in header in case you cant find it)
#2 move to or add a configuration file (.jrunrc) if it becomes a need (at this time it is NOT needed
#3 added support for i3
#4 added support for enlightenment (bodhi linux), xfce4 (xubuntu), gnome (linux mint, debian)
#5 added DISPLAY checking to allow for multiple screens and newer wms (previously only supported old, single screen format (which is :NUM, like :0), new is :DISPLAY.SCREEN (ie, :0.0 for first display handle and first screen, dual monitor systems typically have :0.0 and :0.1 allocated)
#6 added support for non-i3 environments (not as adaptive but at least it works outside i3 now)
#7 in case true initial WorkSpaceis not found (see get_i3_workspaces)
# vim:ft=sh:ts=4:sw=4:noet:cc=160:fen:fdm=indent:fcl=all:vbs=0:nospell:tw=120:nowrap:mls=5
