#!/usr/bin/perl -w
# prenote: file has UTF-8 encoding, be sure you use a compatible text viewer/editor to edit this file
#          most characters will look normal even in an incompatible editor but will encounter "garbage" wherever introducers and extended characters are used
#===============================================================================
#
#         FILE:  jrun
#
#        USAGE:  ./jrun
#
#  DESCRIPTION: a custom menu for some of my guitar-supporting apps
#	  SETTINGS: warnings(-experimental),strict
#	   VERSION: perl 5.20.2 or better (latest test: in 5.30)
#	   MODULES: Path::Tiny(c) JSON(c)		[ (c) = core modules ]
#PERL FEATURES: signatures (5.20+)
#      OPTIONS: Preferrable to use the menu, but, you can specify the program name on the command line
# REQUIREMENTS: Path::Tiny (usually distributed with perl)
#         BUGS: Static, does not self configure at this time as it is hardcoded, see notes below.
#        NOTES: Uses Paradisim2k2 style file commenting (a very simplistic comment style that uses # as part of its notation and is numbered in the file standalone:
#               #1 if a config is added, this will need to be dynamic instead of static
#               #2 move to or add a configuration file (.jrunrc) if it becomes a need (at this time it is NOT needed
#               #3 added support for i3
#               #4 added support for enlightenment (bodhi linux), xfce4 (xubuntu), gnome (linux mint, debian)
#               #5 added DISPLAY checking to allow for multiple screens and newer wms (previously only supported old, single screen format (which is :NUM, like :0), new is :DISPLAY.SCREEN (ie, :0.0 for first display handle and first screen, dual monitor systems typically have :0.0 and :0.1 allocated)
#               #6 added support for non-i3 environments (not as adaptive but at least it works outside i3 now)
#               final note: this is a very, very esoteric script, its proabably not going to be what anyone else wants so before executing it make sure it does what you want --- dont expect too much out of a simple little program like this one
#       AUTHOR: Gabriel Thomas Sharp (gt), osirisgothra@hotmail.com
#      COMPANY: Paradisim NCNP (Non-Corporate, Non-Profit)
# FILE VERSION: 1.0
# PROG VERSION: same
#     PORTABLE: LEVEL 1 (Unix styled operating systems only)
#				      - relies on xterm		- assumes user is using X-compatible window system that utilizes DISPLAY
#					  - uses globs			- relies on the presence of /proc filesystem
#	PORT-LEVEL: can be ported to other unix-like operating systems that have a window manager under wayland, unity, X, etc and keep their processes in /proc
#      CREATED:  10/06/2020 10:12:03 AM
#     REVISION:  No Revisions Made
#===============================================================================
# keep package directive right here, do not put any noncomment/nonblank/nonbang before it!
package Paradisim::MiniProjects::Esoteric::User::Binaries::Local::JustRun;				# define our namespace	(resolves to git branch: git://paradisim/mini.git/eso/ubin-local/jrun;

use strict;					# keep references strict as possible (no delegation of implicit references)
use warnings;				# warnings on all other things unless specified
use v5.20.2;				# signatures are needed, this version lock supports them
no warnings 'experimental';	# allow using signatures without warnings
use feature 'signatures';	# allow using sub proc($arg,...) {} instead of sub proc { my $arg = shift, ...; }
use Path::Tiny qw(path);				# core module for handling paths in an oop sort of way
use JSON;					# this is a core module that autoselects JSON::XS, JSON::PP, JSON::?? whatever is found first
use Term::ReadKey;
use POSIX;
 


# note POSIX::exit == CORE::exit, no shims needed!


# keep this line after BEGIN/END and 'use' directives


# shell mockup

sub false { return (0 or (shift // 0)); }
sub true { return (1 and (shift // 1)); }
sub echo { return CORE::say(@_ > 0 ? @_ : ""); }
sub secho($sdelay,$smsg) {	echo($smsg); sleep(abs($sdelay) // 0);	} # undef will be promoted to '0'

# signal map

sub signal_map($signal)
{
	given($signal)
	{
		csecho (1.5,"\n[SIGINT] Please use [q] to exit the program\n") when /INT/;
		csecho (1.5,"\n[CtrlZ] Please use [q] to exit, or a command to officially stop me\n") when /TSTP/;
		ReadMode("cbreak") when /CONT/;
		ReadMode("normal") when /QUIT/;
		default {
			csecho (2,"\nUnwittingly caught $signal but didnt do anything with it\n");
		}
	}
	&display_menu_text() if defined(&display_menu_text);

}
$SIG{$_} = \&signal_map for qw( INT TSTP QUIT CONT STOP );
my @precmds = ( "killall -SIGSTOP java &> /dev/null" );
my @exitcmds = ( "killall -SIGCONT java &> /dev/null" );
my $i3width = "579";
my $i3height = "120";
my @argv = @ARGV;
my $argc = scalar(@ARGV);
my $i3workspace = "95 GUITAR";
my $i3menuworkspace = "94 GUITAR-MENU";
my $i3exitworkspace = $i3menuworkspace;		# in case true initial WorkSpaceis not found (see get_i3_workspaces)
sub findi3() { (path($_)->slurp() =~ /i3\n/ == 1 ? return 1 : 0 ) for glob "/proc/[0-9]*/comm"; return 0; }		# this is unportable <- but i3 doesnt run on any other os anyway, so its cool
my $hasi3 = findi3() ? 1 : 0;
die("Requires X style window manager (NOT for windows or macos, and must be ported to distant cousins of linux") unless $ENV{DISPLAY} =~ /\A:[0-9]+(\.[0-9]+)?\z/; #5
my $debugging = 0;

sub run_with_statusmsg($statmsg, $cmd)
{
	echo("$statmsg") unless ( $statmsg =~ /^debug-/ && $debugging == 0 );
    system($cmd);
    if ($? != 0) { die("fatal: run of $cmd failed! ($! $?)"); }
}
sub run_jackenabledapp($targetitem)
{
	printf("\nstarting the run of $targetitem... (this window will become jack monitoring status window)\n");
    run_with_statusmsg "starting jack/dbus...\n", "/usr/bin/jack_control start";
		#run_with_statusmsg "switching to own desktop...\n", "/usr/bin/i3-msg workspace $i3workspace";
	set_i3_workspace($i3workspace,0);
    run_with_statusmsg "running $targetitem...\n", "$targetitem";
    run_with_statusmsg "stopping jack/dbus...\n", "/usr/bin/jack_control exit";
	set_i3_workspace($i3menuworkspace,0);
		#run_with_statusmsg "restoring original WorkSpace..\n", "/usr/bin/i3-msg workspace back_and_forth";
}
sub clear_screen()
{
     	echo("\n[1;1H[2J");	# TODO #1: hard code this temporary solution

}
sub display_menu_text()
{    #1
	clear_screen();
    print(
"                ┏━━━━━━━━━━━━━⇛ ⋀⋀∆∶∏ ⋀⋀∈∏⋃ ⇚━━━━━━━━━━━━━━━┓
                ┃ ℜ rakarrack            ℮  renoise         ┃
                ┃ ⅁ guitarix             ℚ  quit or exit    ┃
                ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
                                      ");
}
sub execute_menu_item($item) {
    given ($item) {
	#2

            run_jackenabledapp("/usr/bin/rakarrack") when /r/;
            run_jackenabledapp("/usr/bin/guitarix") when /g/;
			run_jackenabledapp("/usr/local/bin/renoise") when /e/;
            default { return 0; }
    }
    return 1;
}



sub get_i3_workspaces()
{
    unless ( `pgrep i3` )
    {
        return undef;;
    }
    
	my @workspaces = @{ JSON::decode_json( `i3-msg -t get_workspaces` ) };
	for my $w (@workspaces) {
		my $wsname = $$w{name};
	#	echo(" WorkSpace$$w{name} found ");
		if ( $$w{focused} ) {
	#		echo("$wsname is focused, saving it as the return-to WorkSpace");
			$i3exitworkspace = $wsname;
		}
	}
}
sub set_i3_workspace($target,$movefirst)
{
	if ($hasi3) {
		if ($movefirst) {
			`/usr/bin/i3-msg move workspace \"$target\" 2>&1`;
		}
		 `/usr/bin/i3-msg workspace \"$target\" 2>&1`  ;
	}
}
sub set_window_geometry()
{
	if ($hasi3)		# TODO: add support for non-i3 wms
	{
		my @i3cmds =( 	"resize set width $i3width px &> /dev/null",
						"resize set height $i3height px &> /dev/null",
						"move position center &> /dev/null",
					);
		system("/usr/bin/i3-msg $_") for @i3cmds;
	}
}
sub read_single_key()
{
 #     ReadMode('cbreak');                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                             
      while (1) {                                                                                                                                                                                                                                                             
		 my $char = Term::ReadKey::ReadKey(0);                                                                                                                                                                                                                                                 
         last unless defined $char;                                                                                                                                                                                                                                          
         return $char;
         #printf(" Decimal: %d\tHex: %x\n", ord($char), ord($char));                                                                                                                                                                                                          
      }                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                              
}
# handle break modes very start/very end or signal table (next sect)

BEGIN { ReadMode('cbreak'); 

}
		system($_) for @precmds;

END   { ReadMode('normal'); 
}

############################################################################
############# MAIN PROGRAM #################################################
############################################################################

get_i3_workspaces();				# determines i3exitworkspace
#echo("exit WorkSpace is $i3exitworkspace");	# debug point


set_i3_workspace($i3menuworkspace,1);
set_window_geometry();

given ($argc) {
    when (/0/) {
        my $endit=0;
        until ($endit) {
        	`sync`;
			clear_screen();
            display_menu_text();
            my $input = read_single_key();
            chomp $input;
            given ($input) {
                $endit = 1 when /q/;
                default {
                    unless ( execute_menu_item($input) ) {
                    echo("invalid command, try again or type q to quit"); }
                }
            }
        }
    }
    when (/1/) {
        unless (execute_menu_item($argv[1])) {
            echo("unknown action: $argv[1]");
        }
    }
    default {
        echo("you must either specify a subprogram or provide no arguments to have a menu of choices given!");
        sleep(5);
        set_i3_workspace($i3exitworkspace,0);
        exit(127);
    }
}
set_i3_workspace($i3exitworkspace,0);
system($_) for @exitcmds;

exit(0);

# keep vim directives to very end
# vim:ft=sh:ts=4:sw=4:noet:cc=160:fen:fdm=indent:fcl=all:vbs=0:nospell:tw=120:nowrap:mls=5