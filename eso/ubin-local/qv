#!/usr/bin/perl
#
#   qv - a gtk2 data viewer
#   requires: perl Gtk2 bindings
#             G::L::D, Path::Tiny
#             Config::INI (my version, version 1.0.0-r20d0b9*+)
#   written by Gabriel T. Sharp
#   <osirisgothra@hotmail.com>
#   GNU GPL 3.0
#

use v5.20.2;
use warnings;
use strict;
use Path::Tiny qw(path);
use Gtk2 -init;
use Getopt::Long::Descriptive;
use Config::INI;
#use File::MimeInfo;                 #4
use feature 'signatures';
no warnings 'experimental';

my $argc = $#ARGV;                  #10
my @argv = @ARGV;
my $cache_done = 0;
my %cache;

sub get_largest(@files) {
    say("finding largest in @files :");
    say for @files;
    my @largest = ( `file @files` );
    my ($mx,$my) = (0,0); 
    for (@largest) {
        m/^(.*)(\b\d+)( x )(\d+)(.*)$/;
       my ($cx,$cy) = ($2,$4);
       $mx = $cx if $cx > $mx;
       $my = $cy if $cy > $my;
    }
    return ($mx, $my);     
}
my ($imgx, $imgy) = get_largest(@ARGV);

sub cache_mimes {

    warn("cache_mimes called when cache is already done, this should not happen!") if $cache_done;
    say("caching file data...");
    my @mimes = split("\n",`file --mime-type -n @ARGV`);
    for (@mimes) {
        my ($filename, $type) =  split(": ",$_);
        $cache{$filename} = $type;
    }
    $cache_done=1;       
    say("loading files...");    #12
}
sub mimetype($filename)
{    
    cache_mimes() unless $cache_done;    
    if ( $cache{$filename} ) {
        return $cache{$filename};
    } else {       
        return "text/plain";    #11
    }
       
}
my ($opt, $usage) = describe_options(
'qv %o <text/data1 ...>\nqv %o <media/raw1 ...>',
[],
[ 'man|m', "manpage mode" ],
[ 'verbose|v',  "print extra stuff"            ],
[ 'help',       "print usage message and exit", { shortcircuit => 1 } ],
[ 'debug|d',    "print debug messages and stderr" ],
[ 'fork|b',     "run in background/fork after gui opens, will have the side effect of making the chunking limit feature delegate to multiple windows at once instead of waiting for the next one to end" ],
);


close STDERR unless $opt->debug;
print($usage->text), exit if $opt->help;
if ($argc > 100) {
    
    say("more than 100 files, an interface will be used to show in groups of 100, close the window to show the next group
WARNING: background/fork mode will show ALL windows at once!");
    while (@ARGV) {
        my @grpitems = splice(@ARGV,0,100);
        say("showing next group of " . scalar(@grpitems));
        system($0,@grpitems);
    }
    exit();
}
#13
use Data::Dumper;


my $w=new Gtk2::Window( "GTK_WINDOW_TOPLEVEL" );
$w->set_title('Quick Viewer ' . $argc . ' Items Opened');
$w->signal_connect('delete_event' => sub($widget,$event) { Gtk2->main_quit; });
#9

$w->set_border_width(3);
$w->set_position('center_always');

my $v=new Gtk2::HBox();
my $s=new Gtk2::ScrolledWindow();
my $i=undef;
my $n=undef;

for $n (@ARGV)
{
    $n = path($n);
    no warnings 'experimental';    
    unless ( $opt->man )
    {
        if ( -r $n )  
        {
        
            given(mimetype($n)) #8
            {
                when (/image/) {
                    my $l = new Gtk2::Label();
                    my $h = new Gtk2::VBox();                   
                    say("requesting $imgx x $imgy");                    
                    $l->set_use_markup(1); #7
                    $l->set_markup
                    ("<a href=\"file://".$n->realpath()."\">" . $n->basename() . "</a>");   #6                                      
                    $i= new Gtk2::Image();
                    $i->set_from_file($n);    
                    $h->add($i);        #5
                    $h->add($l);        #5
                    $v->add($h);
                }
                default {
                    $i = new Gtk2::TextView();
                    $b = new Gtk2::TextBuffer();
                    $i->set_buffer($b);
                    $i->set_size_request(50,50);
                    $b->set_text($n->slurp());
                    $v->add($i);
                }
            }
        }
    }
    else
    {
        $i = new Gtk2::TextView();
        $b = new Gtk2::TextBuffer();
        $i->modify_font(Gtk2::Pango::FontDescription->from_string("Liberation Mono 10"));
        
        $i->set_buffer($b);
        $i->set_size_request(16,16);
        my $text = `man -7 $n |cat`;
        $b->set_text($text);
        $v->add($i);
    }            
        
}    
$s->add_with_viewport($v);
$w->add($s);
$w->set_default_size(640,480); #1
$w->show_all();
if ($opt->fork) {
    say("forking...");
    exit(0) if fork();
}
Gtk2->main();

#1 this determines the size of the entire window only
#2 remove filename from 'filename: mimetype'
#4 for some reason this incorrectly id's the files without extensions due to
#  no magic (removed in favor of system-based mimetype command)
#  update: no longer using the mimetype script, it is quite slow, instead using
#          the unbuffered 'file' program, and sending ALL filenames at once to
#          remove the choke point during file parsing, status messages are also
#           reduced to just 1 per operational chunk.
#5 add image# add text describing image
#6 anchor a URL so user can access the whole link
#  note: pango defaults to not letting clicks happen, and we only want the copy link function
#  (because I hate programs that open a browser and so on, id rather it copy the link, thats what
#  happens here, right click the link and you get a menu and choose it from there, as it should be)
#7 switch to pseudo-ml (pango) format in text                    
#8 wrap images into an HBox that has
#  a label with some markup in it, and the image itself next door to it (to the left like file managers do)                      
#9 removed:
#  note: use 'for (@_) { if (($ref))' to see what
#  $w->signal_connect('key_press_event' => sub($w,$e,$k) { say($e->keysym); });
#
#10 make local copies of (these get changed by G::L::Descriptive)
#11 failed to cache file during cache_mimes, return the fallback of text/plain (its just the data in the raw)
#12 always happens after cache, best place to put this message per the rules 
#13 dumper not needed before here, saves some time when using stuff like --help, or to prevent loading extra moduels when in batch mode
#14 used (at beginning of program) the get_largest(imagelist) to get the biggest
#   image sizes. note that the X and Y are independant, so, if you had a list
#   of images like this:
#       file1.png   16x128          2048        .02MP
#       file2.png   1440x80         115200      .12MP
#       file3.png   17x19           323         .00003MP
#       file4.png   1280x128        163840      .16MP
#   the resulting imgx/y would be:
#       1440 x 128
#   even though the actual largest
#   image (in absolute pixel count)
#   is actually:
#       1280x128
#   but as you can see, 1440x128 can contain ANY of these images
#   since the upper limits are all met.


