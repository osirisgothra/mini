#!/usr/bin/perl
#
# FILE
#    mix
#    amixer frontend - experimental
#
# PROJECT
#    mini
#	 eso/ubin-local
#
# AUTHOR / COPYRIGHT
#
#    Copyright (C) 2021, /usr/bin/perl
#
#    Written by /usr/bin/perl osirisgothra@larnica.(none)
#    Latest versions of this and all of /usr/bin/perl's projects can be
#    obtained from:
#
#     <<projbranch>>
#
#    Documentation Available At:
#
#     <http://www.github.com/osirisgothra/mini.git>
#
# LICENSE
#
#    mini/mix  is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#  NOTES
#
#     * TODO: move 'use' statements to top if you want to keep them**
#    ** this feature will be added to the next version of perltemplate (hopefully)
#   *** warnings are disabled for experimental and once because they are pretty
#       annoying here, you might want to re-enable them for your own program
#       to do this during testing and development.
#
#  HISTORY
#
#	Sat Jan 16 13:23:31 2021
#         osirisgothra@larnica.(none) created this file using the template generator 'perltemplate'
#         and named it mix for the project '<projname'.
#
#
# (created with perltemplate by Gabriel T. Sharp <osirisgothra@hotmail.com>)
#

use warnings;
use v5.18;
use strict;
no warnings "experimental";			# 	allow given/when/default and smartmatching without their warnings***
no warnings "once";					# 	allow variables to be used just once without warning***



use Term::ANSIColor 4.0  qw ( colorstrip color colored uncolor coloralias :constants colorvalid :pushpop );

sub ansi_demo()
{

    print color 'bold blue';
    print "This text is bold blue.\n";
    print color 'reset';
    print "This text is normal.\n";
    print colored("Yellow on magenta.", 'yellow on_magenta'), "\n";
    print "This text is normal.\n";
    print colored ['yellow on_magenta'], 'Yellow on magenta.', "\n";
    print colored ['red on_bright_yellow'], 'Red on bright yellow.', "\n";
    print colored ['bright_red on_black'], 'Bright red on black.', "\n";
    print "\n";

    # Strip all color escape sequences.

    print colorstrip '\e[1mThis is bold\e[0m', "\n";

    # Determine whether a color is valid.

    my $valid = colorvalid('blue bold', 'on_magenta');

    print "Color string is ", $valid ? "valid\n" : "invalid\n";

    # Create new aliases for colors.

    coloralias('alert', 'red');

    print "Alert is ", coloralias('alert'), "\n";
    print colored("This is in red.", 'alert'), "\n";
    print BOLD, BLUE, "This text is in bold blue.\n", RESET;

    # localized

    {
    	local $Term::ANSIColor::AUTORESET = 1;
    	print BOLD BLUE "This text is in bold blue.\n";
    	print "This text is normal.\n";
    }

    print PUSHCOLOR RED ON_GREEN "This text is red on green.\n";
    print PUSHCOLOR BRIGHT_BLUE "This text is bright blue on green.\n";
    print RESET BRIGHT_BLUE "This text is just bright blue.\n";
    print POPCOLOR "Back to red on green.\n";
    print LOCALCOLOR GREEN ON_BLUE "This text is green on blue.\n";

    # localized

    print "This text is red on green.\n";
    {
    	local $Term::ANSIColor::AUTOLOCAL = 1;
    	print ON_BLUE "This text is red on blue.\n";
    	print "This text is red on green.\n";
    }

    print POPCOLOR "Back to whatever we started as.\n";
}


use IPC::Open3  qw( open3 );


sub open3_demo()
{
    print "do open3 example? [y/[n]]";

    $_ = readline();
    if (/y/)
    {

    	my $pid = open3( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR, 'xcalc','-fg','red' );
    	my @handles = ( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR );
    	my($wtr, $rdr, $err);
    	use Symbol "gensym"; $err = gensym;
    	$pid = open3($wtr, $rdr, $err, 'xcalc','-fg','red' );
    	waitpid( $pid, 0 );
    	my $child_exit_status = $? >> 8;
    }
}
my $coa = 'trouble';

use Getopt::Long::Descriptive; # opt|shortchar[kind] (kind is =s[tr],=i[nt], or none)

my @coor = ( 14 );
my ($opt, $usage) = describe_options(
    '$0 %o devicename|devicenum',
    [],
    [ 'verbose|v',  "print extra stuff to stderr where appropriate"            ],
    [ 'help',       "print usage message and exit" ],
);

say($usage->text), exit if $opt->help;

## CURSES ##
use Curses::UI;

my $cui;  # Main Program Object, it must be global so accessor/menu/etc subs can see it
           # even though subs are defined inside of the same routine, subs wont be able to
           # read any function-local data, this is a closure that keeps loops from compromise.
           # an illustration of the closure:

#  GLOBAL STACK     FUNC STACK
#  +---------------+---------+ -> creates function B() but its access is still limited to global and above unless a ref was passed too
#  |     FUNC A    +    A    |
#  |     FUNC A    +    | var|
#  +---------------+---------+
#  +---------------+---------+
#  |     FUNC B    +    B    |-> tries to access cui, but if its in A how would it?
#  +---------------+---------+
#  GLOBAL STACK     FUNC STACK
#    +---------------+
# |->|     var       |
# |  +---------------+
# |    ^
# |    |
# |    | accessible!
# |    |
# | +---------------+---------+ -> creates function 'FUNC B'
# | |     FUNC A    +    A____|
# | |               +    |////| <- readable by A only
# | +---------------+---------+
# | +---------------+---------+
# -|     FUNC B    +    B     |-> tries to access var, and can because its global
#  +---------------+----------+

my $file = undef;
my $statusbar_showing = 0;
my $statusbar_text = "I am some status text";
sub exit_dialog()
{
    my $return = $cui->dialog	(	-message   => "Do you really want to quit?",
	    							-title     => "Are you sure?",
		    						-buttons   => ['yes', 'no'], );
    exit(0) if $return;
}

sub __cmain()
{
    say("curses: entering setting");

    my $debug = 0;  #1=yes 0=no
    $cui = Curses::UI->new( -color_support => 1, -clear_on_exit => 1, -debug => $debug, ); # this is where we gloss over setting up all the widgets and data structures + start the event loop

    # menu subs

    sub help_contents_act
    {
        $cui->dialog("Contents: Nothing!");
    }
    sub about_dialog
    {
        while(1) {
        my $yes = $cui->dialog( 	-message => "Template Program v1.0", -buttons => [
            {   -label    => '< About The Author >',
                -value    => 191,
                -onpress  => undef,
                -shortcut => 'o', }
        ,
        "ok"], -values  => [1,0], -title   => "About", );
        given($yes) {
            when (191)
            {
                $cui->dialog( 	-message => "The Author of this program seems like a nice enough person!", -buttons => ["ok"], -values  => [1,0], -title   => "About Author", )
            }
            default
            {
                return;
            }
        }
        }
    }
    sub open_dialog
    {
        $file = $cui->filebrowser(	-path => "/dev/snd", -show_hidden => 0, );

        # Filebrowser will return undef if no file was selected.

        if (defined $file)
        {
            unless (open F, "<$file")
            {
                # do something with file
                close F;
            }
            else
            {
                $cui->error(qq(Error opening "$file":\n$!));
            }
        }
    }
    sub undo_act
    {
        # todo: undo something
    }
    sub redo_act
    {
        # todo: redo something
    }
    sub next_act
    {
        # todo: next something
    }
    sub prev_act
    {
        # todo: previous something
    }
    sub statusbar_act
    {
        $statusbar_showing ^= 1;   # toggle it
        $cui->status($statusbar_text) if $statusbar_showing;
        $cui->nostatus unless $statusbar_showing;
    }
    sub toolbar_act
    {
        $cui->error("It's toolbar has yet to be completed!");

    }
    sub progress_act
    {
        $cui->progress( -max => 10, -message => "Counting 2 seconds...", );
        for my $second (0..2)
        {
            $cui->setprogress($second);
            sleep 1;
        }
        $cui->noprogress;
    }

    my @menu = (

                { -label => 'Mixer',
                  -submenu => [{        -label => 'Open...'     ,     -value => \&open_dialog  },
                               {        -label => 'Exit      ^Q',     -value => \&exit_dialog  }],
                },
                { -label => 'Controls',
                  -submenu => [{        -label => 'Undo      ^U',     -value => \&undo_act  },
                               {        -label => 'Redo'        ,     -value => \&redo_act  }],
                },
                { -label => 'Search',
                  -submenu => [{        -label => 'Find      F3',     -value => \&find_dialog  },
                               {        -label => 'Replace   F4',     -value => \&replace_dialog  }],
                },
                { -label => 'View',
                  -submenu => [{        -label => 'Statusbar ^S',     -value => \&statusbar_act  },
                               {        -label => 'Toolbar   ^T',     -value => \&toolbar_act }],
                },
                { -label => 'Device',
                  -submenu => [{        -label => 'Previous   PGUP',     -value => \&prev_act  },
                               {        -label => 'Next       PGDN',     -value => \&next_act  }],
                },
                { -label => 'Help',
                  -submenu => [{        -label => 'Contents   F1',     -value => \&help_contents_act  },
                               {        -label => 'About'        ,     -value => \&about_dialog  }],
                },

                );
    $cui->add( 'menu','Menubar', -menu => \@menu, -fg => "blue",);
    $cui->mainloop;
}

__cmain();


