#!/usr/bin/perl
#    eb
#    extensive batches of files autonomous select-edit program
#    firecode		1992-98
#	 gxbase			1999-2010
#	 autox			2011-2017
#	 mini-eso-ubin	2018
#	
#    Selects, presents, edits, and possibly updates external
#    programs if needed when done. New features are documented
#    in history. Please see note 2 below for information concearning
#	 the evolution of this program!!
#
#    Copyright (C) 2003-2016 Paradisim Enterprises, LLC
#
#    (Please see the end of this text for revision history)
#
#    Written by Gabriel T. Sharp <osirisgothra@hotmail.com>
#    Latest versions of this and all other projects can be
#    obtained by visiting <https://github.com/osirisgothra>
#
#    seasonal mirrors (subject to availability and uptime):
#
#    home-run servers:   <http://paradisim.twilightparadox.com>
#    corporate hosted:   <http://paradisim.tk>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#    REVISION HISTORY
#
#	Fri Apr  6 17:54:14 EDT 2018
#		Created on Linux larnica 4.2.0-22-generic #27-Ubuntu SMP Thu Dec 17 22:57:08 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
#       with the name 'HOME/bin/eb' destined to link 'MASTER:[devel|release]/mini/eso/ubin-local' by osirisgothra@larnica
#

# notes
# 1 - this is the superceded version of eb, originally a MS-DOS batch
#     file in 1992, then a windows batch file (1996-98), then a powershell
#     batch file (until 2008), crossed over into linux in 2010 as first a
#     posix-compliant sh, and then bash script (2010-18). It has now become
#     a Perl 5 (5.020.000) script (*maybe* compatible with at least 5.013.000)
#     with a loose (disappearing) dependence on the system's shell. It is planned
#     to be cross platform at some time during it's new presence in perl.
# 2 - this script is no longer part of gxbase or autox, instead it is part of the
#     very decentralized 'mini' project with esoteric subprojects. since many of 
#     these project do not relate to one another, and tend to be small, they are
#     combined into a general, single project called 'mini'. This file belongs to
#	  the 'eso/ubin-local' subculture. It can always be downloaded from github.
# 3 - many distributions of linux (and cygwin), and some macos extensions, supply
#     a link in /usr/bin/editor or /etc/alternatives/editor -- these are checked
#     last, before this the nonstandard HOME/bin/editor link is checked, and then
#     firstly, the EDITOR environment variable is checked. If there is a $editorpath
#     specified inside this script, and it is found first, it is used above all others
#     if you dont like this, make $editorpath=Path::Tiny->rootdir.
# 4 - the listing of files has a pause for which the user can read it, but there is less
#	  time needed for reading this list if less files are in it, and, the probability
# 	  is high that a long list would ever want to get read entirely. For this reason
#	  threshold and wait values are declared so that the pause can be not annoyingly long
#     or short depending on how many things are in the list. The file listing takes
#     both editing and creating files into consideration in its counts. This mechanism
#	  uses two variables to calculate the time to wait:
# 		my $threshold_file_wait = 6;	
#			how many files influence waiting for user to read
#		my $threshold_time_wait = 4;	
#			the max number of seconds from the 0-threshold, and beyond, in seconds, the program should ever wait for user to read the file list
#	  so in the above example, up to a list of 6 files will be considered, each file
#     added to the list will be (4/6) seconds long (about 0.6 seconds), and, the max
#     time wait will be '4' seconds (at 6 files), any file listing greater than 6 files
#     long will still only get 4 seconds, you can, of course change this but be careful
#     with the file_wait number, if it is too high you could be waiting a loooong time to read the list!


# VERSION

use v5.20.2;

# PRAGMAS

use strict;
use warnings;

# PACKAGES

use POSIX qw( floor ceil );
use Getopt::Long::Descriptive;
use Term::ANSIColor qw( :constants );
use Cwd qw! cwd !;
use Path::Tiny qw! path !;
use File::Temp;

# PROTOTYPES

use subs 'sleep';
use subs qw( print nprint say );

# CONSTANTS

use constant DEBUG_MODE => 0;
use constant POD_COMPLETE => 0;	# todo: complete perl documentation
use constant TRUE => 1;
use constant FALSE => 0;
use constant ON => "ON";
use constant OFF => "OFF";
use constant YES => 1;
use constant NO => 0;

# DIRECTIVES

use warnings "redefine";

# VARIABLES

my $prefix = Path::Tiny->rootdir;					# usually /, but could be /usr or /usr/local if needed
my $defbin = $prefix->child("bin");					# fallback binary location
my $temp = ( -r -w -x -d "/tmp" ? "/tmp" : cwd() ); # default to current dir if no temp found
my $path = path( $ENV{"PATH"} // $defbin );			# failsafe for possibly read-only environments
my $home = path( $ENV{"HOME"} // $temp );   				# set this way so exploits dont happen in curdir
my $editorpath = $ENV{"EDITOR"} // detect_editor($prefix) // $defbin->child("nano");
my $shmtgt = "$home/.cache/powerbash/mon";	
my $reloadflag = "$temp/.pb.reload.flag";
my $signalflag = "$home/.config/powerbash/flags/no_signal";
my $program_lang = 'en_US';				# locale_we_are_using (todo:implement it when needed)
my $program_name = 'eb';				# name of executable file (this file)
my $edit_this = $0;
my $debugging = 0;						# '1' when debugging, '0' when normal usermode
my $pdir = '/proc/'.getppid().'/comm';
my $pname = `cat $pdir`;
my $threshold_file_wait = 6;	# please read the header notes for how this is used
my $threshold_time_wait = 4;	# to estimate fairly disannoying pausing for reading

# SUBROUTINES

sub sleep 
{	
	my $timeout = shift // 1;
	CORE::sleep($timeout) if DEBUG_MODE; 
}
sub detect_editor {
	my $start = path(shift);
	return undef unless $start->exists();
	# see note 3
	
	my $altpath = $start->child("etc")->child("alternatives")->child("editor");
	my $edpatha = $start->child("usr")->child("bin")->child("editor");
	my $edpathu = $home->child("bin")->child("editor");
	# priority is: alt (update-alternatives), user binary (/usr/bin/editor), system-wide binary (/bin/editor)
	# first existing, executable path gets chosen and returned
	return $altpath if ( -r-x $altpath );
#	return $edpatha if ( -r-x $edpathu );
#	return $edpathu if ( -r-x $edpatha );	
}
sub longhelp 
{ 
	# "type perldoc $program_name for long help (for now)"
	if (POD_COMPLETE) {
		system("perldoc",$program_name);
	} else {
		nprint RED,"Sorry, long help is unavailable in this version.",RESET ;
	}
};
sub dodefault
{
	no warnings 'experimental';
	my $target = "unknown.file";
	say "using $pname as shell, editing (guessing) its configuration file as default...";

	given($pname)
	{
		when (/zsh/) 	{ $target = path($home)->child('.zshrc');	}
		when (/ksh/) 	{ $target = path($home)->child('.kshrc');	}
		when (/bash/)	{ $target = path($home)->child('.bashrc'); }	
		default 		{ $target = path($home)->child(".${pname}rc"); }
	};
	given ( -w $target )
	{
		system($editorpath,$target) when TRUE;
		system($editorpath,"~/untitled.sh") when FALSE;
	}

};

# MAIN PROGRAM

# program operation: debug pre-init

unless (DEBUG_MODE==FALSE) {
	nprint "script: $0 (args=$#ARGV, @ARGV)\n";
	nprint "environment: ";
	my $hsz = 11;
	my $lsize = int( (($ENV{COLUMNS} // 80)-$hsz) * 0.25);		# hsz: #chars reserved for the '/t'(8) and ' = '
	my $rsize = int( (($ENV{COLUMNS} // 80)-$hsz) * 0.70);		#
	nsay(GREEN, "\nlsize=$lsize rsize=$rsize hsz=$hsz\n");
	nprintf(CYAN, "\t%".$lsize."s = %".$rsize."s\n", substr($_,0,$lsize), substr($ENV{$_},0,$rsize) ) for keys(%ENV);
	nprint RESET, "";
	sleep 2;
}

# program operation: options handling
my ($opt, $usage) = describe_options(

  '$program_name %o <file>',

[ 'shut-up|U',"do not output ANYTHING (warning, this really means EVERYTHING, even errors, help, etc)" ],
[ 'check-path-first|p', "check PATH, and ~/bin last" ],
[ 'nowarnpath|N','do not warn about invalid path items' ],
[ 'no-execute-new|e', "do not make new files executable" ],
[ 'no-write-check|w', "do not check for write permissions and elevate" ],
[ 'no-exec-check|x',"make file executable if not already" ],
[ 'no-create|C',"do not create any files, edit only" ],
[ 'no-edit|E',"do not edit any files, create only" ],
[ 'user|u=s',"set owner to different user" ],
[ 'group|g=s', "set group owner to different group" ],
[ 'no-home-bin|n',"do not check ~/bin for file" ],
[ 'no-home|h',"do not check home directory if it is not in the PATH" ],
[ 'hints|H=s', "(can be 'on' or 'off') display hints when scan seem questionably empty (default is on)", { default => ON } ],
[ 'no-curdir|r', "do not check current directory if it is not in the PATH" ],
[ 'backup-count|b=i', "keep a number of (defaults to 1) backups in /tmp/eb/idx/*", { default => 1 } ],
[ 'this|t', "this file (perl script) immidiately (overrides command line)" ],
[],
[ 'verbose|v',  "print information about each step during runtime" ],
[ 'help',       "print this usage message and exit" ],
[ 'long-help',  "print the perl pod documentation for this program" ],
[ 'dryrun|d',   "perform scanning and report only, no program execution" ], );

# program operation: pre-condition checks that must be passed (and fail first two) to proceed

sub nsay { say @_ unless $opt->shut_up; }
sub nprint { print @_ unless $opt->shut_up; }
sub nprintf { printf @_ unless $opt->shut_up; }



nprint($usage->text), exit if $opt->help;
longhelp(), exit if $opt->long_help;
dodefault(), exit if (scalar(@ARGV) < 1);
# program operation: set up program's inner variables (these SHOULD NOT need to be changed for any reason!)
my $initdir = cwd();					# track where we are
my @files = @ARGV;					# GetOpt::Long::D..e took care of all but the filenames
my $elevation_preferred = 0; 		# set to 1 when a file can't be written to (but readable)
my $execution_preferred = 0;		# set to 1 when one of the files is not yet executable

# program operation: prepare data
$path =~ s/~/$home/g;				# replace shell's "~" with an actual directory so we dont rely on it [this can save you/me headache bugs down the road!]
my @paths = split(":",$path);		# split path into a list so its easier to deal with
my @editfiles = qw! !;
my @createfiles = qw! !;
my $wants_link_msg = 0;

# program operation: resolve file locations

FILELOOP: for my $file (@files)
{
	nsay "searching for detail on $file ..." if $wants_link_msg;
	nprint("~");
	$_ = $file;
	my $foundfile = 0;
	unless ($opt->no_edit)
	{		
		PATHLOOP: for my $dir (@paths)
		{
			my $loc = path($dir)->child($file);		
				
			if ( -d-r-x $dir && chdir($dir) )
			{				
				if ( ( -f-r-x $file || ( -f-r $file && $opt->no_exec_check) ) && ! -l $file && ! -d $file )
				{				
					push(@editfiles,$loc);
					nprint ".";
					nprint("+") if ( -w $file );
					$elevation_preferred = 1 unless -w $file;
					$execution_preferred = 1 unless -x $file;
					$foundfile = 1;				
					last PATHLOOP;
				}
				elsif ( -l $file )
				{
					nprint MAGENTA, "skipping $file symlink\n", RESET unless $wants_link_msg;					
				}
				else
				{
					if ( -f $file )
					{
						nsay(YELLOW ON_BLUE"\nerror: $file was found but ignored because we cannot access it\n", RESET) if $wants_link_msg;
						
						$foundfile = 1;
					}
					# else file not found so do nothing		
				}			
			}
			else
			{
				nsay(WHITE ON_RED,"\nwarning: couldnt check $dir (from your PATH) because its not readable!\n", RESET) unless $opt->nowarnpath;
			}			
		} # "for my dir (paths)
	} # "unless $opt->no_edit"
							
	unless ($foundfile)
	{
		unless ($opt->no_create) {
			nprint("*");
			my $targetdir = path($home)->child("bin");
			my $targetfile = $targetdir->child($file);
			nsay(RED ON_BLUE, "warning: no user binary folder (~/bin) i will use $initdir instead", RESET ),
				  , $targetfile = $initdir->child("bin") unless $targetdir->exists();					
			push(@createfiles,$targetfile);
			$execution_preferred = 1 unless $opt->no_execute_new;			
		}
	}
	
}

nsay RED,"looking (not editing): ",RESET if $opt->no_edit;
nsay "editing: " unless $opt->no_edit;
nsay "\t$_" for @editfiles;
nsay RED, "\t(elevation ON due to some files needing extra permissions set)",RESET if $execution_preferred;
nsay BLUE, "\thint: use -x if the file you are editing does not bear an executable permission!", RESET if @editfiles == 0 && $opt->hints eq ON;
nsay "\t<none found/specified>" unless @editfiles;
nsay "creating";
nsay "\t$_" for @createfiles;
nsay "\t<none>" unless @createfiles;
nsay BLUE, "\thint: make sure you have not specified an already-existing, non-executable (you can use -x if this is the case)", RESET if @createfiles == 0 && @editfiles == 0 && $opt->hints eq ON;
my $fcount = scalar(scalar(@editfiles) + scalar(@createfiles));
die(WHITE ON_RED,"severe: file count is $fcount (should be at least zero or more) --- this should NEVER happen, please check for a corrupted file or other system instability!", RESET) if $fcount < 0;
my $fspec = abs($fcount)==1?"file":"files";
nsay "processed $fcount $fspec.";
# see annotation above for how the waiting for user to read file listing is handled
sleep( $fcount < $threshold_file_wait ? ceil(($threshold_time_wait/$threshold_file_wait) * $fcount):$threshold_time_wait );
system($editorpath,@editfiles,@createfiles) unless $opt->dryrun;
if ($fcount) 
{
	nsay "Checking permissions on the $fspec:";
	for my $x (@editfiles, @createfiles) 
	{
		nprint RESET, "\t$x: ";
		if ( -r $x && ( ! -x $x ) ) 
		{ 
			nsay GREEN, "changing to executable", RESET; 
			path($x)->chmod("a+x");		
			
		}
		else 
		{ 
			nsay CYAN, "needs no change", RESET; 
		}
	}
}


