#!/usr/bin/env perl

use warnings;
no warnings "experimental";
use strict;
use v5.20.2;						# given/signatures/say
use feature "signatures";
use File::Slurp;
use Curses::UI;
use Path::Tiny;
use File::Spec;
use File::Config::INI;
use Getopt::Long::Descriptive; # opt|shortchar[kind] (kind is =s[tr],=i[nt], or none)

# syntax:	tg3 [process|pid] [nice] [class[[:]data]]
#           tg3 OPTIONS processids
#			tg3 OPTIONS -g process-group

# VARIABLES

my $none = "";      # for use of x//$none or also =~ when x isn't defined
my $cui = undef;    # until we have curses confirmed no init, needs global for accessor methods
my @argv = @ARGV;   # keep a copy for internal use (c style), argv
my $argc = @ARGV;   # keep a count (c style), argc
my $envp = \%ENV;   # keep a pointer to the environment table (c style)


# OPTIONS

my ($opt, $usage) = describe_options( '$0 %o [process name/id] [...]',
    [ 'no-curses|N',    "dont use curses to show status", ], [],
    [ 'verbose|v',      "print extra stuff"            ],
    [ 'help',           "print usage message and exit" ],
);

say($usage->text), exit if $opt->help;
say("$0: arguments remaining: $#ARGV");





say("curses: entering setting");
my $file;
my $debug = 0;  #1=yes 0=no
my $cui = Curses::UI->new( -color_support => 1, -clear_on_exit => 1, -debug => $debug, ); # this is where we gloss over setting up all the widgets and data structures + start the event loop
$cui->dialog("Hello, world!");
my $yes = $cui->dialog( 	-message => "Hello, world?", -buttons => ["yes","no"], -values  => [1,0], -title   => "Question", );
if ($yes) {	chomp(); } # whatever
$cui->error("It's the end of the\n"."world as we know it!");
$file = $cui->filebrowser(	-path => "/tmp", -show_hidden => 1, );
# Filebrowser will return undef if no file was selected.
if (defined $file) {    unless (open F, ">$file") {	print F "Hello, world!\n"; close F; } else { $cui->error(qq(Error on writing to "$file":\n$!)); }     }
$cui->status("Saying hello to the world..."); 		# code for saying "Hello, world!"
$cui->status("Saying goodbye to the world..."); 	# code for saying "Goodbye, world!"
$cui->nostatus;
$cui->progress( 	-max => 10, 	-message => "Counting 10 seconds...", );
for my $second (0..1) {	$cui->setprogress($second); sleep 1; }
    $cui->noprogress;
sub exit_dialog {
	my $response = $cui->dialog(
		-message => "Really Exit?",
		-buttons => ['yes','no'],
		-values => [1,0],
		-title => "Question",
		);
	exit(127) if $response;
}



my @menu = (
     { -label => 'File',
       -submenu => [
      { -label => 'Exit      ^Q', -value => \&exit_dialog  }
                   ]
      },
   );
$cui->addmenu(\@menu);
$cui->mainloop;
## END CURSES ##

## ANSI* ##
use Term::ANSIColor 4.0  qw ( colorstrip color colored uncolor coloralias :constants colorvalid :pushpop );
# color
print color 'bold blue';
print "This text is bold blue.\n";
print color 'reset';
print "This text is normal.\n";
print colored("Yellow on magenta.", 'yellow on_magenta'), "\n";
print "This text is normal.\n";
print colored ['yellow on_magenta'], 'Yellow on magenta.', "\n";
print colored ['red on_bright_yellow'], 'Red on bright yellow.', "\n";
print colored ['bright_red on_black'], 'Bright red on black.', "\n";
print "\n";
# Strip all color escape sequences.
print colorstrip '\e[1mThis is bold\e[0m', "\n";
# Determine whether a color is valid.
my $valid = colorvalid('blue bold', 'on_magenta');
print "Color string is ", $valid ? "valid\n" : "invalid\n";
# Create new aliases for colors.
coloralias('alert', 'red');
print "Alert is ", coloralias('alert'), "\n";
print colored("This is in red.", 'alert'), "\n";
print BOLD, BLUE, "This text is in bold blue.\n", RESET;
# localized
{
	local $Term::ANSIColor::AUTORESET = 1;
	print BOLD BLUE "This text is in bold blue.\n";
	print "This text is normal.\n";
}
print PUSHCOLOR RED ON_GREEN "This text is red on green.\n";
print PUSHCOLOR BRIGHT_BLUE "This text is bright blue on green.\n";
print RESET BRIGHT_BLUE "This text is just bright blue.\n";
print POPCOLOR "Back to red on green.\n";
print LOCALCOLOR GREEN ON_BLUE "This text is green on blue.\n";
# localized 
print "This text is red on green.\n";
{
	local $Term::ANSIColor::AUTOLOCAL = 1;
	print ON_BLUE "This text is red on blue.\n";
	print "This text is red on green.\n";
}
print POPCOLOR "Back to whatever we started as.\n";
## END ANSI ## 

## OPEN3 ##
print "do open3 example? [y/[n]]";
$_ = readline();
if (/y/) {
	use IPC::Open3  qw( open3 );
	my $pid = open3( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR, 'xcalc','-fg','red' );
	my @handles = ( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR );	
	my($wtr, $rdr, $err);
	use Symbol "gensym"; $err = gensym;
	$pid = open3($wtr, $rdr, $err, 'xcalc','-fg','red' ); 
	waitpid( $pid, 0 );
	my $child_exit_status = $? >> 8;
}
## END OPEN3 ##

## PATH ##
use Path::Tiny;
# creating Path::Tiny objects
print("for this to work, must have /tmp/foo.txt and /tmp/foo/bar.txt first, attempt will be made to create them...");
sleep(1);
my $data1 = `ls -l /`;
my $data2 = `ls /etc`;
path('/tmp/foo/bar.txt')->spew($data1);
path('/tmp/foo.txt')->spew($data2);
my $dir = path("/tmp");
my $foo = path("foo.txt");
my $subdir = $dir->child("foo");
my $bar = $subdir->child("bar.txt");
# stringifies as cleaned up path
$file = path("./foo.txt");
say $file; # "foo.txt"
# reading files
my $guts = $file->slurp;
$guts = $file->slurp_utf8;
my @lines = $file->lines;
@lines = $file->lines_utf8;
my ($head) = $file->lines( {count => 1} );
my ($tail) = $file->lines( {count => -1} );
say "head";
say $head;
say "tail";
say $tail;
say "write data...";
# writing files
my @data = qw ( sample data );
$bar->spew( @data );
$bar->spew_utf8( @data );
# reading directories
for ( $dir->children ) { say("children: $_"); }
my $iter = $dir->iterator;
while ( my $next = $iter->() ) { say("iterated: $next"); }
## PATH END ##


