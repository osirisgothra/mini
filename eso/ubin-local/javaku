#!/bin/zsh
# if we dont have a term, somehow tell the user to use its new incantation
if [[ $1 == FORCE_YOU_TO_DO_IT_ANYWAY ]]; then
	echo "DANGER: entered forceful override mode"
else
	if tty -s; then
		echo "depreciated, please use topicku"
		printf "Press Any Key To Terminate Script."
		read -sk1
	else
		echo "no term, attempting to run topicku in compatibility mode"
		if `which topicku`; then
			if topicku --javaku-compat-mode "$@"; then
				rc=$?
				echo "ok ($rc)"
				exit $rc
			else
				rc=$?
				echo "failed to run topicku, falling through (code=$rc)"			
			fi
		fi
		echo "failed to run topicku (last error code was: $rc, pipeline: ${pipestatus-no pipeline code available}"
		echo "using desktop (if possible) to write log so user knows it failed"
		desktopdir=`xdg-user-dir DESKTOP`
		statuslog="$(mktemp -d ${desktopdir-/dev/null}/javaku_depreciated_README.log)"
		if [[ -w $statuslog ]]; then
			echo "writing status log to $statuslog"
			echo "user ${UID}:${GID} on $HOST $(date): javaku ($0) depreciated, you need to install/run topicku instead (it was not found so you should include it in your PATH if you wish for compatibility or programs that rely on it to run" >> $statuslog
		else
			echo "FAILED BUT NOBODY KNOWS" > /tmp/failed-to-run-javaku-its-depreciated-use-topicku.important.txt		
		fi
	
	fi
	exit $rc
fi

# javaku
# java launch-kill-uni-launcher
#
# summary:
# general purpose launcher<>instance handler to start the launcher,
# monitor it, and wait for it to start a process with a specific command line
# (aka the keyword) and then kills the launcher when it is identified
#
# Important notes:
#
# Not intended for more than one process of the same name on a system.
# This also means multiple users will not be able to use it since that would
# cause multiple instances of the same process name.
#
# Requirements:
#
# Requires zsh and zsh-common, which are not always installed on barebones
# linux distributions.
#
# you can get zsh on *ubuntu by using apt:
#  apt-get install zsh zsh-common
#
# Todo:
# 0 Despecialize script code, it will become topicku (short for topic kill unit)
#   step 1: trade java refs for topic_binary
#   step 2: ??? <- step 2 relies on step 1 being completed!
#   step 3: forget this todo, instead keep as is, write a new despecialized 
#           program on the side.
# 'until replacement topicku is written, that is'
# 1 Write the indifference code (right now designed for single-user,
#   single instance situations)
# 2 Add multi-configs in javakurc and specifying parameters for use:#
#   javaku mylauncher
#
#
#   <-begin .javakurc sample->
#   # launcher sample text for .javakurc
#   # in todo section does nothing
#   [mylauncher]
#   keyword=myprog
#   topic=my program run from my launcher
#   maxusers=1  ; default behavior
#   maxprocs=1  ;
#   [mc]
#   keyword=LiteLoader
#   topic=Modded Minecraft
#   maxusers=5   ; killed after more than 5 users
#   maxprocs=2   ; killed after more than 2 processes (per user)
#   [openx]
#   keyword=ox_instance
#   topic=OpenX Desktop
#   ..etc..
#   <-end .javakurc sample->
#
#   This is currently possible by making a copy and saving as a
#   different name.
#
# How to use:
#
#  1 set startup to the FULL path to your jarfile (dont forget .jar!)
#  2 set 'topic' to a "friendly" name for the program to refer to when
#    writing messages about the program's launcher and the program
#  3 set 'topic_keyword' to a UNIQUE set of characters in the LAUNCHED
#     processes (NOT the launcher) so it can be identified and not killed
#     note that all launchers will be killed so be careful. however, no
#     programs matching 'topic_keyword' will be killed
# ku_none is for 'idle' and 'none' but is same as fastest its just syntactic sugar
# i/o priorities (for 'realtime' and 'best-effort' only, and only for unix compatible systems)
ku_none=0
ku_fastest=0
ku_fast=1
ku_faster=2
ku_norm=3
ku_slower=4
ku_slow=5
ku_slowest=6

# obviously for debugging
ku_debug=0

# set these to identify the startup jarfile, the launcher + the instance alias
# and + keyword to find the main instance after the launcher has started it
# all match-against items use regular expression language for matching (perl regex syntax)
# see perlreref(3perl) for details on how to use perl 5's regex.

# USUAL CASES
#
# topic 				what to call the process of interest when displaying output
# topic_binary			executable file to run -- if binary is not in a directory specified in $PATH, you must also supply the absolute path to that executable
# topic_startup			additional arguments to pass along with $topic_binary, these must be in a zsh array, and use quotes if spaces are in the items, though, it is recommended to use quotes always for clarity's sake.
# topic_keyword 		keyword used to single out the process of interest
# topic_disposition		when the process is found, who do we carry the task out on
# topic_relation		how disposition items relate to one another
# topic_user			name/UID of user that owns the disposition items and topic item (also can be 'parent-owner', or, 'any')
# topic_group			group/GID of the user that owns the disposition items and topic item (also can be 'any', or, 'user')
# topic_renice			number from -20 to 19 (19=least priority) indicating how much priority to give the topic_topic_ process
# topic_renice_threads	same as above, but for topic's threads
# topic_ionice_group	can be 'idle' 'realtime' 'best-effort' or 'none'
# topic_ionice_priority a number from 0 to 7 indicating priority over others of the same class (for 'realtime' and 'best-effort' only!)
#                       you can use a number or one of the 'ku_xxx' variables defined above
# topic_kill_rightaway	keep this at 0 to prevent immediate unconditional kill without the pkill prewait timeout (below, next section)

#
# SPECIAL CASES++
#
# topic_kill_rightaway				1=ignore pkill_prewait_secs entirely  0*=normal operation
#									keep this at 0 to prevent immediate unconditional kill without the pkill prewait timeout (below, next section)
# topic_immediate_kill_tollerance   0=disable (always normal operation) 1+=second-start-threshold to disregard the kill timeout from above
#
# footnotes:
#  * zero (0) is the usual value, but any value that is not 1 will work the same as 0, but will yield a warning in case it was accidental somehow
#  + seconds can be 1 or more, this value is checked when the match is made, and if the the seconds the script has been running is less
#    than this number or equal, topic_kill_rightaway will be locked into a value of '1' for the remainder of the script's run, this does
#    not count for subsequent runs, they do not carry over in any way unless invoked interactively where $SECONDS would stay the same. 
#    obviously if done incorrectly could cause problems in interactive mode so it is recommended to not do such practices and keep the
#    script exclusive to execute mode not interactive mode (so variables, etc dont end up conflicting with the user's environment variables)
# ++ these special cases usually dont need changed because they are setup internally depending on other variables. If the script doesnt
#    work the way you like, you should change those other variables first, as long as you know what you are doing.
#
# CLEANUP
#
# WARNING: This feature misused can cause SEVERE loss to your files, do not use it unless
#          you know exactly what you are doing, no safeguards are in place to protect from
#          losses, this is your responsibility alone. The author is not liable for any damages 
#          from using this script's features.
#
# Optional cleanup can be done before topics are analized, in a specified location or
# list of locations, with a list of files or a mask of filenames recognized by zsh(1).
# You can disable this feature by setting 'topic_cleanup_disable' to a non-zero value.
# The variables controlling cleanup are:
#
# topic_cleanup_dir
# 	 one or more directories to clean up.
#
# topic_cleanup_cmd
#   one or more programs in which will be given the filenames, usually just '/bin/rm'
#   but you can also do supply stuff for backing up files or shredding them prior to
#   deletion, or just move them to an offline location, etc.
#
# topic_cleanup_mask
#  filemask(s) to send along to the program at runtime, these will be evaluated by zsh(1)
#  and the time of execution (not at startup!).
#
# topic_disable
#  set to 0 to enable cleanup operations, or to 1 (or any other value) to disable entirely
#  having it set to '1' is the default.
# uncomment this line to self-debug (dont believe the syntax checker, its seldom correct)
#set -x
topic="minecraft-modded-forge"
topic_binary="java"
topic_startup=( "-jar" "$HOME/lm.jar" )
topic_keyword="minecraftforge"
topic_disposition="children-of-topic"
topic_relation="siblings"
topic_user="parent-owner"
topic_group="any"
topic_renice_method="preset"
topic_renice_preset="minecraft"
topic_renice="0"
topic_ionice_group="none"
topic_ionice_priority="$ku_none"
topic_ionice_additional_processes=( "Xorg" "xorg" "kwin_x11" "kwin" "plasmashell" )
topic_service_kill=( )
topic_process_kill=( )
topic_kill_rightaway=0
# when empty, no cleanup is done
topic_cleanup_dir=( )
topic_cleanup_mask=( "*.log" "*.log.lck" )
topic_cleanup_cmd=( "/usr/bin/shred -v -z" "/bin/rm -fv" )
topic_cleanup_disable=1
topic_cleanup_disableso=1
topic_cleanup_force_internal_decho=1
topic_pkill_kind="KILL"

#
# TERMINAL ABORT
#

# Wait for Startup Timeout Enabled for X Terminals Only
# The program after starting the topic, waits for the topic to launch the target, and then once it is launched
# and verified, terminates the topic in question. This sometimes may take a while (either user input or system performance).
# For situations where the user may be waiting for a terminal used to become available again (either stuck or not),
# a timeout is programmed in (which can be changed below, it is usually not useful to set to more than a minute or two).
# This enables timeout abort for situations where the user may be waiting for their terminal to become available again
# some wms pipe output from background to a console tty or something else, so those are probably not being waited on
# since this is an X application, the user is likely waiting on a ptmx terminal, so it is enabled for that only.
# The default timeout (abort time) is about 2 minutes and 15 seconds, including lag or load.
case ${(L)TTY} in
	/dev/tty[0-9]*)		jku_useabort=0;;	# console
	/dev/pt*)			jku_useabort=1;;	# x terminal
	not?a?tty)			jku_useabort=0;;	# pipe
	*)					jku_useabort=0;;	# unsupported/other
esac



#
# COMMAND LINE
#

boolstat=( disabled enabled )
TTY=$(tty 2> /dev/null)
case $DISPLAY in
	:*)	echo "screen verified";;
	 *) echo "invalid display ${DISPLAY-NONE}, please start under X"; exit;;
esac

# KDE relies on DBUS and other services a great deal. It also is one of the environments where the topics
# usually function fine without intervention. Should the user want to, they can use -kde flag to signal
# that they are in kde and do not wish to employ special measures other than starting the topic program.
if [[ $1 == -kde ]] || [[ $KDE_FULL_SESSION == true ]]; then
	# emulate echo -ne out of habit, but -e is never needed with print
	setopt aliases
	disable pushln
	disable hash
	alias echo='() { [[ $1 == -ne ]] && { shift; set -- -n "$@"; };  print -P "$@"; }'
	echo "running in kde, disabling optimized mode and running barebones..."
	if ! pgrep -f '^java$'; then
		echo -n "setting nvidia settings..."
		nvidia-tweak && echo "ok" || echo "unfulfilled"
		echo -n "attempting to start java..."
		java -jar ~/MyM-Launcher.jar &> /dev/null & disown
		echo "errors=$?  status=${pipestatus-ok} instances=$(pgrep java | wc -l)"
		echo "[1;34mreminder: dont close the main mym task when in kde unless you intend to need to restart each time per modpack![0m"
	else
		echo "already have at least one java instance, will not run another until this one is ended"
		exit 127
	fi
	exit 0
fi


if [[ $1 =~ ^--?k(ill-first)? ]]; then
	shift
	killall -KILL $topic_binary
	exec "$0" "$@"
	# execution transfers to ^^
	echo "error transferring process ($?)"
	exit $?
fi

if [[ $1 == "--nokill" ]] || [[ $1 == "--nk" ]]; then
	topic_nokill=1
	shift
else
	topic_nokill=0
fi

function postkillstuff()
{
	if ((topic_nokill)); then
		echo "in nokill mode, will not postkill anything"
		return
	fi
	if [[ -x `which thrgrep` ]]; then
		# things done after topic was found and its owner killed
		case ${topic_renice_method-explicit} in
		explicit)
				thrgrep $topic_binary $topic_renice $topic_ionice_group $topic_ionice_priority
				for ap in $topic_ionice_additional_processes; do
					thrgrep $ap $topic_renice $topic_ionice_group $topic_ionice_priority
				done;;
		preset)
				thrgrep $topic_renice_preset
				;;
		*)		echo "WARNING: INCORRECT topic_renice_method: $topic_renice_method -- not doing any renicing!"
				;;
		esac
	else
		echo "thrgrep >= 1.0.0 not found, no renicing will be performed"
	fi
	echo "service kills: $topic_service_kill"
	sudo systemctl stop "${topic_service_kill[@]}"
	echo "service kills done (systemctl returned: $?)"
	echo "process kills: $topic_pkill_kind $topic_process_kill"
	for pkt in "${topic_process_kill[@]}"; do
		echo -ne "killing instances of $pkt because we are configured to do so..."
		if sudo pkill -${topic_pkill_kind}  "$pkt" &> /tmp/pkillme; then
			echo "ok"
		else
			echo "failed"
			echo "error text (if any): $(cat /tmp/pkillme)"
		fi
	done
	echo "process kills done (pkill returned: $?)"
}
function cleanup()
{
	local c=80
	echo "$0 start ($SECONDS)"
	local start=$SECONDS
	#local function decho() { builtin echo "$*"; }
	if [[ $topic_cleanup_disable == "0" ]]; then
		decho "beginning cleanup operations"
		for tdir in $topic_cleanup_dir; do
			decho "in $tdir"
			# danger: topic_cleanup_cmd is not checked for validity and could contain harmful code (be sure to check variables!)
			for tcmd in $topic_cleanup_cmd; do
				cmd=( $(eval builtin echo $tcmd) )
				decho "CMD: ${tcmd: 0:$c}"
				for tmask in $topic_cleanup_mask; do
				decho "MASK: $tdir/$tmask"
					cfiles=( $(eval builtin echo $tdir/$tmask) ) 2>/dev/null
					decho "FILES: $cfiles"
					if [[ -n $cfiles ]]; then
						for tcfile in $cfiles; do
							decho "execute: [$tcmd $tcfile]"
							eval $tcmd $tcfile
						done
					else
						decho "there is no files for mask: $tmask"
					fi
				done
			done
		done
	fi
	echo "$0 all done, $(( SECONDS-start )) secs"
}

# stuff that shouldn't need changed
# but can be if you dont like the behavior
pkill_prewait_secs=5
retries=5
waitforcnt=2
retrydelay=2.5
abort_timeout_min=2
abort_timeout_sec=15
runbg=0

# stuff that never needs changed
# dont touch these if you dont know what you're doing!
ku_assert_kernel='(GNU.?)?[lL]inux'
ku_version="javaku-1.0.1a"
ku_assert_platform='x86.64|i[3-5]86'
execution_stage=startup
abort_timeout=$(( ( abort_timeout_min * 60 )+abort_timeout_sec ))
topic_immediate_kill_tolerance=$pkill_prewait_secs
help_text='
Usage:   topicku [OPTION]...
   or  <topic>ku [OPTION]...

Current binary(topic): $topic_binary($topic)

Start the topicku launcher script.

  -k, --killfirst  kill topic first before running
  -b, --background
                  start in background, no messages will be given in this state
  -v, --verbose   output diagnostic messages
  -h, --help     display this help and exit
  -V, --version  output version information and exit

PE mini/esoteric online help: <http://mini.github.io/javaku>
Full documentation at: <http://mini.github.io/javaku>
or available locally via: info "(mini) javaku invocation"
'

function assert()
{
	arg=${1-none}
	dat=${2-none}
	shift $#
	case $# in
		0)
			if [[ $arg == none ]] || [[ $dat == none ]]; then
				echo "internal error: assert used with bad parameters: arg=$arg dat=$dat"
				echo "syntax: assert <arg> <dat>"
				echo "you must specify both <arg> and <dat> when calling an assert"
				exit 122
			else
				case $arg in
					zsh_version)
						# nb: dat = 5.1.2 -> maj = 5 -> rv = 1.2 -> rev = 1 -> min = 2
						maj=${dat%%.*}
						zmaj=${ZSH_VERSION%%.*}
						if [[ $zmaj -ge $maj ]]; then
							return 0
						else
							echo "assert fail: $maj < $zmaj in version, abort"
							exit 122
						fi
						;;
					*)
						echo "assert fail: assert called with $arg which is unknown"
						exit 122
						;;
				esac
			fi
			;;
		*)
			echo "assert failed: extra parameters, $# extra arguments present on the command line ($@)"
			exit 122
			;;
	esac
}

# overrides builtin echo
# also checks for debugging if it is on, then it uses the appropriate format
function echo()
{
	if [[ "$1" != "-ne" ]] && [[ "$1" =~ ^- ]]; then
		builtin echo "FATAL: echo specified in an unsupported manner, all echo commands MUST use the -ne flag only"
		builtin echo "this error is fatal because the syntax for the function is incorrect - you must correct the syntax before proceeding with this script"
		sleep 2
		read -sk1 "Press a key to exit"
		exit 127
	fi
	if decho -on; then
		if [[ "$1" == "-ne" ]]; then
			shift
			# shifting required here because the ne mode is to be continued or
			# started from the command line
			if [[ $echo_ne_on == 1 ]]; then
				# a "continuation" (and continuing) of a line started with ne, to continue the -ne mode
				builtin echo -ne "$*"
			else
				# a "starting" the ne mode (no prior ne mode started) to be continued by next echo
				builtin echo -ne "$(date +"[%X %x]:")($?,${PIPESTATUS- 0},$SECONDS) $*"
				echo_ne_on=1
			fi
		elif [[ $echo_ne_on == 1 ]]; then
			# "continuation" (and ending) of a line that was started with -ne, ending the -ne mode
			# shifting not needed because this is not an -ne itself, just a continuation and ending
			builtin echo "$*"
			echo_ne_on=0
		else
			# not a "continuation" or a "starting" of the -ne mode
			builtin echo "$(date +"[%X %x]:")($?,${PIPESTATUS- 0},$SECONDS) $*"
		fi
	else
		if [[ $1 =~ ^-[ne][ne]? ]]; then
			echoflag="$1"
			shift
			builtin echo $echoflag "[$SECONDS]: $*"
			echo_ne_on=1
		else
			if ((echo_ne_on)); then
				builtin echo "$@"
			else
				builtin echo "[$SECONDS]: $*"
			fi
			echo_ne_on=0
		fi
	fi
}
# decho [debug message]
# decho -on
# first form sends a message, if debugging is enabled
# second form queries if a debug message would be sent out
# (this is done because other situations are anticipated in the future so it is a redundant feature that will soon have
#  a greater purpose and implementation would be a needless pain later on)
function decho()
{
	if [[ ${(U)ku_debug} =~ (1|Y(ES)?|T(RUE)) ]]; then
		if [[ $1 == "-on" ]]; then
			return 0
		fi
		if [[ $TERM =~ (linux|xterm|konsole) ]]; then
			echo "DEBUG: [1;36m$*[0m"
		else
			echo "DEBUG: $*"
		fi
	else
		if [[ $1 == "-on" ]]; then
			return 1
		fi
	fi
}

# SANITY CHECKS

assert zsh_version 5
# PRE-RUN CLEANUP (topic_cleanup_disable checked internally)
cleanup

# ARGUMENTS
declare -a opts
# NB: never put - in argnames (ie: "--some-item") will break this loop
#     this is not handled because the program is never planning for such arguments
#     due to size and small number of arguments
if [[ $1 == skiprun ]]; then
	echo "running in background"
else
if opts=( `getopt -n $(basename $0) -o hbVv -l version,verbose,background,help -- "$@"` ); then
	for opt in "${opts[@]}"; do
		[[ $opt == "--" ]] && break
		decho "found argument: $opt"
		o=${opt##*-}
		case ${o} in
			k|killfirst) echo "killing first";
				killall -KILL $topic_binary;;		
			V|verbose) ku_debug=1;;
			v|version) echo "$ku_version"; exit 0;;
			h|help)	echo "$help_text"
			exit 0
			;;
			b|background) runbg=1
			;;
			*) echo "fatal: unhandled argument: $o"
			exit 122
			;;
		esac
	done
	decho "finished argument processing"
else
	decho "failed to process arguments ($?): $@"
	exit 122
fi	# MAIN PROGRAM
	if [[ $runbg -eq 1 ]]; then
		echo "starting $0 in background [all other messages hidden]"
		$0 skiprun &> /dev/null & disown
		exit 0
	fi
fi

case $(pgrep -xa $topic_binary | wc -l) in
	0) # start anew
		decho "starting new launch of $topic..."
		decho "target binary executed: $topic_binary"
		decho "passing $topic arguments: $topic_startup"
		echo "starting topic $topic_binary"
		( $topic_binary $topic_startup &> /dev/null & disown ) &> /dev/null
		echo "started $topic_startup with pipestatus=${pipestatus-ok} returned=${?-ok}"
		if ((topic_nokill)); then
			echo "running in topic_nokill mode, no more to do (no scan needed)"
			execution_stage=pidkill
		else
			decho "entering execution stage: wait(formore)"
			execution_stage=waitformore
		fi
		;;
	1) # single ongoing process
		if pgrep $topic_binary -xa | grep -q $topic_keyword; then
			decho "single process found and identified as $topic"
			echo "nothing to do! exiting..."
			exit 0
		else
			echo "single process found, but not $topic, switching to wait mode..."
			execution_stage=waitformore
		fi
		;;
	*) # many processes ongoing
		decho "multiple processes found, going right into scan mode..."
		execution_stage=skipwait
		;;
esac
if [[ $execution_stage == waitformore ]]; then
	echo "waiting for more processes to start..."
	while [[ $(pgrep -xa $topic_binary | wc -l) -ne $waitforcnt ]]; do
		sleep 2
		if [[ $jku_useabort -eq 1 ]]; then
			if [[ $SECONDS -ge $abort_timeout ]]; then
				echo "abort timeout reached, doing just that!"
				exit 122
			fi
		fi
	done
fi

execution_stage=scan

while [[ $execution_stage != pidkill ]]; do
	pgrep $topic_binary -xa | {
		while read r; do
			procn=`grep '^[0-9]+' -Po <<< "$r"`

			decho "against: ${r: 0:20}"
			decho "rule: $topic_keyword"
			decho "procn: $procn"

			if [[ $r =~ $topic_keyword ]]; then
				if [[ $execution_stage != pidkill ]]; then
					echo "found $topic: $procn"
					if [[ $SECONDS -le $topic_immediate_kill_tolerance ]]; then
						topic_kill_rightaway=1
					fi
					decho "now entering stage: intermediate"
					execution_stage=intermediate
				fi
			else
				decho "found non-$topic process: $procn"
				if [[ $execution_stage == scan ]]; then
					decho "stage is still scan, deferring process until scan complete"
				else

					decho "non-$topic process killable, terminating $procn now..."
					killok=0
					if	[[ $topic_kill_rightaway -ne 1 ]];   then
						[[ $topic_kill_rightaway -ne 0 ]] && echo "warning: topic_kill_rightaway was set to a nonzero value that is not 1, it is ignored (it must be 1 to be recognized) please recheck your code to ensure it is correct."
						sleep $pkill_prewait_secs
					fi
					kill -SIGKILL $procn && killok=1
					if [[ $killok -eq 1 ]]; then
						echo "killed $procn ok"
						echo "performing postkill stuff..."
						postkillstuff
						echo "finished"
						execution_stage=pidkill
					else
						echo "failed to kill $procn"
						let retries--
						[[ $retries -ne 1 ]] && s="s" || s=""
						[[ $retrydelay -ne 1 ]] && t="s" || t=""
						echo "trying $retries more time${s}"
						if [[ $retrydelay -gt 0 ]]; then
							decho "in $retrydelay second${t}..."
							sleep $retrydelay
						else
							decho "immediately (retry delay was $retrydelay)"
						fi
						if [[ $retries -lt 1 ]]; then
							echo "failed to kill reached limit, aborting..."
							execution_stage=pidkill
						fi
					fi
				fi
			fi
		done
	}
done
