#!/bin/zsh

# javaku
# java launch-kill-uni-launcher

#
# summary:
# general purpose launcher<>instance handler to start the launcher,
# monitor it, and wait for it to start a process with a specific command line
# (aka the keyword) and then kills the launcher when it is identified
#
# Important notes:
#
# Not intended for more than one process of the same name on a system.
# This also means multiple users will not be able to use it since that would
# cause multiple instances of the same process name.
#
# Requirements:
#
# Requires zsh and zsh-common, which are not always installed on barebones
# linux distributions.
#
# you can get zsh on *ubuntu by using apt:
#  apt-get install zsh zsh-common
#
# Todo:
#
# 1 Write the indifference code (right now designed for single-user,
#   single instance situations)
# 2 Add multi-configs in javakurc and specifying parameters for use:#
#   javaku mylauncher
#
#   <-begin .javakurc sample->
#   # launcher sample text for .javakurc
#   # in todo section does nothing
#   [mylauncher]
#   keyword=myprog
#   topic=my program run from my launcher
#   maxusers=1  ; default behavior
#   maxprocs=1  ;
#   [mc]
#   keyword=LiteLoader
#   topic=Modded Minecraft
#   maxusers=5   ; killed after more than 5 users
#   maxprocs=2   ; killed after more than 2 processes (per user)
#   [openx]
#   keyword=ox_instance
#   topic=OpenX Desktop
#   ..etc..
#   <-end .javakurc sample->
#
#   This is currently possible by making a copy and saving as a
#   different name.
#
# How to use:
#
#  1 set startup to the FULL path to your jarfile (dont forget .jar!)
#  2 set 'topic' to a "friendly" name for the program to refer to when
#    writing messages about the program's launcher and the program
#  3 set 'topic_keyword' to a UNIQUE set of characters in the LAUNCHED
#     processes (NOT the launcher) so it can be identified and not killed
#     note that all launchers will be killed so be careful. however, no
#     programs matching 'topic_keyword' will be killed

# i/o priorities (for 'realtime' and 'best-effort' only, and only for unix compatible systems)
ku_fastest=0
ku_fast=1
ku_faster=2
ku_norm=3
ku_slower=4
ku_slow=5
ku_slowest=6

# obviously for debugging
ku_debug=0

# set these to identify the startup jarfile, the launcher + the instance alias
# and + keyword to find the main instance after the launcher has started it
# all match-against items use regular expression language for matching (perl regex syntax)
# see perlreref(3perl) for details on how to use perl 5's regex.

# USUAL CASES
#
# topic 				what to call the process of interest when displaying output
# topic_binary			executable file to run -- if binary is not in a directory specified in $PATH, you must also supply the absolute path to that executable
# topic_startup			additional arguments to pass along with $topic_binary, these must be in a zsh array, and use quotes if spaces are in the items, though, it is recommended to use quotes always for clarity's sake.
# topic_keyword 		keyword used to single out the process of interest
# topic_disposition		when the process is found, who do we carry the task out on
# topic_relation		how disposition items relate to one another
# topic_user			name/UID of user that owns the disposition items and topic item (also can be 'parent-owner', or, 'any')
# topic_group			group/GID of the user that owns the disposition items and topic item (also can be 'any', or, 'user')
# topic_renice			number from -20 to 19 (19=least priority) indicating how much priority to give the topic_topic_ process
# topic_renice_threads	same as above, but for topic's threads
# topic_ionice_group	can be 'idle' 'realtime' 'best-effort' or 'none'
# topic_ionice_priority a number from 0 to 7 indicating priority over others of the same class (for 'realtime' and 'best-effort' only!)
#                       you can use a number or one of the 'ku_xxx' variables defined above
# topic_kill_rightaway	keep this at 0 to prevent immediate unconditional kill without the pkill prewait timeout (below, next section)

#
# SPECIAL CASES++
#
# topic_kill_rightaway				1=ignore pkill_prewait_secs entirely  0*=normal operation
#									keep this at 0 to prevent immediate unconditional kill without the pkill prewait timeout (below, next section)
# topic_immediate_kill_tollerance   0=disable (always normal operation) 1+=second-start-threshold to disregard the kill timeout from above
#
# footnotes:
#  * zero (0) is the usual value, but any value that is not 1 will work the same as 0, but will yield a warning in case it was accidental somehow
#  + seconds can be 1 or more, this value is checked when the match is made, and if the the seconds the script has been running is less
#    than this number or equal, topic_kill_rightaway will be locked into a value of '1' for the remainder of the script's run, this does
#    not count for subsequent runs, they do not carry over in any way unless invoked interactively where $SECONDS would stay the same. 
#    obviously if done incorrectly could cause problems in interactive mode so it is recommended to not do such practices and keep the
#    script exclusive to execute mode not interactive mode (so variables, etc dont end up conflicting with the user's environment variables)
# ++ these special cases usually dont need changed because they are setup internally depending on other variables. If the script doesnt
#    work the way you like, you should change those other variables first, as long as you know what you are doing.
#
# CLEANUP
#
# WARNING: This feature misused can cause SEVERE loss to your files, do not use it unless
#          you know exactly what you are doing, no safeguards are in place to protect from
#          losses, this is your responsibility alone. The author is not liable for any damages 
#          from using this script's features.
#
# Optional cleanup can be done before topics are analized, in a specified location or
# list of locations, with a list of files or a mask of filenames recognized by zsh(1).
# You can disable this feature by setting 'topic_cleanup_disable' to a non-zero value.
# The variables controlling cleanup are:
#
# topic_cleanup_dir
# 	 one or more directories to clean up.
#
# topic_cleanup_cmd
#   one or more programs in which will be given the filenames, usually just '/bin/rm'
#   but you can also do supply stuff for backing up files or shredding them prior to
#   deletion, or just move them to an offline location, etc.
#
# topic_cleanup_mask
#  filemask(s) to send along to the program at runtime, these will be evaluated by zsh(1)
#  and the time of execution (not at startup!).
#
# topic_disable
#  set to 0 to enable cleanup operations, or to 1 (or any other value) to disable entirely
#  having it set to '1' is the default.
#

topic="minecraft-modded-forge"
topic_binary="java"
topic_startup=( "-jar" "$HOME/lm.jar" )
topic_keyword="minecraftforge"
topic_disposition="children-of-topic"
topic_relation="siblings"
topic_user="parent-owner"
topic_group="any"
topic_renice="-12"
topic_ionice_group="realtime"
topic_ionice_priority="$ku_fastest"
topic_kill_rightaway=0
topic_cleanup_dir=( "$HOME/tw2" )
topic_cleanup_mask=( "*.log" "*.log.lck" )
topic_cleanup_cmd=( "/usr/bin/shred -v -z" "/bin/rm -fv" )
topic_cleanup_disable=0
topic_cleanup_disableso=0

function cleanup()
{
	echo "running $FUNC..."
	FATAL() { local c=${1-255}; echo "$FUNCNAME($c) ${*-unknown}"; echo "exiting with code $c"; exit $c; }
	if [[ $topic_cleanup_disableso == 0 ]]; then
		# allows for internal testing of cleanup()
		if ! whence decho; then
			decho() { echo "(internal/testing): $@"; }
		fi
		# allows for use in a stand-alone environment (mainly for testing/revising)
		case $# in
			0)	: ;;
			3)	topic_cleanup_cmd=( $( eval echo $1 ) )
				topic_cleanup_dir=( $( eval echo $2 ) )
				topic_cleanup_mask=( $( eval echo $3 ) )
				topic_cleanup_disable=0
				;;
			*)	echo "$FUNCNAME error: must be exactly 3 arguments or 0 arguments!"
				exit 127
				;;
		esac
	else
		whence decho ||	FATAL 249 "decho missing"
	fi
	if [[ $topic_cleanup_disable == "0" ]]; then
		decho "beginning cleanup operations"
		for dir in $topic_cleanup_dir; do
			decho "in $dir"
			for cmd in $topic_cleanup_cmd; do
				cmd=( $(eval echo $cmd) )
				decho "for cmd $cmd"
				for mask in $topic_cleanup_mask; do
					decho "with mask $mask"
					cfiles=( $(eval echo $dir/$mask) )
					if [[ -n $cfiles ]]; then
						decho "performing $cmd on $cfiles"
						for cfile in $cfiles; do
							decho "running $cmd $cfile"
							$cmd $cfile
						done
					else
						decho "there is no files for mask: $mask"
					fi
				done
			done
		done
	fi
}



# stuff that shouldn't need changed
# but can be if you dont like the behavior
pkill_prewait_secs=5
retries=5
waitforcnt=2
retrydelay=2.5
abort_timeout_min=5
abort_timeout_sec=30
runbg=0

# stuff that never needs changed
# dont touch these if you dont know what you're doing!
ku_assert_kernel='(GNU.?)?[lL]inux'
ku_version="javaku-1.0.1a"
ku_assert_platform='x86.64|i[3-5]86'
execution_stage=startup
abort_timeout=$(( ( abort_timeout_min * 60 )+abort_timeout_sec ))
topic_immediate_kill_tolerance=$pkill_prewait_secs
help_text='
Usage: javaku [OPTION]...
Start the javaku launcher script.

  -b, --background
                  start in background, no messages will be given in this state
  -v, --verbose   output diagnostic messages
  -h, --help     display this help and exit
  -V, --version  output version information and exit

PE mini/esoteric online help: <http://mini.github.io/javaku>
Full documentation at: <http://mini.github.io/javaku>
or available locally via: info "(mini) javaku invocation"
'

function assert()
{
	arg=${1-none}
	dat=${2-none}
	shift $#
	case $# in
		0)
			if [[ $arg == none ]] || [[ $dat == none ]]; then
				echo "internal error: assert used with bad parameters: arg=$arg dat=$dat"
				echo "syntax: assert <arg> <dat>"
				echo "you must specify both <arg> and <dat> when calling an assert"
				exit 122
			else
				case $arg in
					zsh_version)
						# nb: dat = 5.1.2 -> maj = 5 -> rv = 1.2 -> rev = 1 -> min = 2
						maj=${dat%%.*}
						zmaj=${ZSH_VERSION%%.*}
						if [[ $zmaj -ge $maj ]]; then
							return 0
						else
							echo "assert fail: $maj < $zmaj in version, abort"
							exit 122
						fi
						;;
					*)
						echo "assert fail: assert called with $arg which is unknown"
						exit 122
						;;
				esac
			fi
			;;
		*)
			echo "assert failed: extra parameters, $# extra arguments present on the command line ($@)"
			exit 122
			;;
	esac
}

function echo()
{
	if decho -on; then
		builtin echo "$(date +"[%X %x]:")($?,${PIPESTATUS- 0},$SECONDS) $*"
	else
		builtin echo "[$SECONDS]: $*"
	fi
}
function decho()
{

	if [[ ${(U)ku_debug} =~ (1|Y(ES)?|T(RUE)) ]]; then
		if [[ $1 == "-on" ]]; then
			return 0
		fi
		if [[ $TERM =~ (linux|xterm|konsole) ]]; then
			echo "DEBUG: [1;36m$*[0m"
		else
			echo "DEBUG: $*"
		fi
	else
		if [[ $1 == "-on" ]]; then
			return 1
		fi
	fi
}

# SANITY CHECKS

assert zsh_version 5
# PRE-RUN CLEANUP (topic_cleanup_disable checked internally)
cleanup

# ARGUMENTS
declare -a opts
# NB: never put - in argnames (ie: "--some-item") will break this loop
#     this is not handled because the program is never planning for such arguments
#     due to size and small number of arguments
if [[ $1 == skiprun ]]; then
	echo "running in background"
else
if opts=( `getopt -n $(basename $0) -o hbVv -l version,verbose,background,help -- "$@"` ); then
	for opt in "${opts[@]}"; do
		[[ $opt == "--" ]] && break
		decho "found argument: $opt"
		o=${opt##*-}
		case ${o} in
			V|verbose) ku_debug=1;;
			v|version) echo "$ku_version"; exit 0;;
			h|help)	echo "$help_text"
			exit 0
			;;
			b|background) runbg=1
			;;
			*) echo "fatal: unhandled argument: $o"
			exit 122
			;;
		esac
	done
	decho "finished argument processing"
else
	decho "failed to process arguments ($?): $@"
	exit 122
fi	# MAIN PROGRAM
	if [[ $runbg -eq 1 ]]; then
		echo "starting $0 in background [all other messages hidden]"
		$0 skiprun &> /dev/null & disown
		exit 0
	fi
fi

case $(pgrep -xa $topic_binary | wc -l) in
	0) # start anew
		decho "starting new launch of $topic..."
		decho "target binary executed: $topic_binary"
		decho "passing $topic arguments: $topic_startup"
		( $topic_binary $topic_startup &> /dev/null & disown ) &> /dev/null
		decho "entering execution stage: wait(formore)"
		execution_stage=waitformore
		;;
	1) # single ongoing process
		if pgrep java -xa | grep -q $topic_keyword; then
			decho "single process found and identified as $topic"
			echo "nothing to do! exiting..."
			exit 0
		else
			echo "single process found, but not $topic, switching to wait mode..."
			execution_stage=waitformore
		fi
		;;
	*) # many processes ongoing
		decho "multiple processes found, going right into scan mode..."
		execution_stage=skipwait
		;;
esac
if [[ $execution_stage == waitformore ]]; then
	echo "waiting for more processes to start..."
	while [[ $(pgrep -xa java | wc -l) -ne $waitforcnt ]]; do
		sleep 2
		if [[ $SECONDS -ge $abort_timeout ]]; then
			echo "abort timeout reached, doing just that!"
			exit 122
		fi
	done
fi

execution_stage=scan

while [[ $execution_stage != pidkill ]]; do
	pgrep java -xa | {
		while read r; do
			procn=`grep '^[0-9]+' -Po <<< "$r"`

			decho "against: ${r: 0:20}"
			decho "rule: $topic_keyword"
			decho "procn: $procn"

			if [[ $r =~ $topic_keyword ]]; then
				if [[ $execution_stage != pidkill ]]; then
					echo "found $topic: $procn"
					if [[ $SECONDS -le $topic_immediate_kill_tolerance ]]; then
						topic_kill_rightaway=1
					fi
					decho "now entering stage: intermediate"
					execution_stage=intermediate
				fi
			else
				decho "found non-$topic process: $procn"
				if [[ $execution_stage == scan ]]; then
					decho "stage is still scan, deferring process until scan complete"
				else

					decho "non-$topic process killable, terminating $procn now..."
					killok=0
					if	[[ $topic_kill_rightaway -ne 1 ]];   then
						[[ $topic_kill_rightaway -ne 0 ]] && echo "warning: topic_kill_rightaway was set to a nonzero value that is not 1, it is ignored (it must be 1 to be recognized) please recheck your code to ensure it is correct."
						sleep $pkill_prewait_secs
					fi
					kill -SIGKILL $procn && killok=1
					if [[ $killok -eq 1 ]]; then
						echo "killed $procn ok"
						execution_stage=pidkill
					else
						echo "failed to kill $procn"
						let retries--
						[[ $retries -ne 1 ]] && s="s" || s=""
						[[ $retrydelay -ne 1 ]] && t="s" || t=""
						echo "trying $retries more time${s}"
						if [[ $retrydelay -gt 0 ]]; then
							decho "in $retrydelay second${t}..."
							sleep $retrydelay
						else
							decho "immediately (retry delay was $retrydelay)"
						fi
						if [[ $retries -lt 1 ]]; then
							echo "failed to kill reached limit, aborting..."
							execution_stage=pidkill
						fi
					fi
				fi
			fi
		done
	}
done
