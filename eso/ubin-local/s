#!/bin/bash
#
#  tsa (original name, uses aliases to determine browser function)
#
#  Author:
#    Gabriel T. Sharp <osirisgothra@hotmail.com>
#
#  Copyright (C)2013-2014 Paradisim Enterprises, LLC (http://paradisim.twilightparadox.com)
#
#  (Re)created on Sat Oct 2 11:03:17 EDT 2017, 
#  Last Major Update on Sat Oct 28 11:03:56 EDT 2017
#
#  This library is free software; you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as
#  published by the Free Software Foundation; either version 2.1 of the
#  License, or (at your option) any later version.
#
#  This library is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with this library; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
#   Revision History
#   Date                                    Revision Name/Number            User Who Revised
#   _______________________________________________________________________________________________
#
#   Sun Nov  6 18:18:52 EST 2016            Initial Creation                osirisgothra@larnica
#   Sat Oct 28 11:13:03 EDT 2017            Annual Review                   osirisgothra@larnica
#	Fri Mar 30 15:12:42 EDT 2018			Annual Review					osirisgothra@larnica**
#
#  ** = reached by osirisgothra@hotmail.com <or> internalinsomnia@gmail.com <or> 21shariria@gmail.com
#  

if [[ $1 == --makelinks ]]; then
	echo "MAKELINK MODE PRESS A KEY TO MAKE THEM IN $PWD -- CTRL-C ABORTS"
	echo "OLD LINKS WILL BE OVERWRITTEN SO PLEASE BACKUP FIRST!"
	read -sn1
	echo "creating links in $PWD..."
	( for x in G Q T U f g i l m o q r t; do [[ -r $x ]] && echo "yep $x" || echo "nope $x";  for y in d g h i; do [[ -r $x$y ]] && echo "yep $x$y" || echo "nope $x$y"; done; [[ -r $x ]] && echo "yep $x$y" || echo "nope $x$y"; done ) | grep -Po '(?<=nope ).*' | while read r; do ln -s "$PWD/t" "$PWD/$r"; done
	echo "done (rv=$?, ps=$PIPESTATUS)"
	exit 122
fi


# DOCUMENTATION/
#
# ABOUT
#
# tsa is a drop in replacement for /gxbase/bin/t with extra features
# and its original ms-dos 'goo.exe'
# searches (the web) or other things depending on it's
# configuration which is below
#
# the (script, or $0) program name determines it's function
# much like dash in a startup shell installer. You should however
# not make copies of this script, but softlink it whenever possible
# except on non-softlinkable filesystems such as FAT partitions which
# may be pre-formatted on many USB and flash drives still even now.
# It is recommended that you format these to ext2 or ext4 when you get them.
#
# DEFAULTS
#
# script name defaults
#    first letter
#       primary function (also known as the 'translator')
#    second letter
#       search modifier (simply known as the 'modifier')
#
# extra letters will not be considered, so only add them for visual aid purposes
# (ie, you have loc instead of lo for locate, perhaps because you already have hi and dont want to mislead users)
#
# NOTE
#  i wouldn't bother hardlinking, because it makes it too difficult to
#  let users know which is the original and could lead to all the files
#  becoming invalid if the wrong original were to be accidently deleted!
#  (even though 't' is the default, it could just as easily be 'g')
# IMPORTANT
#  for 'translators':
#  make sure shell-special chars are DOUBLE ESCAPED (esp ;<>()[]!*?&!!) I MEAN IT,
#  DOUBLE ESCAPED (else the evaluator will resolve it before it gets to cmdline!)
# NB
#  about 'Z' below, the '/' in '/$0' isnt a typo, it is there to ensure that Z == '/' if no $0 exists, otherwise no name would be
#
# REVISIONS
#
#  thus far, two annual revisions have been done, and a few intermediate changes as well. officially in 2018 this project will now
#  become a subpart of the autox-extras project
# /DOCUMENTATION

if [[ $BG_EXEC == 1 ]]; then
	TMPFILE="$(mktemp)"
	echo "ALERT: BG_EXEC asked for, starting in BACKGROUND (even for help)"
	echo "any errors diverted to: $TMPFILE"
	env BG_EXEC=0 "$0" "$*" 2> "$TMPFILE" 1> /dev/null &
	disown
	case $- in
	      *i*) return;;
		*) exit;;
	esac
elif [[ $BG_EXEC == 254 ]]; then
	echo "got successful background-run code, proceeding as that..."
	export IN_BACKGROUND=1
else
	export IN_BACKGROUND=0
	export BG_EXEC=0
fi

Z="$(eval basename\ /$0)"

#+------------------------------------------------------------------------------------------------------------------------------+
#| CONFIG SETTINGS[e]      | below; all                                                                                         |
#| add custom browsers/pro-| non r-o vars                                                                                       |
#| grams/searchtext here   | are described!                                                                                     |
#+------------------------------------------------------------------------------------------------------------------------------+
#| setting[e]              | means to use ...                                                                                   | [e: 2]
#+------------------------------------------------------------------------------------------------------------------------------+
#| start_in_background     | 'coproc' to run process (no wait)    [h][g]                                                        |
#| remove_from_jobcontrol  | 'bg' plus 'disown' to run detached[a][h]                                                           |
#| use_exec      		   | 'exec' turns process over to browser [h]                                                           |
#| translators      	   | hashtable that links script prefix[b] to binary and its arguments to get passed in first           |
#| modifiers      		   | hashtable that translates script suffix into specific command line argument suffix[b]              |
#| default_translator      | pointer to default[c] entry in 'translator'                                                        |
#| default_modifier        | pointer to default[c] entry in 'modifiers'                                                         |
#| loop_and_prompt[g :3]   | runs in an infinite loop prompting for arguments between or after runs[d]                      |
#| colorful_logo[i]        | was prepared and used breifly in 2016, but later disabled, see note [i]
#+------------------------------------------------------------------------------------------------------------------------------+
# footnotes [a]: detached means reassigned to parent's PID (PPID)
#           [b]: prefix and suffix are in script's name and should use symbolic links to configure them (softlinks!)
#			[c]: defaults are used when no alternatives could be satisfied - usually happens when scriptname is improper
#           [d]: these values are boolean as in: 0 is FALSE, ANYOTHERNUMBER is TRUE <- evaluated by (( )) operator
#           [e]: conditions are later translated into condition codes, but conditions are not yet in the cmdline so change them
#			  2:  here if you have a preference to use them!
#           [g]: for execution modifiers (first 3 and last 1) THE ORDER OF PRIORITY IS FIRST TO LAST, TOP TO BOTTOM (the items farther
#             2: up the list take precedence over the latters, see the case statement on how. loop_and_prompt works only if all others
#             3: are set to false (0)
#		    [i]: removed in 2017 annual review and cleaned up and filed as perma-comment in 2018 in preparation for tsa-python
#                option exists only for portability (it WILL be in the ported to python, multi-platform version)
#
# at the moment these settings (4 of them) are not stackable, but, in the future they can be easily converted to
# or added to the stack, this ensures that the routine is stack-ready:

case $# in
	0)
		declare -ig loop_and_prompt=1;;
	*)
		declare -ig loop_and_prompt=0;;
esac
if [[ "$1" == "LOOPACCESS" ]]; then
	# caught to deal with loop's calls
	shift
	start_in_background=1
	remove_from_jobcontrol=1
	use_exec=0
	loop_and_prompt=0
fi

declare -ig colorful_logo=0
declare -ig start_in_background=0
declare -ig remove_from_jobcontrol=0
declare -ig use_exec=0
#declare -g LOGO_RENDERED="$(mktemp)"
declare -gA translators=( [t]='links2'  [T]='links2 -g' [f]='firefox' [g]='firefox' [G]='chromium-browser' [l]='locate' [i]='find' [o]='xombrero' [U]='surf' [m]='midori' [r]='safari' [q]='konqueror' [Q]='rekonq' )
declare -gA modifiers=( [g]='http://www.google.com/search?q=%s' [d]='http://www.duckduckgo.com/?q=%s+!' [h]='http://www.github.com/%s' [i]='http://www.google.com/search?tbm=isch&ie=ISO-8859-1&hl=en&source=hp&biw=&bih=&q=%s&btnG=Search+Images&gbv=1' )
declare -g default_translator=t
declare -g default_modifier=g
declare -a tmps=( "/tmp/toolie.X.logo" )
#for ((q=0;q<45;q++)); do
#  tmps=( "${tmps[@]}" "/tmp/toolie.$q.logo" )
#done

#if [[ $1 == -rmtmp ]]; then
#        echo "removing animation render files, if any..."
        # NB use -f b/c we dont want errors if FNF
#        rm -f ${tmps[@]} && echo "ok!"
#        rm -f ${LOGO_RENDERED} && echo "removed ansimation file(s)"
#        echo "see you soon..."
#        exit 2
#fi

# if ! [[ -r ${LOGO_RENDERED} ]]; then
#	for tmp in "${tmps[@]}"; do

        #echo "" > $tmp
PROGNAME="$0 ($(basename $(realpath tsa)))"
PROGVERS="3.1"
PROGDESC="browser search engine launcher"
DATEHI="1995"
DATELO="2017"
AUTHOR="Gabriel T. Sharp"
EMAIL="osirisgothra@hotmail.com"
LICKIND="GNU GPL v2.1"
        msg="\\n[0;1;36m$PROGNAME v$PROGVERS - $PROGDESC\\n"
        msg+="(C)$DATEHI-$DATELO $AUTHOR <$EMAIL$>\\n"
        msg+="\\n"
        msg+="[0;36mLicensed under the $LICKIND license\\n"
        msg+="\\n"
        msg+="[0;34mYou should have received a copy of the GNU Lesser General Public\\n"
        msg+="License along with this library; if not, write to the Free Software\\n"
        msg+="Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\\n"
        msg+="[0m\\n"
##        for ((x=0;x<${#msg};x++)); do  # <<= see note [i]
##	       char=${msg:x:1}
##	        printf "[48;5;%s;38;5;1%sm" "${RANDOM:2}" "$[ ( ${RANDOM:1:1} * 1) + 4]" >> $tmp
##    	    case ${msg:x:2} in
##        	        '\n')   printf '\n' >> $tmp; let x++; continue;;
##        	esac
##        	printf '%c' "$char" >> $tmp
##        done
##fi
##	done
##	declare -i CNT=0
##	# prepare 5 lines
##	{
##	echo -e "\n\n\n\n\n\e[5A"
##	for tmp in "${tmps[@]}"; do
##		let CNT++
##		echo -ne '\e[s'$(cat $tmp)'\e[u'
##		#cat $tmp
##		#tput sgr0
##	done
##	echo -ne '\e[4B'
##	} > ${LOGO_RENDERED}
##	rm /tmp/toolie.*
##fi

echo -e "$msg" | perl -wpe 'BEGIN {our $z=20+'${RANDOM: 0:2}';}; $z=$z+1; s/((?<![[:digit:]]|;|)[[:punct:]]|, |[-.]|^)/[22;1;38;5;${z}m$&[2m/g'

##will remain cached until someone deletes it (much faster this way!)
##cat ${LOGO_RENDERED}

if [[ $1 == --help ]]; then
        shopt -s xpg_echo
        echo ""
        echo "\e[30;1minternal configuration status\e[0m"
        echo
        tput setaf 150
        echo "translators (first letter = translator)"
        tput setaf 140
        echo "letter   value"
        tput setaf 235
        echo "-------+------------------------------------"
        for w in "${!translators[@]}"; do
                tput sgr0
                tput setaf 15${RANDOM:0:1}
              printf "%c        [2m%s\n" "$w" "${translators[$w]}"
        done
        echo
        tput sgr0
        tput setaf 150
        echo "modifiers (second letter)"
        tput setaf 140
        echo "letter   value"
        tput setaf 235
        echo "-------+------------------------------------"
        for w in "${!modifiers[@]}"; do
                tput sgr0
                tput setaf 15${RANDOM:0:1}

               printf "%c        %s\n" "$w" "${modifiers[$w]}"
        done
        echo "options special:"
        echo " --makelinks             makes links above mentioned in current dir"
        echo
        tput sgr0
        exit 1
fi
if [[ $1 == "--intervene" || $1 == "-i" ]]; then
	echo "-[-i]ntervene was chosen ($1), asking for change in translator..."
	echo
	for ntl in ${!translators[@]}; do
		echo -e "[32;1m${ntl}\t[0;2m=\t[0;32m${translators[$ntl]}[0m"
	done
	printf "[s"
	[[ $UID -le 1000 ]] && sudo modprobe pcspkr 2> /dev/null
	until [[ ${translators[$newindex]} != "" ]]; do
		[[ -n $newindex ]] && beep
		printf "[u[1;34m%s[2m:[0m" "pick new translator"
	done
	[[ $UID -le 1000 ]] && sudo modprobe -r pcspkr 2> /dev/null
	shift
fi


declare -g translator_idx=$( [[ ${#Z} -ge 1 ]] && echo ${Z: 0:1} || echo $default_translator )
declare -g modifier_idx=$( [[ ${#Z} -gt 1 ]] && echo ${Z: 1:1} || echo $default_modifier )
declare -g translator=${translators[$translator_idx]}
declare -g modifier=${modifiers[$modifier_idx]}
declare -g searchstring=$( n=0; for x; do [[ $n -gt 0 ]] && echo -ne '+'; let n++; echo -ne "$x"; done )
declare -ga cmdline=( "$translator" "$(printf "$modifier" "$searchstring")" )

echo -ne "checking for default translator..."
if [[ "$default_translator" == "" ]]; then
	echo "fail--default translator not set!"
else
	echo "ok"
fi
echo -ne "checking for default modifier..."
if [[ "$default_modifier" == "" ]]; then
	echo "fail--default modifier not set!"
else
	echo "ok"
	echo -ne "checking for valid indexes for modifiers and translators..."
	if [[ "$translator" == "" ]]; then
		echo "failed (FAIL_NO_TRANSLATOR)"
		exit 126
	else
		echo "ok(xlat,"
		if [[ "$modifier" == "" ]]; then
			echo "FAIL_NO_MODIFIER)"
			exit 127
		else
			echo "mod)"
		fi
	fi
fi

echo ""
echo "[2m items[22;1m:[11m"
echo "[2m       translator: $translator"
echo "[2m         modifier: $modifier"
echo "[2m indexes:"
echo "[2m       translator: $translator_idx"
echo "[2m         modifier: $modifier_idx"
echo "[2m      search text: $searchstring"
echo ""
echo "  result cmdline: [${cmdline[@]}]"
echo "  result command: (${#cmdline[@]} element(s))"
for x in "${cmdline[@]}"; do
echo "                  $x"
done
if [[ $T_NO_KEYWAIT == FALSE ]]; then
       echo "press a key"
       # - (set/remove T_NO_KEYWAIT=TRUE to turn off)
       read -sn1
else
        echo ""
        #sleep 1.25
        # it takes up to .75 seconds to run sleep, accounting for that
        # by waiting 1.25 + .75 = 2 seconds
fi

# evaluate this way because 1) shift only works on positional parameters
# and 2) because cmdline[0] could have more than one argument in itself
# NB: $cmdline without the array will default to cmdline[0] for us
# without the work, as does cmdline[1]:1 when referencing the inverse of
# the latter.
unset conditions
declare -g conditions="n"
# translate to condition codes for case evaluation(s)
((start_in_background)) && conditions=s
((remove_from_jobcontrol)) && conditions=r
((use_exec)) && conditions=x
((loop_and_prompt)) && conditions=l
# stackable conditions here
((example_stackable_item)) && conditions+=[example]
SECONDS=0
# evaluate cases
case $conditions in
	n)	${cmdline} "${cmdline[@]:1}"
		;;
	s)	${cmdline} "${cmdline[@]:1}" &
		;;
    x)  echo "started (PID=$PID PPID=$PPID)"
    	exec ${cmdline} "${cmdline[@]:1}"
    	;;
    r)	echo "removing ownership (not a child of $PID, now $PPID)"
    	${cmdline} "${cmdline[@]:1}" &> /dev/null & disown
    	;;
    l)  echo "starting..."
    	sleep 1
    	while true; do
    		read -p "${cmdline[0]} search> " CLINE
    		sleep 0.5
    		if [[ $CLINE =~ [EQeq][XUxu][Ii][Tt] ]]; then
    			echo "terminating loop by request of user..."
    			sleep 1
    			break
    		fi
    		echo "starting externally..."
    		sleep 0.5
    		$0 "LOOPACCESS" $CLINE &> /dev/null & disown
    		sleep 0.5
    		echo "started with parent $PPID as owner"
    		sleep 0.5
    		echo
    	done
    	;;
    *)
    	echo "SHOULDNOTHAPPEN: Unknown combination of conditions ($conditions), please contact your administrator or E-mail the author on this matter!"
    	exit 121
    	;;
esac
# only if execution phase lasted less than 3 seconds
if [[ $SECONDS -lt 3 ]]; then
    sleep 1.5
    # pause so any error could be read before return to shell
fi
echo ""
exit 0

