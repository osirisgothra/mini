#!/bin/bash

TTY="$(tty)"

function kdialog()
{
	# only use kdialog IF we dont have a tty (like running from an X based launcher)
	if [[ $TTY =~ (pts|tty) ]]; then
		case $1 in
			--msgbox)	shift; printf "[1m[ $* ]\n";;
			*) printf "kdlg: $*\n";;
		esac
	else
		command kdialog "$@"
	fi
}


function errexit()
{
	kdialog --msgbox "cant find surf anywhere! $*"
	echo "CANT FIND SURF!"
	exit 1
}

if [[ -r ~/.config/surflocation ]]; then
	SURFCACHE=~/.config/surflocation
else
	SURFCACHE="/tmp/surfloc.cached"
fi

if [[ ! -r "$SURFCACHE" ]]; then
	kdialog --msgbox "I am going to look for surf for you, and save the location!"
	echo "$SURFCACHE not found, looking for surf..."
	# note: "nlocate" does NOT search for just files (stupid right?) so we have to check em ourselves
	declare -a files=( `locate */surf` )
	declare -i index=0
	echo
	echo "Heres the list: ${files[@]}"
	echo
	while true; do
		nextfile=${files[index]}
		echo "now checking: $nextfile - to see if it is a file/executable/nondirectory"
		if [[ -f "$nextfile" ]] && [[ -x "$nextfile" ]] && [[ ! -d "$nextfile" ]]; then
			if diff "$nextfile" "$BASH_SOURCE"; then
				echo "$nextfile is THIS script, obviously not what we are looking for"
			else
				if file "$nextfile" | grep ELF; then
					echo "$nextfile verified as an ELF binary"
					break
				else
					echo "$nextfile is a script (possibly a different/modified version of THIS script)"
				fi
			fi
		fi
		let index++
		echo "no go, going to the next one.. (number $index in the list)"
		if [[ $index -gt "${#files[@]}" ]]; then
			# /dev/null is guarenteed to NEVER be executable POSIX-HFS specifications
			echo "FAILED, could NOT find one, so we have to use /dev/null to trip the checker"
			nextfile=/dev/null
			break
		fi
	done
	SURFLOC="$nextfile"
	if [[ ! -x "$SURFLOC" ]]; then
		errexit
	fi
	kdialog --msgbox "we made it, it was found at $SURFLOC and will be stored in $SURFCACHE until the next system reboot clears the cache"
	echo "found surf at $SURFLOC"
	echo "recording cache to $SURFLOC"
	echo "$SURFLOC" > "$SURFCACHE"
else
	SURFLOC=`cat $SURFCACHE`
	if [[ ! -x "$SURFLOC"  || ! -f "$SURFLOC" || -d "$SURFLOC" ]]; then
		rm -f "$SURFCACHE"
		errexit "The cache file was found, but it pointed to somewhere that didnt execute, the cache file has been deleted, try running again to perform the initial search"
	elif diff "$SURFLOC" "$BASH_SOURCE"; then
		rm -f "$SURFCACHE"
		errexit "The cache file points to this script, not okay (removing script file -- please try again)"
	elif file "$SURFLOC" | grep ELF; then
		echo "cached file $SURFLOC is an executable, binary file. Using it as the target file (and keeping in cache)"
	else
		echo "file $SURFLOC is not a binary executable, removing it (please try again!)"
		rm -f "$SURFCACHE"
		errexit "failed to execute any valid cache file, please start this program again to rescan!"
	fi
fi
# at this point $SURFLOC will have a valid, executable location, no matter what
# execution problems are now the problem of the binary, not us
# our script is called 'surf' so we can safely 'exec' into it to keep
# the expected PID when we were launched, this is required for startup
# notification on some systems to work correctly (and monitoring apps)
exec "$SURFLOC" "$@"
